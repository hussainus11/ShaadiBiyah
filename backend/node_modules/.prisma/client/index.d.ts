
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Vendor
 * 
 */
export type Vendor = $Result.DefaultSelection<Prisma.$VendorPayload>
/**
 * Model Service
 * 
 */
export type Service = $Result.DefaultSelection<Prisma.$ServicePayload>
/**
 * Model Booking
 * 
 */
export type Booking = $Result.DefaultSelection<Prisma.$BookingPayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model Message
 * 
 */
export type Message = $Result.DefaultSelection<Prisma.$MessagePayload>
/**
 * Model ChatSession
 * 
 */
export type ChatSession = $Result.DefaultSelection<Prisma.$ChatSessionPayload>
/**
 * Model Review
 * 
 */
export type Review = $Result.DefaultSelection<Prisma.$ReviewPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model WeddingChecklist
 * 
 */
export type WeddingChecklist = $Result.DefaultSelection<Prisma.$WeddingChecklistPayload>
/**
 * Model AIConversation
 * 
 */
export type AIConversation = $Result.DefaultSelection<Prisma.$AIConversationPayload>
/**
 * Model MatrimonialProfile
 * 
 */
export type MatrimonialProfile = $Result.DefaultSelection<Prisma.$MatrimonialProfilePayload>
/**
 * Model MatrimonialMessage
 * 
 */
export type MatrimonialMessage = $Result.DefaultSelection<Prisma.$MatrimonialMessagePayload>
/**
 * Model VendorVerificationDocument
 * 
 */
export type VendorVerificationDocument = $Result.DefaultSelection<Prisma.$VendorVerificationDocumentPayload>
/**
 * Model VendorDynamicField
 * 
 */
export type VendorDynamicField = $Result.DefaultSelection<Prisma.$VendorDynamicFieldPayload>
/**
 * Model PackageDynamicField
 * 
 */
export type PackageDynamicField = $Result.DefaultSelection<Prisma.$PackageDynamicFieldPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  USER: 'USER',
  VENDOR: 'VENDOR',
  ADMIN: 'ADMIN'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const VendorCategory: {
  VENUE: 'VENUE',
  CATERER: 'CATERER',
  PHOTOGRAPHER: 'PHOTOGRAPHER',
  DECORATOR: 'DECORATOR',
  MAKEUP_ARTIST: 'MAKEUP_ARTIST',
  DJ: 'DJ',
  TRANSPORT: 'TRANSPORT',
  FLORIST: 'FLORIST',
  WEDDING_PLANNER: 'WEDDING_PLANNER',
  OTHER: 'OTHER'
};

export type VendorCategory = (typeof VendorCategory)[keyof typeof VendorCategory]


export const VerificationStatus: {
  PENDING: 'PENDING',
  DOCUMENT_SENT: 'DOCUMENT_SENT',
  DOCUMENT_SIGNED: 'DOCUMENT_SIGNED',
  VERIFIED: 'VERIFIED',
  REJECTED: 'REJECTED',
  EXPIRED: 'EXPIRED'
};

export type VerificationStatus = (typeof VerificationStatus)[keyof typeof VerificationStatus]


export const BookingStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED',
  CONFIRMED: 'CONFIRMED',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type BookingStatus = (typeof BookingStatus)[keyof typeof BookingStatus]


export const PaymentStatus: {
  PENDING: 'PENDING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  REFUNDED: 'REFUNDED'
};

export type PaymentStatus = (typeof PaymentStatus)[keyof typeof PaymentStatus]


export const Gender: {
  MALE: 'MALE',
  FEMALE: 'FEMALE',
  OTHER: 'OTHER'
};

export type Gender = (typeof Gender)[keyof typeof Gender]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type VendorCategory = $Enums.VendorCategory

export const VendorCategory: typeof $Enums.VendorCategory

export type VerificationStatus = $Enums.VerificationStatus

export const VerificationStatus: typeof $Enums.VerificationStatus

export type BookingStatus = $Enums.BookingStatus

export const BookingStatus: typeof $Enums.BookingStatus

export type PaymentStatus = $Enums.PaymentStatus

export const PaymentStatus: typeof $Enums.PaymentStatus

export type Gender = $Enums.Gender

export const Gender: typeof $Enums.Gender

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.vendor`: Exposes CRUD operations for the **Vendor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vendors
    * const vendors = await prisma.vendor.findMany()
    * ```
    */
  get vendor(): Prisma.VendorDelegate<ExtArgs>;

  /**
   * `prisma.service`: Exposes CRUD operations for the **Service** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Services
    * const services = await prisma.service.findMany()
    * ```
    */
  get service(): Prisma.ServiceDelegate<ExtArgs>;

  /**
   * `prisma.booking`: Exposes CRUD operations for the **Booking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bookings
    * const bookings = await prisma.booking.findMany()
    * ```
    */
  get booking(): Prisma.BookingDelegate<ExtArgs>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<ExtArgs>;

  /**
   * `prisma.chatSession`: Exposes CRUD operations for the **ChatSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChatSessions
    * const chatSessions = await prisma.chatSession.findMany()
    * ```
    */
  get chatSession(): Prisma.ChatSessionDelegate<ExtArgs>;

  /**
   * `prisma.review`: Exposes CRUD operations for the **Review** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reviews
    * const reviews = await prisma.review.findMany()
    * ```
    */
  get review(): Prisma.ReviewDelegate<ExtArgs>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs>;

  /**
   * `prisma.weddingChecklist`: Exposes CRUD operations for the **WeddingChecklist** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WeddingChecklists
    * const weddingChecklists = await prisma.weddingChecklist.findMany()
    * ```
    */
  get weddingChecklist(): Prisma.WeddingChecklistDelegate<ExtArgs>;

  /**
   * `prisma.aIConversation`: Exposes CRUD operations for the **AIConversation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AIConversations
    * const aIConversations = await prisma.aIConversation.findMany()
    * ```
    */
  get aIConversation(): Prisma.AIConversationDelegate<ExtArgs>;

  /**
   * `prisma.matrimonialProfile`: Exposes CRUD operations for the **MatrimonialProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MatrimonialProfiles
    * const matrimonialProfiles = await prisma.matrimonialProfile.findMany()
    * ```
    */
  get matrimonialProfile(): Prisma.MatrimonialProfileDelegate<ExtArgs>;

  /**
   * `prisma.matrimonialMessage`: Exposes CRUD operations for the **MatrimonialMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MatrimonialMessages
    * const matrimonialMessages = await prisma.matrimonialMessage.findMany()
    * ```
    */
  get matrimonialMessage(): Prisma.MatrimonialMessageDelegate<ExtArgs>;

  /**
   * `prisma.vendorVerificationDocument`: Exposes CRUD operations for the **VendorVerificationDocument** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VendorVerificationDocuments
    * const vendorVerificationDocuments = await prisma.vendorVerificationDocument.findMany()
    * ```
    */
  get vendorVerificationDocument(): Prisma.VendorVerificationDocumentDelegate<ExtArgs>;

  /**
   * `prisma.vendorDynamicField`: Exposes CRUD operations for the **VendorDynamicField** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VendorDynamicFields
    * const vendorDynamicFields = await prisma.vendorDynamicField.findMany()
    * ```
    */
  get vendorDynamicField(): Prisma.VendorDynamicFieldDelegate<ExtArgs>;

  /**
   * `prisma.packageDynamicField`: Exposes CRUD operations for the **PackageDynamicField** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PackageDynamicFields
    * const packageDynamicFields = await prisma.packageDynamicField.findMany()
    * ```
    */
  get packageDynamicField(): Prisma.PackageDynamicFieldDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Vendor: 'Vendor',
    Service: 'Service',
    Booking: 'Booking',
    Payment: 'Payment',
    Message: 'Message',
    ChatSession: 'ChatSession',
    Review: 'Review',
    Notification: 'Notification',
    WeddingChecklist: 'WeddingChecklist',
    AIConversation: 'AIConversation',
    MatrimonialProfile: 'MatrimonialProfile',
    MatrimonialMessage: 'MatrimonialMessage',
    VendorVerificationDocument: 'VendorVerificationDocument',
    VendorDynamicField: 'VendorDynamicField',
    PackageDynamicField: 'PackageDynamicField'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "vendor" | "service" | "booking" | "payment" | "message" | "chatSession" | "review" | "notification" | "weddingChecklist" | "aIConversation" | "matrimonialProfile" | "matrimonialMessage" | "vendorVerificationDocument" | "vendorDynamicField" | "packageDynamicField"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Vendor: {
        payload: Prisma.$VendorPayload<ExtArgs>
        fields: Prisma.VendorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VendorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VendorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          findFirst: {
            args: Prisma.VendorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VendorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          findMany: {
            args: Prisma.VendorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>[]
          }
          create: {
            args: Prisma.VendorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          createMany: {
            args: Prisma.VendorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VendorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>[]
          }
          delete: {
            args: Prisma.VendorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          update: {
            args: Prisma.VendorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          deleteMany: {
            args: Prisma.VendorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VendorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VendorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          aggregate: {
            args: Prisma.VendorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVendor>
          }
          groupBy: {
            args: Prisma.VendorGroupByArgs<ExtArgs>
            result: $Utils.Optional<VendorGroupByOutputType>[]
          }
          count: {
            args: Prisma.VendorCountArgs<ExtArgs>
            result: $Utils.Optional<VendorCountAggregateOutputType> | number
          }
        }
      }
      Service: {
        payload: Prisma.$ServicePayload<ExtArgs>
        fields: Prisma.ServiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findFirst: {
            args: Prisma.ServiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findMany: {
            args: Prisma.ServiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          create: {
            args: Prisma.ServiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          createMany: {
            args: Prisma.ServiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          delete: {
            args: Prisma.ServiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          update: {
            args: Prisma.ServiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          deleteMany: {
            args: Prisma.ServiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ServiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          aggregate: {
            args: Prisma.ServiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateService>
          }
          groupBy: {
            args: Prisma.ServiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceCountAggregateOutputType> | number
          }
        }
      }
      Booking: {
        payload: Prisma.$BookingPayload<ExtArgs>
        fields: Prisma.BookingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BookingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          findFirst: {
            args: Prisma.BookingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          findMany: {
            args: Prisma.BookingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>[]
          }
          create: {
            args: Prisma.BookingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          createMany: {
            args: Prisma.BookingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BookingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>[]
          }
          delete: {
            args: Prisma.BookingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          update: {
            args: Prisma.BookingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          deleteMany: {
            args: Prisma.BookingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BookingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BookingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          aggregate: {
            args: Prisma.BookingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBooking>
          }
          groupBy: {
            args: Prisma.BookingGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookingGroupByOutputType>[]
          }
          count: {
            args: Prisma.BookingCountArgs<ExtArgs>
            result: $Utils.Optional<BookingCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      Message: {
        payload: Prisma.$MessagePayload<ExtArgs>
        fields: Prisma.MessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findFirst: {
            args: Prisma.MessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findMany: {
            args: Prisma.MessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          create: {
            args: Prisma.MessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          createMany: {
            args: Prisma.MessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          delete: {
            args: Prisma.MessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          update: {
            args: Prisma.MessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          deleteMany: {
            args: Prisma.MessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessage>
          }
          groupBy: {
            args: Prisma.MessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageCountArgs<ExtArgs>
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
          }
        }
      }
      ChatSession: {
        payload: Prisma.$ChatSessionPayload<ExtArgs>
        fields: Prisma.ChatSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChatSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChatSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatSessionPayload>
          }
          findFirst: {
            args: Prisma.ChatSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChatSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatSessionPayload>
          }
          findMany: {
            args: Prisma.ChatSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatSessionPayload>[]
          }
          create: {
            args: Prisma.ChatSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatSessionPayload>
          }
          createMany: {
            args: Prisma.ChatSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChatSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatSessionPayload>[]
          }
          delete: {
            args: Prisma.ChatSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatSessionPayload>
          }
          update: {
            args: Prisma.ChatSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatSessionPayload>
          }
          deleteMany: {
            args: Prisma.ChatSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChatSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ChatSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatSessionPayload>
          }
          aggregate: {
            args: Prisma.ChatSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChatSession>
          }
          groupBy: {
            args: Prisma.ChatSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChatSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChatSessionCountArgs<ExtArgs>
            result: $Utils.Optional<ChatSessionCountAggregateOutputType> | number
          }
        }
      }
      Review: {
        payload: Prisma.$ReviewPayload<ExtArgs>
        fields: Prisma.ReviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReviewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReviewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findFirst: {
            args: Prisma.ReviewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReviewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findMany: {
            args: Prisma.ReviewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          create: {
            args: Prisma.ReviewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          createMany: {
            args: Prisma.ReviewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReviewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          delete: {
            args: Prisma.ReviewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          update: {
            args: Prisma.ReviewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          deleteMany: {
            args: Prisma.ReviewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReviewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReviewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          aggregate: {
            args: Prisma.ReviewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReview>
          }
          groupBy: {
            args: Prisma.ReviewGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReviewCountArgs<ExtArgs>
            result: $Utils.Optional<ReviewCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      WeddingChecklist: {
        payload: Prisma.$WeddingChecklistPayload<ExtArgs>
        fields: Prisma.WeddingChecklistFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WeddingChecklistFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeddingChecklistPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WeddingChecklistFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeddingChecklistPayload>
          }
          findFirst: {
            args: Prisma.WeddingChecklistFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeddingChecklistPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WeddingChecklistFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeddingChecklistPayload>
          }
          findMany: {
            args: Prisma.WeddingChecklistFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeddingChecklistPayload>[]
          }
          create: {
            args: Prisma.WeddingChecklistCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeddingChecklistPayload>
          }
          createMany: {
            args: Prisma.WeddingChecklistCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WeddingChecklistCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeddingChecklistPayload>[]
          }
          delete: {
            args: Prisma.WeddingChecklistDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeddingChecklistPayload>
          }
          update: {
            args: Prisma.WeddingChecklistUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeddingChecklistPayload>
          }
          deleteMany: {
            args: Prisma.WeddingChecklistDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WeddingChecklistUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WeddingChecklistUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeddingChecklistPayload>
          }
          aggregate: {
            args: Prisma.WeddingChecklistAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWeddingChecklist>
          }
          groupBy: {
            args: Prisma.WeddingChecklistGroupByArgs<ExtArgs>
            result: $Utils.Optional<WeddingChecklistGroupByOutputType>[]
          }
          count: {
            args: Prisma.WeddingChecklistCountArgs<ExtArgs>
            result: $Utils.Optional<WeddingChecklistCountAggregateOutputType> | number
          }
        }
      }
      AIConversation: {
        payload: Prisma.$AIConversationPayload<ExtArgs>
        fields: Prisma.AIConversationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AIConversationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIConversationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AIConversationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIConversationPayload>
          }
          findFirst: {
            args: Prisma.AIConversationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIConversationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AIConversationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIConversationPayload>
          }
          findMany: {
            args: Prisma.AIConversationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIConversationPayload>[]
          }
          create: {
            args: Prisma.AIConversationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIConversationPayload>
          }
          createMany: {
            args: Prisma.AIConversationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AIConversationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIConversationPayload>[]
          }
          delete: {
            args: Prisma.AIConversationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIConversationPayload>
          }
          update: {
            args: Prisma.AIConversationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIConversationPayload>
          }
          deleteMany: {
            args: Prisma.AIConversationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AIConversationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AIConversationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIConversationPayload>
          }
          aggregate: {
            args: Prisma.AIConversationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAIConversation>
          }
          groupBy: {
            args: Prisma.AIConversationGroupByArgs<ExtArgs>
            result: $Utils.Optional<AIConversationGroupByOutputType>[]
          }
          count: {
            args: Prisma.AIConversationCountArgs<ExtArgs>
            result: $Utils.Optional<AIConversationCountAggregateOutputType> | number
          }
        }
      }
      MatrimonialProfile: {
        payload: Prisma.$MatrimonialProfilePayload<ExtArgs>
        fields: Prisma.MatrimonialProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MatrimonialProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatrimonialProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MatrimonialProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatrimonialProfilePayload>
          }
          findFirst: {
            args: Prisma.MatrimonialProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatrimonialProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MatrimonialProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatrimonialProfilePayload>
          }
          findMany: {
            args: Prisma.MatrimonialProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatrimonialProfilePayload>[]
          }
          create: {
            args: Prisma.MatrimonialProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatrimonialProfilePayload>
          }
          createMany: {
            args: Prisma.MatrimonialProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MatrimonialProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatrimonialProfilePayload>[]
          }
          delete: {
            args: Prisma.MatrimonialProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatrimonialProfilePayload>
          }
          update: {
            args: Prisma.MatrimonialProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatrimonialProfilePayload>
          }
          deleteMany: {
            args: Prisma.MatrimonialProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MatrimonialProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MatrimonialProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatrimonialProfilePayload>
          }
          aggregate: {
            args: Prisma.MatrimonialProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMatrimonialProfile>
          }
          groupBy: {
            args: Prisma.MatrimonialProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<MatrimonialProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.MatrimonialProfileCountArgs<ExtArgs>
            result: $Utils.Optional<MatrimonialProfileCountAggregateOutputType> | number
          }
        }
      }
      MatrimonialMessage: {
        payload: Prisma.$MatrimonialMessagePayload<ExtArgs>
        fields: Prisma.MatrimonialMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MatrimonialMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatrimonialMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MatrimonialMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatrimonialMessagePayload>
          }
          findFirst: {
            args: Prisma.MatrimonialMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatrimonialMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MatrimonialMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatrimonialMessagePayload>
          }
          findMany: {
            args: Prisma.MatrimonialMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatrimonialMessagePayload>[]
          }
          create: {
            args: Prisma.MatrimonialMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatrimonialMessagePayload>
          }
          createMany: {
            args: Prisma.MatrimonialMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MatrimonialMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatrimonialMessagePayload>[]
          }
          delete: {
            args: Prisma.MatrimonialMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatrimonialMessagePayload>
          }
          update: {
            args: Prisma.MatrimonialMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatrimonialMessagePayload>
          }
          deleteMany: {
            args: Prisma.MatrimonialMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MatrimonialMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MatrimonialMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatrimonialMessagePayload>
          }
          aggregate: {
            args: Prisma.MatrimonialMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMatrimonialMessage>
          }
          groupBy: {
            args: Prisma.MatrimonialMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MatrimonialMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MatrimonialMessageCountArgs<ExtArgs>
            result: $Utils.Optional<MatrimonialMessageCountAggregateOutputType> | number
          }
        }
      }
      VendorVerificationDocument: {
        payload: Prisma.$VendorVerificationDocumentPayload<ExtArgs>
        fields: Prisma.VendorVerificationDocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VendorVerificationDocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorVerificationDocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VendorVerificationDocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorVerificationDocumentPayload>
          }
          findFirst: {
            args: Prisma.VendorVerificationDocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorVerificationDocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VendorVerificationDocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorVerificationDocumentPayload>
          }
          findMany: {
            args: Prisma.VendorVerificationDocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorVerificationDocumentPayload>[]
          }
          create: {
            args: Prisma.VendorVerificationDocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorVerificationDocumentPayload>
          }
          createMany: {
            args: Prisma.VendorVerificationDocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VendorVerificationDocumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorVerificationDocumentPayload>[]
          }
          delete: {
            args: Prisma.VendorVerificationDocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorVerificationDocumentPayload>
          }
          update: {
            args: Prisma.VendorVerificationDocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorVerificationDocumentPayload>
          }
          deleteMany: {
            args: Prisma.VendorVerificationDocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VendorVerificationDocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VendorVerificationDocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorVerificationDocumentPayload>
          }
          aggregate: {
            args: Prisma.VendorVerificationDocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVendorVerificationDocument>
          }
          groupBy: {
            args: Prisma.VendorVerificationDocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<VendorVerificationDocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.VendorVerificationDocumentCountArgs<ExtArgs>
            result: $Utils.Optional<VendorVerificationDocumentCountAggregateOutputType> | number
          }
        }
      }
      VendorDynamicField: {
        payload: Prisma.$VendorDynamicFieldPayload<ExtArgs>
        fields: Prisma.VendorDynamicFieldFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VendorDynamicFieldFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorDynamicFieldPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VendorDynamicFieldFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorDynamicFieldPayload>
          }
          findFirst: {
            args: Prisma.VendorDynamicFieldFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorDynamicFieldPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VendorDynamicFieldFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorDynamicFieldPayload>
          }
          findMany: {
            args: Prisma.VendorDynamicFieldFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorDynamicFieldPayload>[]
          }
          create: {
            args: Prisma.VendorDynamicFieldCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorDynamicFieldPayload>
          }
          createMany: {
            args: Prisma.VendorDynamicFieldCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VendorDynamicFieldCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorDynamicFieldPayload>[]
          }
          delete: {
            args: Prisma.VendorDynamicFieldDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorDynamicFieldPayload>
          }
          update: {
            args: Prisma.VendorDynamicFieldUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorDynamicFieldPayload>
          }
          deleteMany: {
            args: Prisma.VendorDynamicFieldDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VendorDynamicFieldUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VendorDynamicFieldUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorDynamicFieldPayload>
          }
          aggregate: {
            args: Prisma.VendorDynamicFieldAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVendorDynamicField>
          }
          groupBy: {
            args: Prisma.VendorDynamicFieldGroupByArgs<ExtArgs>
            result: $Utils.Optional<VendorDynamicFieldGroupByOutputType>[]
          }
          count: {
            args: Prisma.VendorDynamicFieldCountArgs<ExtArgs>
            result: $Utils.Optional<VendorDynamicFieldCountAggregateOutputType> | number
          }
        }
      }
      PackageDynamicField: {
        payload: Prisma.$PackageDynamicFieldPayload<ExtArgs>
        fields: Prisma.PackageDynamicFieldFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PackageDynamicFieldFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackageDynamicFieldPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PackageDynamicFieldFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackageDynamicFieldPayload>
          }
          findFirst: {
            args: Prisma.PackageDynamicFieldFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackageDynamicFieldPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PackageDynamicFieldFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackageDynamicFieldPayload>
          }
          findMany: {
            args: Prisma.PackageDynamicFieldFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackageDynamicFieldPayload>[]
          }
          create: {
            args: Prisma.PackageDynamicFieldCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackageDynamicFieldPayload>
          }
          createMany: {
            args: Prisma.PackageDynamicFieldCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PackageDynamicFieldCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackageDynamicFieldPayload>[]
          }
          delete: {
            args: Prisma.PackageDynamicFieldDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackageDynamicFieldPayload>
          }
          update: {
            args: Prisma.PackageDynamicFieldUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackageDynamicFieldPayload>
          }
          deleteMany: {
            args: Prisma.PackageDynamicFieldDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PackageDynamicFieldUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PackageDynamicFieldUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackageDynamicFieldPayload>
          }
          aggregate: {
            args: Prisma.PackageDynamicFieldAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePackageDynamicField>
          }
          groupBy: {
            args: Prisma.PackageDynamicFieldGroupByArgs<ExtArgs>
            result: $Utils.Optional<PackageDynamicFieldGroupByOutputType>[]
          }
          count: {
            args: Prisma.PackageDynamicFieldCountArgs<ExtArgs>
            result: $Utils.Optional<PackageDynamicFieldCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    bookings: number
    sentMessages: number
    receivedMessages: number
    reviews: number
    notifications: number
    chatSessions: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | UserCountOutputTypeCountBookingsArgs
    sentMessages?: boolean | UserCountOutputTypeCountSentMessagesArgs
    receivedMessages?: boolean | UserCountOutputTypeCountReceivedMessagesArgs
    reviews?: boolean | UserCountOutputTypeCountReviewsArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    chatSessions?: boolean | UserCountOutputTypeCountChatSessionsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSentMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReceivedMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountChatSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatSessionWhereInput
  }


  /**
   * Count Type VendorCountOutputType
   */

  export type VendorCountOutputType = {
    bookings: number
    services: number
    reviews: number
    chatSessions: number
    verificationDocuments: number
    dynamicFields: number
  }

  export type VendorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | VendorCountOutputTypeCountBookingsArgs
    services?: boolean | VendorCountOutputTypeCountServicesArgs
    reviews?: boolean | VendorCountOutputTypeCountReviewsArgs
    chatSessions?: boolean | VendorCountOutputTypeCountChatSessionsArgs
    verificationDocuments?: boolean | VendorCountOutputTypeCountVerificationDocumentsArgs
    dynamicFields?: boolean | VendorCountOutputTypeCountDynamicFieldsArgs
  }

  // Custom InputTypes
  /**
   * VendorCountOutputType without action
   */
  export type VendorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorCountOutputType
     */
    select?: VendorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VendorCountOutputType without action
   */
  export type VendorCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }

  /**
   * VendorCountOutputType without action
   */
  export type VendorCountOutputTypeCountServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
  }

  /**
   * VendorCountOutputType without action
   */
  export type VendorCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
  }

  /**
   * VendorCountOutputType without action
   */
  export type VendorCountOutputTypeCountChatSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatSessionWhereInput
  }

  /**
   * VendorCountOutputType without action
   */
  export type VendorCountOutputTypeCountVerificationDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VendorVerificationDocumentWhereInput
  }

  /**
   * VendorCountOutputType without action
   */
  export type VendorCountOutputTypeCountDynamicFieldsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VendorDynamicFieldWhereInput
  }


  /**
   * Count Type ServiceCountOutputType
   */

  export type ServiceCountOutputType = {
    bookings: number
  }

  export type ServiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | ServiceCountOutputTypeCountBookingsArgs
  }

  // Custom InputTypes
  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCountOutputType
     */
    select?: ServiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }


  /**
   * Count Type BookingCountOutputType
   */

  export type BookingCountOutputType = {
    payments: number
    messages: number
  }

  export type BookingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payments?: boolean | BookingCountOutputTypeCountPaymentsArgs
    messages?: boolean | BookingCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes
  /**
   * BookingCountOutputType without action
   */
  export type BookingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingCountOutputType
     */
    select?: BookingCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BookingCountOutputType without action
   */
  export type BookingCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * BookingCountOutputType without action
   */
  export type BookingCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }


  /**
   * Count Type MatrimonialProfileCountOutputType
   */

  export type MatrimonialProfileCountOutputType = {
    sentMessages: number
    receivedMessages: number
  }

  export type MatrimonialProfileCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sentMessages?: boolean | MatrimonialProfileCountOutputTypeCountSentMessagesArgs
    receivedMessages?: boolean | MatrimonialProfileCountOutputTypeCountReceivedMessagesArgs
  }

  // Custom InputTypes
  /**
   * MatrimonialProfileCountOutputType without action
   */
  export type MatrimonialProfileCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatrimonialProfileCountOutputType
     */
    select?: MatrimonialProfileCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MatrimonialProfileCountOutputType without action
   */
  export type MatrimonialProfileCountOutputTypeCountSentMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatrimonialMessageWhereInput
  }

  /**
   * MatrimonialProfileCountOutputType without action
   */
  export type MatrimonialProfileCountOutputTypeCountReceivedMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatrimonialMessageWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    budget: number | null
  }

  export type UserSumAggregateOutputType = {
    budget: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    firstName: string | null
    lastName: string | null
    phone: string | null
    role: $Enums.UserRole | null
    isVerified: boolean | null
    profileImage: string | null
    weddingDate: Date | null
    budget: number | null
    location: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    firstName: string | null
    lastName: string | null
    phone: string | null
    role: $Enums.UserRole | null
    isVerified: boolean | null
    profileImage: string | null
    weddingDate: Date | null
    budget: number | null
    location: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    firstName: number
    lastName: number
    phone: number
    role: number
    isVerified: number
    profileImage: number
    weddingDate: number
    budget: number
    location: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    budget?: true
  }

  export type UserSumAggregateInputType = {
    budget?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    firstName?: true
    lastName?: true
    phone?: true
    role?: true
    isVerified?: true
    profileImage?: true
    weddingDate?: true
    budget?: true
    location?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    firstName?: true
    lastName?: true
    phone?: true
    role?: true
    isVerified?: true
    profileImage?: true
    weddingDate?: true
    budget?: true
    location?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    firstName?: true
    lastName?: true
    phone?: true
    role?: true
    isVerified?: true
    profileImage?: true
    weddingDate?: true
    budget?: true
    location?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    password: string
    firstName: string
    lastName: string
    phone: string | null
    role: $Enums.UserRole
    isVerified: boolean
    profileImage: string | null
    weddingDate: Date | null
    budget: number | null
    location: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    role?: boolean
    isVerified?: boolean
    profileImage?: boolean
    weddingDate?: boolean
    budget?: boolean
    location?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bookings?: boolean | User$bookingsArgs<ExtArgs>
    sentMessages?: boolean | User$sentMessagesArgs<ExtArgs>
    receivedMessages?: boolean | User$receivedMessagesArgs<ExtArgs>
    reviews?: boolean | User$reviewsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    chatSessions?: boolean | User$chatSessionsArgs<ExtArgs>
    vendor?: boolean | User$vendorArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    role?: boolean
    isVerified?: boolean
    profileImage?: boolean
    weddingDate?: boolean
    budget?: boolean
    location?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    role?: boolean
    isVerified?: boolean
    profileImage?: boolean
    weddingDate?: boolean
    budget?: boolean
    location?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | User$bookingsArgs<ExtArgs>
    sentMessages?: boolean | User$sentMessagesArgs<ExtArgs>
    receivedMessages?: boolean | User$receivedMessagesArgs<ExtArgs>
    reviews?: boolean | User$reviewsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    chatSessions?: boolean | User$chatSessionsArgs<ExtArgs>
    vendor?: boolean | User$vendorArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      bookings: Prisma.$BookingPayload<ExtArgs>[]
      sentMessages: Prisma.$MessagePayload<ExtArgs>[]
      receivedMessages: Prisma.$MessagePayload<ExtArgs>[]
      reviews: Prisma.$ReviewPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      chatSessions: Prisma.$ChatSessionPayload<ExtArgs>[]
      vendor: Prisma.$VendorPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      password: string
      firstName: string
      lastName: string
      phone: string | null
      role: $Enums.UserRole
      isVerified: boolean
      profileImage: string | null
      weddingDate: Date | null
      budget: number | null
      location: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bookings<T extends User$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, User$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany"> | Null>
    sentMessages<T extends User$sentMessagesArgs<ExtArgs> = {}>(args?: Subset<T, User$sentMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany"> | Null>
    receivedMessages<T extends User$receivedMessagesArgs<ExtArgs> = {}>(args?: Subset<T, User$receivedMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany"> | Null>
    reviews<T extends User$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, User$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany"> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany"> | Null>
    chatSessions<T extends User$chatSessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$chatSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatSessionPayload<ExtArgs>, T, "findMany"> | Null>
    vendor<T extends User$vendorArgs<ExtArgs> = {}>(args?: Subset<T, User$vendorArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly isVerified: FieldRef<"User", 'Boolean'>
    readonly profileImage: FieldRef<"User", 'String'>
    readonly weddingDate: FieldRef<"User", 'DateTime'>
    readonly budget: FieldRef<"User", 'Float'>
    readonly location: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.bookings
   */
  export type User$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * User.sentMessages
   */
  export type User$sentMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * User.receivedMessages
   */
  export type User$receivedMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * User.reviews
   */
  export type User$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.chatSessions
   */
  export type User$chatSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatSession
     */
    select?: ChatSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatSessionInclude<ExtArgs> | null
    where?: ChatSessionWhereInput
    orderBy?: ChatSessionOrderByWithRelationInput | ChatSessionOrderByWithRelationInput[]
    cursor?: ChatSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatSessionScalarFieldEnum | ChatSessionScalarFieldEnum[]
  }

  /**
   * User.vendor
   */
  export type User$vendorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    where?: VendorWhereInput
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Vendor
   */

  export type AggregateVendor = {
    _count: VendorCountAggregateOutputType | null
    _avg: VendorAvgAggregateOutputType | null
    _sum: VendorSumAggregateOutputType | null
    _min: VendorMinAggregateOutputType | null
    _max: VendorMaxAggregateOutputType | null
  }

  export type VendorAvgAggregateOutputType = {
    experience: number | null
    rating: number | null
    totalReviews: number | null
    basePrice: number | null
  }

  export type VendorSumAggregateOutputType = {
    experience: number | null
    rating: number | null
    totalReviews: number | null
    basePrice: number | null
  }

  export type VendorMinAggregateOutputType = {
    id: string | null
    userId: string | null
    businessName: string | null
    category: $Enums.VendorCategory | null
    description: string | null
    location: string | null
    phone: string | null
    email: string | null
    website: string | null
    experience: number | null
    rating: number | null
    totalReviews: number | null
    isVerified: boolean | null
    isActive: boolean | null
    verificationStatus: $Enums.VerificationStatus | null
    documentSignedAt: Date | null
    verificationNotes: string | null
    basePrice: number | null
    priceRange: string | null
    profileImage: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VendorMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    businessName: string | null
    category: $Enums.VendorCategory | null
    description: string | null
    location: string | null
    phone: string | null
    email: string | null
    website: string | null
    experience: number | null
    rating: number | null
    totalReviews: number | null
    isVerified: boolean | null
    isActive: boolean | null
    verificationStatus: $Enums.VerificationStatus | null
    documentSignedAt: Date | null
    verificationNotes: string | null
    basePrice: number | null
    priceRange: string | null
    profileImage: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VendorCountAggregateOutputType = {
    id: number
    userId: number
    businessName: number
    category: number
    description: number
    location: number
    phone: number
    email: number
    website: number
    experience: number
    rating: number
    totalReviews: number
    isVerified: number
    isActive: number
    verificationStatus: number
    documentSignedAt: number
    verificationNotes: number
    basePrice: number
    priceRange: number
    profileImage: number
    gallery: number
    availability: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VendorAvgAggregateInputType = {
    experience?: true
    rating?: true
    totalReviews?: true
    basePrice?: true
  }

  export type VendorSumAggregateInputType = {
    experience?: true
    rating?: true
    totalReviews?: true
    basePrice?: true
  }

  export type VendorMinAggregateInputType = {
    id?: true
    userId?: true
    businessName?: true
    category?: true
    description?: true
    location?: true
    phone?: true
    email?: true
    website?: true
    experience?: true
    rating?: true
    totalReviews?: true
    isVerified?: true
    isActive?: true
    verificationStatus?: true
    documentSignedAt?: true
    verificationNotes?: true
    basePrice?: true
    priceRange?: true
    profileImage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VendorMaxAggregateInputType = {
    id?: true
    userId?: true
    businessName?: true
    category?: true
    description?: true
    location?: true
    phone?: true
    email?: true
    website?: true
    experience?: true
    rating?: true
    totalReviews?: true
    isVerified?: true
    isActive?: true
    verificationStatus?: true
    documentSignedAt?: true
    verificationNotes?: true
    basePrice?: true
    priceRange?: true
    profileImage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VendorCountAggregateInputType = {
    id?: true
    userId?: true
    businessName?: true
    category?: true
    description?: true
    location?: true
    phone?: true
    email?: true
    website?: true
    experience?: true
    rating?: true
    totalReviews?: true
    isVerified?: true
    isActive?: true
    verificationStatus?: true
    documentSignedAt?: true
    verificationNotes?: true
    basePrice?: true
    priceRange?: true
    profileImage?: true
    gallery?: true
    availability?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VendorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vendor to aggregate.
     */
    where?: VendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendors to fetch.
     */
    orderBy?: VendorOrderByWithRelationInput | VendorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Vendors
    **/
    _count?: true | VendorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VendorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VendorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VendorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VendorMaxAggregateInputType
  }

  export type GetVendorAggregateType<T extends VendorAggregateArgs> = {
        [P in keyof T & keyof AggregateVendor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVendor[P]>
      : GetScalarType<T[P], AggregateVendor[P]>
  }




  export type VendorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VendorWhereInput
    orderBy?: VendorOrderByWithAggregationInput | VendorOrderByWithAggregationInput[]
    by: VendorScalarFieldEnum[] | VendorScalarFieldEnum
    having?: VendorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VendorCountAggregateInputType | true
    _avg?: VendorAvgAggregateInputType
    _sum?: VendorSumAggregateInputType
    _min?: VendorMinAggregateInputType
    _max?: VendorMaxAggregateInputType
  }

  export type VendorGroupByOutputType = {
    id: string
    userId: string
    businessName: string
    category: $Enums.VendorCategory
    description: string
    location: string
    phone: string
    email: string
    website: string | null
    experience: number
    rating: number
    totalReviews: number
    isVerified: boolean
    isActive: boolean
    verificationStatus: $Enums.VerificationStatus
    documentSignedAt: Date | null
    verificationNotes: string | null
    basePrice: number | null
    priceRange: string | null
    profileImage: string | null
    gallery: string[]
    availability: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: VendorCountAggregateOutputType | null
    _avg: VendorAvgAggregateOutputType | null
    _sum: VendorSumAggregateOutputType | null
    _min: VendorMinAggregateOutputType | null
    _max: VendorMaxAggregateOutputType | null
  }

  type GetVendorGroupByPayload<T extends VendorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VendorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VendorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VendorGroupByOutputType[P]>
            : GetScalarType<T[P], VendorGroupByOutputType[P]>
        }
      >
    >


  export type VendorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    businessName?: boolean
    category?: boolean
    description?: boolean
    location?: boolean
    phone?: boolean
    email?: boolean
    website?: boolean
    experience?: boolean
    rating?: boolean
    totalReviews?: boolean
    isVerified?: boolean
    isActive?: boolean
    verificationStatus?: boolean
    documentSignedAt?: boolean
    verificationNotes?: boolean
    basePrice?: boolean
    priceRange?: boolean
    profileImage?: boolean
    gallery?: boolean
    availability?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    bookings?: boolean | Vendor$bookingsArgs<ExtArgs>
    services?: boolean | Vendor$servicesArgs<ExtArgs>
    reviews?: boolean | Vendor$reviewsArgs<ExtArgs>
    chatSessions?: boolean | Vendor$chatSessionsArgs<ExtArgs>
    verificationDocuments?: boolean | Vendor$verificationDocumentsArgs<ExtArgs>
    dynamicFields?: boolean | Vendor$dynamicFieldsArgs<ExtArgs>
    _count?: boolean | VendorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vendor"]>

  export type VendorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    businessName?: boolean
    category?: boolean
    description?: boolean
    location?: boolean
    phone?: boolean
    email?: boolean
    website?: boolean
    experience?: boolean
    rating?: boolean
    totalReviews?: boolean
    isVerified?: boolean
    isActive?: boolean
    verificationStatus?: boolean
    documentSignedAt?: boolean
    verificationNotes?: boolean
    basePrice?: boolean
    priceRange?: boolean
    profileImage?: boolean
    gallery?: boolean
    availability?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vendor"]>

  export type VendorSelectScalar = {
    id?: boolean
    userId?: boolean
    businessName?: boolean
    category?: boolean
    description?: boolean
    location?: boolean
    phone?: boolean
    email?: boolean
    website?: boolean
    experience?: boolean
    rating?: boolean
    totalReviews?: boolean
    isVerified?: boolean
    isActive?: boolean
    verificationStatus?: boolean
    documentSignedAt?: boolean
    verificationNotes?: boolean
    basePrice?: boolean
    priceRange?: boolean
    profileImage?: boolean
    gallery?: boolean
    availability?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VendorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    bookings?: boolean | Vendor$bookingsArgs<ExtArgs>
    services?: boolean | Vendor$servicesArgs<ExtArgs>
    reviews?: boolean | Vendor$reviewsArgs<ExtArgs>
    chatSessions?: boolean | Vendor$chatSessionsArgs<ExtArgs>
    verificationDocuments?: boolean | Vendor$verificationDocumentsArgs<ExtArgs>
    dynamicFields?: boolean | Vendor$dynamicFieldsArgs<ExtArgs>
    _count?: boolean | VendorCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VendorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $VendorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Vendor"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      bookings: Prisma.$BookingPayload<ExtArgs>[]
      services: Prisma.$ServicePayload<ExtArgs>[]
      reviews: Prisma.$ReviewPayload<ExtArgs>[]
      chatSessions: Prisma.$ChatSessionPayload<ExtArgs>[]
      verificationDocuments: Prisma.$VendorVerificationDocumentPayload<ExtArgs>[]
      dynamicFields: Prisma.$VendorDynamicFieldPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      businessName: string
      category: $Enums.VendorCategory
      description: string
      location: string
      phone: string
      email: string
      website: string | null
      experience: number
      rating: number
      totalReviews: number
      isVerified: boolean
      isActive: boolean
      verificationStatus: $Enums.VerificationStatus
      documentSignedAt: Date | null
      verificationNotes: string | null
      basePrice: number | null
      priceRange: string | null
      profileImage: string | null
      gallery: string[]
      availability: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["vendor"]>
    composites: {}
  }

  type VendorGetPayload<S extends boolean | null | undefined | VendorDefaultArgs> = $Result.GetResult<Prisma.$VendorPayload, S>

  type VendorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VendorFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VendorCountAggregateInputType | true
    }

  export interface VendorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Vendor'], meta: { name: 'Vendor' } }
    /**
     * Find zero or one Vendor that matches the filter.
     * @param {VendorFindUniqueArgs} args - Arguments to find a Vendor
     * @example
     * // Get one Vendor
     * const vendor = await prisma.vendor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VendorFindUniqueArgs>(args: SelectSubset<T, VendorFindUniqueArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Vendor that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VendorFindUniqueOrThrowArgs} args - Arguments to find a Vendor
     * @example
     * // Get one Vendor
     * const vendor = await prisma.vendor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VendorFindUniqueOrThrowArgs>(args: SelectSubset<T, VendorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Vendor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorFindFirstArgs} args - Arguments to find a Vendor
     * @example
     * // Get one Vendor
     * const vendor = await prisma.vendor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VendorFindFirstArgs>(args?: SelectSubset<T, VendorFindFirstArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Vendor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorFindFirstOrThrowArgs} args - Arguments to find a Vendor
     * @example
     * // Get one Vendor
     * const vendor = await prisma.vendor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VendorFindFirstOrThrowArgs>(args?: SelectSubset<T, VendorFindFirstOrThrowArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Vendors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vendors
     * const vendors = await prisma.vendor.findMany()
     * 
     * // Get first 10 Vendors
     * const vendors = await prisma.vendor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vendorWithIdOnly = await prisma.vendor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VendorFindManyArgs>(args?: SelectSubset<T, VendorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Vendor.
     * @param {VendorCreateArgs} args - Arguments to create a Vendor.
     * @example
     * // Create one Vendor
     * const Vendor = await prisma.vendor.create({
     *   data: {
     *     // ... data to create a Vendor
     *   }
     * })
     * 
     */
    create<T extends VendorCreateArgs>(args: SelectSubset<T, VendorCreateArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Vendors.
     * @param {VendorCreateManyArgs} args - Arguments to create many Vendors.
     * @example
     * // Create many Vendors
     * const vendor = await prisma.vendor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VendorCreateManyArgs>(args?: SelectSubset<T, VendorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Vendors and returns the data saved in the database.
     * @param {VendorCreateManyAndReturnArgs} args - Arguments to create many Vendors.
     * @example
     * // Create many Vendors
     * const vendor = await prisma.vendor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Vendors and only return the `id`
     * const vendorWithIdOnly = await prisma.vendor.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VendorCreateManyAndReturnArgs>(args?: SelectSubset<T, VendorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Vendor.
     * @param {VendorDeleteArgs} args - Arguments to delete one Vendor.
     * @example
     * // Delete one Vendor
     * const Vendor = await prisma.vendor.delete({
     *   where: {
     *     // ... filter to delete one Vendor
     *   }
     * })
     * 
     */
    delete<T extends VendorDeleteArgs>(args: SelectSubset<T, VendorDeleteArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Vendor.
     * @param {VendorUpdateArgs} args - Arguments to update one Vendor.
     * @example
     * // Update one Vendor
     * const vendor = await prisma.vendor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VendorUpdateArgs>(args: SelectSubset<T, VendorUpdateArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Vendors.
     * @param {VendorDeleteManyArgs} args - Arguments to filter Vendors to delete.
     * @example
     * // Delete a few Vendors
     * const { count } = await prisma.vendor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VendorDeleteManyArgs>(args?: SelectSubset<T, VendorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vendors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vendors
     * const vendor = await prisma.vendor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VendorUpdateManyArgs>(args: SelectSubset<T, VendorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Vendor.
     * @param {VendorUpsertArgs} args - Arguments to update or create a Vendor.
     * @example
     * // Update or create a Vendor
     * const vendor = await prisma.vendor.upsert({
     *   create: {
     *     // ... data to create a Vendor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vendor we want to update
     *   }
     * })
     */
    upsert<T extends VendorUpsertArgs>(args: SelectSubset<T, VendorUpsertArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Vendors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorCountArgs} args - Arguments to filter Vendors to count.
     * @example
     * // Count the number of Vendors
     * const count = await prisma.vendor.count({
     *   where: {
     *     // ... the filter for the Vendors we want to count
     *   }
     * })
    **/
    count<T extends VendorCountArgs>(
      args?: Subset<T, VendorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VendorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vendor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VendorAggregateArgs>(args: Subset<T, VendorAggregateArgs>): Prisma.PrismaPromise<GetVendorAggregateType<T>>

    /**
     * Group by Vendor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VendorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VendorGroupByArgs['orderBy'] }
        : { orderBy?: VendorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VendorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVendorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Vendor model
   */
  readonly fields: VendorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Vendor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VendorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    bookings<T extends Vendor$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, Vendor$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany"> | Null>
    services<T extends Vendor$servicesArgs<ExtArgs> = {}>(args?: Subset<T, Vendor$servicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findMany"> | Null>
    reviews<T extends Vendor$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, Vendor$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany"> | Null>
    chatSessions<T extends Vendor$chatSessionsArgs<ExtArgs> = {}>(args?: Subset<T, Vendor$chatSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatSessionPayload<ExtArgs>, T, "findMany"> | Null>
    verificationDocuments<T extends Vendor$verificationDocumentsArgs<ExtArgs> = {}>(args?: Subset<T, Vendor$verificationDocumentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorVerificationDocumentPayload<ExtArgs>, T, "findMany"> | Null>
    dynamicFields<T extends Vendor$dynamicFieldsArgs<ExtArgs> = {}>(args?: Subset<T, Vendor$dynamicFieldsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorDynamicFieldPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Vendor model
   */ 
  interface VendorFieldRefs {
    readonly id: FieldRef<"Vendor", 'String'>
    readonly userId: FieldRef<"Vendor", 'String'>
    readonly businessName: FieldRef<"Vendor", 'String'>
    readonly category: FieldRef<"Vendor", 'VendorCategory'>
    readonly description: FieldRef<"Vendor", 'String'>
    readonly location: FieldRef<"Vendor", 'String'>
    readonly phone: FieldRef<"Vendor", 'String'>
    readonly email: FieldRef<"Vendor", 'String'>
    readonly website: FieldRef<"Vendor", 'String'>
    readonly experience: FieldRef<"Vendor", 'Int'>
    readonly rating: FieldRef<"Vendor", 'Float'>
    readonly totalReviews: FieldRef<"Vendor", 'Int'>
    readonly isVerified: FieldRef<"Vendor", 'Boolean'>
    readonly isActive: FieldRef<"Vendor", 'Boolean'>
    readonly verificationStatus: FieldRef<"Vendor", 'VerificationStatus'>
    readonly documentSignedAt: FieldRef<"Vendor", 'DateTime'>
    readonly verificationNotes: FieldRef<"Vendor", 'String'>
    readonly basePrice: FieldRef<"Vendor", 'Float'>
    readonly priceRange: FieldRef<"Vendor", 'String'>
    readonly profileImage: FieldRef<"Vendor", 'String'>
    readonly gallery: FieldRef<"Vendor", 'String[]'>
    readonly availability: FieldRef<"Vendor", 'Json'>
    readonly createdAt: FieldRef<"Vendor", 'DateTime'>
    readonly updatedAt: FieldRef<"Vendor", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Vendor findUnique
   */
  export type VendorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendor to fetch.
     */
    where: VendorWhereUniqueInput
  }

  /**
   * Vendor findUniqueOrThrow
   */
  export type VendorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendor to fetch.
     */
    where: VendorWhereUniqueInput
  }

  /**
   * Vendor findFirst
   */
  export type VendorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendor to fetch.
     */
    where?: VendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendors to fetch.
     */
    orderBy?: VendorOrderByWithRelationInput | VendorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vendors.
     */
    cursor?: VendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vendors.
     */
    distinct?: VendorScalarFieldEnum | VendorScalarFieldEnum[]
  }

  /**
   * Vendor findFirstOrThrow
   */
  export type VendorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendor to fetch.
     */
    where?: VendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendors to fetch.
     */
    orderBy?: VendorOrderByWithRelationInput | VendorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vendors.
     */
    cursor?: VendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vendors.
     */
    distinct?: VendorScalarFieldEnum | VendorScalarFieldEnum[]
  }

  /**
   * Vendor findMany
   */
  export type VendorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendors to fetch.
     */
    where?: VendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendors to fetch.
     */
    orderBy?: VendorOrderByWithRelationInput | VendorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Vendors.
     */
    cursor?: VendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendors.
     */
    skip?: number
    distinct?: VendorScalarFieldEnum | VendorScalarFieldEnum[]
  }

  /**
   * Vendor create
   */
  export type VendorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * The data needed to create a Vendor.
     */
    data: XOR<VendorCreateInput, VendorUncheckedCreateInput>
  }

  /**
   * Vendor createMany
   */
  export type VendorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Vendors.
     */
    data: VendorCreateManyInput | VendorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Vendor createManyAndReturn
   */
  export type VendorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Vendors.
     */
    data: VendorCreateManyInput | VendorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Vendor update
   */
  export type VendorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * The data needed to update a Vendor.
     */
    data: XOR<VendorUpdateInput, VendorUncheckedUpdateInput>
    /**
     * Choose, which Vendor to update.
     */
    where: VendorWhereUniqueInput
  }

  /**
   * Vendor updateMany
   */
  export type VendorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Vendors.
     */
    data: XOR<VendorUpdateManyMutationInput, VendorUncheckedUpdateManyInput>
    /**
     * Filter which Vendors to update
     */
    where?: VendorWhereInput
  }

  /**
   * Vendor upsert
   */
  export type VendorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * The filter to search for the Vendor to update in case it exists.
     */
    where: VendorWhereUniqueInput
    /**
     * In case the Vendor found by the `where` argument doesn't exist, create a new Vendor with this data.
     */
    create: XOR<VendorCreateInput, VendorUncheckedCreateInput>
    /**
     * In case the Vendor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VendorUpdateInput, VendorUncheckedUpdateInput>
  }

  /**
   * Vendor delete
   */
  export type VendorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter which Vendor to delete.
     */
    where: VendorWhereUniqueInput
  }

  /**
   * Vendor deleteMany
   */
  export type VendorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vendors to delete
     */
    where?: VendorWhereInput
  }

  /**
   * Vendor.bookings
   */
  export type Vendor$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Vendor.services
   */
  export type Vendor$servicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    where?: ServiceWhereInput
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    cursor?: ServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Vendor.reviews
   */
  export type Vendor$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Vendor.chatSessions
   */
  export type Vendor$chatSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatSession
     */
    select?: ChatSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatSessionInclude<ExtArgs> | null
    where?: ChatSessionWhereInput
    orderBy?: ChatSessionOrderByWithRelationInput | ChatSessionOrderByWithRelationInput[]
    cursor?: ChatSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatSessionScalarFieldEnum | ChatSessionScalarFieldEnum[]
  }

  /**
   * Vendor.verificationDocuments
   */
  export type Vendor$verificationDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorVerificationDocument
     */
    select?: VendorVerificationDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorVerificationDocumentInclude<ExtArgs> | null
    where?: VendorVerificationDocumentWhereInput
    orderBy?: VendorVerificationDocumentOrderByWithRelationInput | VendorVerificationDocumentOrderByWithRelationInput[]
    cursor?: VendorVerificationDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VendorVerificationDocumentScalarFieldEnum | VendorVerificationDocumentScalarFieldEnum[]
  }

  /**
   * Vendor.dynamicFields
   */
  export type Vendor$dynamicFieldsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorDynamicField
     */
    select?: VendorDynamicFieldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorDynamicFieldInclude<ExtArgs> | null
    where?: VendorDynamicFieldWhereInput
    orderBy?: VendorDynamicFieldOrderByWithRelationInput | VendorDynamicFieldOrderByWithRelationInput[]
    cursor?: VendorDynamicFieldWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VendorDynamicFieldScalarFieldEnum | VendorDynamicFieldScalarFieldEnum[]
  }

  /**
   * Vendor without action
   */
  export type VendorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
  }


  /**
   * Model Service
   */

  export type AggregateService = {
    _count: ServiceCountAggregateOutputType | null
    _avg: ServiceAvgAggregateOutputType | null
    _sum: ServiceSumAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  export type ServiceAvgAggregateOutputType = {
    price: number | null
    duration: number | null
    maxCapacity: number | null
  }

  export type ServiceSumAggregateOutputType = {
    price: number | null
    duration: number | null
    maxCapacity: number | null
  }

  export type ServiceMinAggregateOutputType = {
    id: string | null
    vendorId: string | null
    name: string | null
    description: string | null
    price: number | null
    duration: number | null
    maxCapacity: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceMaxAggregateOutputType = {
    id: string | null
    vendorId: string | null
    name: string | null
    description: string | null
    price: number | null
    duration: number | null
    maxCapacity: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceCountAggregateOutputType = {
    id: number
    vendorId: number
    name: number
    description: number
    price: number
    duration: number
    maxCapacity: number
    includes: number
    addOns: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ServiceAvgAggregateInputType = {
    price?: true
    duration?: true
    maxCapacity?: true
  }

  export type ServiceSumAggregateInputType = {
    price?: true
    duration?: true
    maxCapacity?: true
  }

  export type ServiceMinAggregateInputType = {
    id?: true
    vendorId?: true
    name?: true
    description?: true
    price?: true
    duration?: true
    maxCapacity?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceMaxAggregateInputType = {
    id?: true
    vendorId?: true
    name?: true
    description?: true
    price?: true
    duration?: true
    maxCapacity?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceCountAggregateInputType = {
    id?: true
    vendorId?: true
    name?: true
    description?: true
    price?: true
    duration?: true
    maxCapacity?: true
    includes?: true
    addOns?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ServiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Service to aggregate.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Services
    **/
    _count?: true | ServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceMaxAggregateInputType
  }

  export type GetServiceAggregateType<T extends ServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateService[P]>
      : GetScalarType<T[P], AggregateService[P]>
  }




  export type ServiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
    orderBy?: ServiceOrderByWithAggregationInput | ServiceOrderByWithAggregationInput[]
    by: ServiceScalarFieldEnum[] | ServiceScalarFieldEnum
    having?: ServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceCountAggregateInputType | true
    _avg?: ServiceAvgAggregateInputType
    _sum?: ServiceSumAggregateInputType
    _min?: ServiceMinAggregateInputType
    _max?: ServiceMaxAggregateInputType
  }

  export type ServiceGroupByOutputType = {
    id: string
    vendorId: string
    name: string
    description: string
    price: number
    duration: number | null
    maxCapacity: number | null
    includes: string[]
    addOns: JsonValue | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: ServiceCountAggregateOutputType | null
    _avg: ServiceAvgAggregateOutputType | null
    _sum: ServiceSumAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  type GetServiceGroupByPayload<T extends ServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceGroupByOutputType[P]>
        }
      >
    >


  export type ServiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendorId?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    duration?: boolean
    maxCapacity?: boolean
    includes?: boolean
    addOns?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    bookings?: boolean | Service$bookingsArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendorId?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    duration?: boolean
    maxCapacity?: boolean
    includes?: boolean
    addOns?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectScalar = {
    id?: boolean
    vendorId?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    duration?: boolean
    maxCapacity?: boolean
    includes?: boolean
    addOns?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ServiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    bookings?: boolean | Service$bookingsArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ServiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }

  export type $ServicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Service"
    objects: {
      vendor: Prisma.$VendorPayload<ExtArgs>
      bookings: Prisma.$BookingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      vendorId: string
      name: string
      description: string
      price: number
      duration: number | null
      maxCapacity: number | null
      includes: string[]
      addOns: Prisma.JsonValue | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["service"]>
    composites: {}
  }

  type ServiceGetPayload<S extends boolean | null | undefined | ServiceDefaultArgs> = $Result.GetResult<Prisma.$ServicePayload, S>

  type ServiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ServiceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ServiceCountAggregateInputType | true
    }

  export interface ServiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Service'], meta: { name: 'Service' } }
    /**
     * Find zero or one Service that matches the filter.
     * @param {ServiceFindUniqueArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceFindUniqueArgs>(args: SelectSubset<T, ServiceFindUniqueArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Service that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ServiceFindUniqueOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Service that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceFindFirstArgs>(args?: SelectSubset<T, ServiceFindFirstArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Service that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Services that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Services
     * const services = await prisma.service.findMany()
     * 
     * // Get first 10 Services
     * const services = await prisma.service.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceWithIdOnly = await prisma.service.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceFindManyArgs>(args?: SelectSubset<T, ServiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Service.
     * @param {ServiceCreateArgs} args - Arguments to create a Service.
     * @example
     * // Create one Service
     * const Service = await prisma.service.create({
     *   data: {
     *     // ... data to create a Service
     *   }
     * })
     * 
     */
    create<T extends ServiceCreateArgs>(args: SelectSubset<T, ServiceCreateArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Services.
     * @param {ServiceCreateManyArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const service = await prisma.service.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceCreateManyArgs>(args?: SelectSubset<T, ServiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Services and returns the data saved in the database.
     * @param {ServiceCreateManyAndReturnArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const service = await prisma.service.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Services and only return the `id`
     * const serviceWithIdOnly = await prisma.service.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Service.
     * @param {ServiceDeleteArgs} args - Arguments to delete one Service.
     * @example
     * // Delete one Service
     * const Service = await prisma.service.delete({
     *   where: {
     *     // ... filter to delete one Service
     *   }
     * })
     * 
     */
    delete<T extends ServiceDeleteArgs>(args: SelectSubset<T, ServiceDeleteArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Service.
     * @param {ServiceUpdateArgs} args - Arguments to update one Service.
     * @example
     * // Update one Service
     * const service = await prisma.service.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceUpdateArgs>(args: SelectSubset<T, ServiceUpdateArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Services.
     * @param {ServiceDeleteManyArgs} args - Arguments to filter Services to delete.
     * @example
     * // Delete a few Services
     * const { count } = await prisma.service.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceDeleteManyArgs>(args?: SelectSubset<T, ServiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Services
     * const service = await prisma.service.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceUpdateManyArgs>(args: SelectSubset<T, ServiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Service.
     * @param {ServiceUpsertArgs} args - Arguments to update or create a Service.
     * @example
     * // Update or create a Service
     * const service = await prisma.service.upsert({
     *   create: {
     *     // ... data to create a Service
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Service we want to update
     *   }
     * })
     */
    upsert<T extends ServiceUpsertArgs>(args: SelectSubset<T, ServiceUpsertArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCountArgs} args - Arguments to filter Services to count.
     * @example
     * // Count the number of Services
     * const count = await prisma.service.count({
     *   where: {
     *     // ... the filter for the Services we want to count
     *   }
     * })
    **/
    count<T extends ServiceCountArgs>(
      args?: Subset<T, ServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceAggregateArgs>(args: Subset<T, ServiceAggregateArgs>): Prisma.PrismaPromise<GetServiceAggregateType<T>>

    /**
     * Group by Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceGroupByArgs['orderBy'] }
        : { orderBy?: ServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Service model
   */
  readonly fields: ServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Service.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vendor<T extends VendorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VendorDefaultArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    bookings<T extends Service$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, Service$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Service model
   */ 
  interface ServiceFieldRefs {
    readonly id: FieldRef<"Service", 'String'>
    readonly vendorId: FieldRef<"Service", 'String'>
    readonly name: FieldRef<"Service", 'String'>
    readonly description: FieldRef<"Service", 'String'>
    readonly price: FieldRef<"Service", 'Float'>
    readonly duration: FieldRef<"Service", 'Int'>
    readonly maxCapacity: FieldRef<"Service", 'Int'>
    readonly includes: FieldRef<"Service", 'String[]'>
    readonly addOns: FieldRef<"Service", 'Json'>
    readonly isActive: FieldRef<"Service", 'Boolean'>
    readonly createdAt: FieldRef<"Service", 'DateTime'>
    readonly updatedAt: FieldRef<"Service", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Service findUnique
   */
  export type ServiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findUniqueOrThrow
   */
  export type ServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findFirst
   */
  export type ServiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service findFirstOrThrow
   */
  export type ServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service findMany
   */
  export type ServiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Services to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service create
   */
  export type ServiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Service.
     */
    data: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
  }

  /**
   * Service createMany
   */
  export type ServiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Services.
     */
    data: ServiceCreateManyInput | ServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Service createManyAndReturn
   */
  export type ServiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Services.
     */
    data: ServiceCreateManyInput | ServiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Service update
   */
  export type ServiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Service.
     */
    data: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
    /**
     * Choose, which Service to update.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service updateMany
   */
  export type ServiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Services.
     */
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyInput>
    /**
     * Filter which Services to update
     */
    where?: ServiceWhereInput
  }

  /**
   * Service upsert
   */
  export type ServiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Service to update in case it exists.
     */
    where: ServiceWhereUniqueInput
    /**
     * In case the Service found by the `where` argument doesn't exist, create a new Service with this data.
     */
    create: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
    /**
     * In case the Service was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
  }

  /**
   * Service delete
   */
  export type ServiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter which Service to delete.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service deleteMany
   */
  export type ServiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Services to delete
     */
    where?: ServiceWhereInput
  }

  /**
   * Service.bookings
   */
  export type Service$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Service without action
   */
  export type ServiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
  }


  /**
   * Model Booking
   */

  export type AggregateBooking = {
    _count: BookingCountAggregateOutputType | null
    _avg: BookingAvgAggregateOutputType | null
    _sum: BookingSumAggregateOutputType | null
    _min: BookingMinAggregateOutputType | null
    _max: BookingMaxAggregateOutputType | null
  }

  export type BookingAvgAggregateOutputType = {
    eventDuration: number | null
    guestCount: number | null
    basePrice: number | null
    additionalCosts: number | null
    totalAmount: number | null
  }

  export type BookingSumAggregateOutputType = {
    eventDuration: number | null
    guestCount: number | null
    basePrice: number | null
    additionalCosts: number | null
    totalAmount: number | null
  }

  export type BookingMinAggregateOutputType = {
    id: string | null
    userId: string | null
    vendorId: string | null
    serviceId: string | null
    eventDate: Date | null
    eventTime: string | null
    eventDuration: number | null
    guestCount: number | null
    location: string | null
    specialRequests: string | null
    basePrice: number | null
    additionalCosts: number | null
    totalAmount: number | null
    status: $Enums.BookingStatus | null
    paymentStatus: $Enums.PaymentStatus | null
    requestedAt: Date | null
    approvedAt: Date | null
    confirmedAt: Date | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BookingMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    vendorId: string | null
    serviceId: string | null
    eventDate: Date | null
    eventTime: string | null
    eventDuration: number | null
    guestCount: number | null
    location: string | null
    specialRequests: string | null
    basePrice: number | null
    additionalCosts: number | null
    totalAmount: number | null
    status: $Enums.BookingStatus | null
    paymentStatus: $Enums.PaymentStatus | null
    requestedAt: Date | null
    approvedAt: Date | null
    confirmedAt: Date | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BookingCountAggregateOutputType = {
    id: number
    userId: number
    vendorId: number
    serviceId: number
    eventDate: number
    eventTime: number
    eventDuration: number
    guestCount: number
    location: number
    specialRequests: number
    basePrice: number
    additionalCosts: number
    totalAmount: number
    status: number
    paymentStatus: number
    requestedAt: number
    approvedAt: number
    confirmedAt: number
    completedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BookingAvgAggregateInputType = {
    eventDuration?: true
    guestCount?: true
    basePrice?: true
    additionalCosts?: true
    totalAmount?: true
  }

  export type BookingSumAggregateInputType = {
    eventDuration?: true
    guestCount?: true
    basePrice?: true
    additionalCosts?: true
    totalAmount?: true
  }

  export type BookingMinAggregateInputType = {
    id?: true
    userId?: true
    vendorId?: true
    serviceId?: true
    eventDate?: true
    eventTime?: true
    eventDuration?: true
    guestCount?: true
    location?: true
    specialRequests?: true
    basePrice?: true
    additionalCosts?: true
    totalAmount?: true
    status?: true
    paymentStatus?: true
    requestedAt?: true
    approvedAt?: true
    confirmedAt?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BookingMaxAggregateInputType = {
    id?: true
    userId?: true
    vendorId?: true
    serviceId?: true
    eventDate?: true
    eventTime?: true
    eventDuration?: true
    guestCount?: true
    location?: true
    specialRequests?: true
    basePrice?: true
    additionalCosts?: true
    totalAmount?: true
    status?: true
    paymentStatus?: true
    requestedAt?: true
    approvedAt?: true
    confirmedAt?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BookingCountAggregateInputType = {
    id?: true
    userId?: true
    vendorId?: true
    serviceId?: true
    eventDate?: true
    eventTime?: true
    eventDuration?: true
    guestCount?: true
    location?: true
    specialRequests?: true
    basePrice?: true
    additionalCosts?: true
    totalAmount?: true
    status?: true
    paymentStatus?: true
    requestedAt?: true
    approvedAt?: true
    confirmedAt?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BookingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Booking to aggregate.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bookings
    **/
    _count?: true | BookingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BookingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BookingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookingMaxAggregateInputType
  }

  export type GetBookingAggregateType<T extends BookingAggregateArgs> = {
        [P in keyof T & keyof AggregateBooking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBooking[P]>
      : GetScalarType<T[P], AggregateBooking[P]>
  }




  export type BookingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithAggregationInput | BookingOrderByWithAggregationInput[]
    by: BookingScalarFieldEnum[] | BookingScalarFieldEnum
    having?: BookingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookingCountAggregateInputType | true
    _avg?: BookingAvgAggregateInputType
    _sum?: BookingSumAggregateInputType
    _min?: BookingMinAggregateInputType
    _max?: BookingMaxAggregateInputType
  }

  export type BookingGroupByOutputType = {
    id: string
    userId: string
    vendorId: string
    serviceId: string
    eventDate: Date
    eventTime: string
    eventDuration: number
    guestCount: number | null
    location: string | null
    specialRequests: string | null
    basePrice: number
    additionalCosts: number
    totalAmount: number
    status: $Enums.BookingStatus
    paymentStatus: $Enums.PaymentStatus
    requestedAt: Date
    approvedAt: Date | null
    confirmedAt: Date | null
    completedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: BookingCountAggregateOutputType | null
    _avg: BookingAvgAggregateOutputType | null
    _sum: BookingSumAggregateOutputType | null
    _min: BookingMinAggregateOutputType | null
    _max: BookingMaxAggregateOutputType | null
  }

  type GetBookingGroupByPayload<T extends BookingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookingGroupByOutputType[P]>
            : GetScalarType<T[P], BookingGroupByOutputType[P]>
        }
      >
    >


  export type BookingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    vendorId?: boolean
    serviceId?: boolean
    eventDate?: boolean
    eventTime?: boolean
    eventDuration?: boolean
    guestCount?: boolean
    location?: boolean
    specialRequests?: boolean
    basePrice?: boolean
    additionalCosts?: boolean
    totalAmount?: boolean
    status?: boolean
    paymentStatus?: boolean
    requestedAt?: boolean
    approvedAt?: boolean
    confirmedAt?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    payments?: boolean | Booking$paymentsArgs<ExtArgs>
    messages?: boolean | Booking$messagesArgs<ExtArgs>
    _count?: boolean | BookingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["booking"]>

  export type BookingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    vendorId?: boolean
    serviceId?: boolean
    eventDate?: boolean
    eventTime?: boolean
    eventDuration?: boolean
    guestCount?: boolean
    location?: boolean
    specialRequests?: boolean
    basePrice?: boolean
    additionalCosts?: boolean
    totalAmount?: boolean
    status?: boolean
    paymentStatus?: boolean
    requestedAt?: boolean
    approvedAt?: boolean
    confirmedAt?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["booking"]>

  export type BookingSelectScalar = {
    id?: boolean
    userId?: boolean
    vendorId?: boolean
    serviceId?: boolean
    eventDate?: boolean
    eventTime?: boolean
    eventDuration?: boolean
    guestCount?: boolean
    location?: boolean
    specialRequests?: boolean
    basePrice?: boolean
    additionalCosts?: boolean
    totalAmount?: boolean
    status?: boolean
    paymentStatus?: boolean
    requestedAt?: boolean
    approvedAt?: boolean
    confirmedAt?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BookingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    payments?: boolean | Booking$paymentsArgs<ExtArgs>
    messages?: boolean | Booking$messagesArgs<ExtArgs>
    _count?: boolean | BookingCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BookingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }

  export type $BookingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Booking"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      vendor: Prisma.$VendorPayload<ExtArgs>
      service: Prisma.$ServicePayload<ExtArgs>
      payments: Prisma.$PaymentPayload<ExtArgs>[]
      messages: Prisma.$MessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      vendorId: string
      serviceId: string
      eventDate: Date
      eventTime: string
      eventDuration: number
      guestCount: number | null
      location: string | null
      specialRequests: string | null
      basePrice: number
      additionalCosts: number
      totalAmount: number
      status: $Enums.BookingStatus
      paymentStatus: $Enums.PaymentStatus
      requestedAt: Date
      approvedAt: Date | null
      confirmedAt: Date | null
      completedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["booking"]>
    composites: {}
  }

  type BookingGetPayload<S extends boolean | null | undefined | BookingDefaultArgs> = $Result.GetResult<Prisma.$BookingPayload, S>

  type BookingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BookingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BookingCountAggregateInputType | true
    }

  export interface BookingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Booking'], meta: { name: 'Booking' } }
    /**
     * Find zero or one Booking that matches the filter.
     * @param {BookingFindUniqueArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BookingFindUniqueArgs>(args: SelectSubset<T, BookingFindUniqueArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Booking that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BookingFindUniqueOrThrowArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BookingFindUniqueOrThrowArgs>(args: SelectSubset<T, BookingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Booking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindFirstArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BookingFindFirstArgs>(args?: SelectSubset<T, BookingFindFirstArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Booking that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindFirstOrThrowArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BookingFindFirstOrThrowArgs>(args?: SelectSubset<T, BookingFindFirstOrThrowArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Bookings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bookings
     * const bookings = await prisma.booking.findMany()
     * 
     * // Get first 10 Bookings
     * const bookings = await prisma.booking.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookingWithIdOnly = await prisma.booking.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BookingFindManyArgs>(args?: SelectSubset<T, BookingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Booking.
     * @param {BookingCreateArgs} args - Arguments to create a Booking.
     * @example
     * // Create one Booking
     * const Booking = await prisma.booking.create({
     *   data: {
     *     // ... data to create a Booking
     *   }
     * })
     * 
     */
    create<T extends BookingCreateArgs>(args: SelectSubset<T, BookingCreateArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Bookings.
     * @param {BookingCreateManyArgs} args - Arguments to create many Bookings.
     * @example
     * // Create many Bookings
     * const booking = await prisma.booking.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BookingCreateManyArgs>(args?: SelectSubset<T, BookingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Bookings and returns the data saved in the database.
     * @param {BookingCreateManyAndReturnArgs} args - Arguments to create many Bookings.
     * @example
     * // Create many Bookings
     * const booking = await prisma.booking.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Bookings and only return the `id`
     * const bookingWithIdOnly = await prisma.booking.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BookingCreateManyAndReturnArgs>(args?: SelectSubset<T, BookingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Booking.
     * @param {BookingDeleteArgs} args - Arguments to delete one Booking.
     * @example
     * // Delete one Booking
     * const Booking = await prisma.booking.delete({
     *   where: {
     *     // ... filter to delete one Booking
     *   }
     * })
     * 
     */
    delete<T extends BookingDeleteArgs>(args: SelectSubset<T, BookingDeleteArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Booking.
     * @param {BookingUpdateArgs} args - Arguments to update one Booking.
     * @example
     * // Update one Booking
     * const booking = await prisma.booking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BookingUpdateArgs>(args: SelectSubset<T, BookingUpdateArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Bookings.
     * @param {BookingDeleteManyArgs} args - Arguments to filter Bookings to delete.
     * @example
     * // Delete a few Bookings
     * const { count } = await prisma.booking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BookingDeleteManyArgs>(args?: SelectSubset<T, BookingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bookings
     * const booking = await prisma.booking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BookingUpdateManyArgs>(args: SelectSubset<T, BookingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Booking.
     * @param {BookingUpsertArgs} args - Arguments to update or create a Booking.
     * @example
     * // Update or create a Booking
     * const booking = await prisma.booking.upsert({
     *   create: {
     *     // ... data to create a Booking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Booking we want to update
     *   }
     * })
     */
    upsert<T extends BookingUpsertArgs>(args: SelectSubset<T, BookingUpsertArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingCountArgs} args - Arguments to filter Bookings to count.
     * @example
     * // Count the number of Bookings
     * const count = await prisma.booking.count({
     *   where: {
     *     // ... the filter for the Bookings we want to count
     *   }
     * })
    **/
    count<T extends BookingCountArgs>(
      args?: Subset<T, BookingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Booking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookingAggregateArgs>(args: Subset<T, BookingAggregateArgs>): Prisma.PrismaPromise<GetBookingAggregateType<T>>

    /**
     * Group by Booking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookingGroupByArgs['orderBy'] }
        : { orderBy?: BookingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Booking model
   */
  readonly fields: BookingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Booking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BookingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    vendor<T extends VendorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VendorDefaultArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    service<T extends ServiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceDefaultArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    payments<T extends Booking$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Booking$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany"> | Null>
    messages<T extends Booking$messagesArgs<ExtArgs> = {}>(args?: Subset<T, Booking$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Booking model
   */ 
  interface BookingFieldRefs {
    readonly id: FieldRef<"Booking", 'String'>
    readonly userId: FieldRef<"Booking", 'String'>
    readonly vendorId: FieldRef<"Booking", 'String'>
    readonly serviceId: FieldRef<"Booking", 'String'>
    readonly eventDate: FieldRef<"Booking", 'DateTime'>
    readonly eventTime: FieldRef<"Booking", 'String'>
    readonly eventDuration: FieldRef<"Booking", 'Int'>
    readonly guestCount: FieldRef<"Booking", 'Int'>
    readonly location: FieldRef<"Booking", 'String'>
    readonly specialRequests: FieldRef<"Booking", 'String'>
    readonly basePrice: FieldRef<"Booking", 'Float'>
    readonly additionalCosts: FieldRef<"Booking", 'Float'>
    readonly totalAmount: FieldRef<"Booking", 'Float'>
    readonly status: FieldRef<"Booking", 'BookingStatus'>
    readonly paymentStatus: FieldRef<"Booking", 'PaymentStatus'>
    readonly requestedAt: FieldRef<"Booking", 'DateTime'>
    readonly approvedAt: FieldRef<"Booking", 'DateTime'>
    readonly confirmedAt: FieldRef<"Booking", 'DateTime'>
    readonly completedAt: FieldRef<"Booking", 'DateTime'>
    readonly createdAt: FieldRef<"Booking", 'DateTime'>
    readonly updatedAt: FieldRef<"Booking", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Booking findUnique
   */
  export type BookingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking findUniqueOrThrow
   */
  export type BookingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking findFirst
   */
  export type BookingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookings.
     */
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking findFirstOrThrow
   */
  export type BookingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookings.
     */
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking findMany
   */
  export type BookingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Bookings to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking create
   */
  export type BookingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The data needed to create a Booking.
     */
    data: XOR<BookingCreateInput, BookingUncheckedCreateInput>
  }

  /**
   * Booking createMany
   */
  export type BookingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Bookings.
     */
    data: BookingCreateManyInput | BookingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Booking createManyAndReturn
   */
  export type BookingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Bookings.
     */
    data: BookingCreateManyInput | BookingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Booking update
   */
  export type BookingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The data needed to update a Booking.
     */
    data: XOR<BookingUpdateInput, BookingUncheckedUpdateInput>
    /**
     * Choose, which Booking to update.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking updateMany
   */
  export type BookingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Bookings.
     */
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyInput>
    /**
     * Filter which Bookings to update
     */
    where?: BookingWhereInput
  }

  /**
   * Booking upsert
   */
  export type BookingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The filter to search for the Booking to update in case it exists.
     */
    where: BookingWhereUniqueInput
    /**
     * In case the Booking found by the `where` argument doesn't exist, create a new Booking with this data.
     */
    create: XOR<BookingCreateInput, BookingUncheckedCreateInput>
    /**
     * In case the Booking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookingUpdateInput, BookingUncheckedUpdateInput>
  }

  /**
   * Booking delete
   */
  export type BookingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter which Booking to delete.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking deleteMany
   */
  export type BookingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bookings to delete
     */
    where?: BookingWhereInput
  }

  /**
   * Booking.payments
   */
  export type Booking$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Booking.messages
   */
  export type Booking$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Booking without action
   */
  export type BookingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    amount: number | null
  }

  export type PaymentSumAggregateOutputType = {
    amount: number | null
  }

  export type PaymentMinAggregateOutputType = {
    id: string | null
    bookingId: string | null
    amount: number | null
    currency: string | null
    paymentMethod: string | null
    transactionId: string | null
    status: $Enums.PaymentStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: string | null
    bookingId: string | null
    amount: number | null
    currency: string | null
    paymentMethod: string | null
    transactionId: string | null
    status: $Enums.PaymentStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    bookingId: number
    amount: number
    currency: number
    paymentMethod: number
    transactionId: number
    gatewayResponse: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    amount?: true
  }

  export type PaymentSumAggregateInputType = {
    amount?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    bookingId?: true
    amount?: true
    currency?: true
    paymentMethod?: true
    transactionId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    bookingId?: true
    amount?: true
    currency?: true
    paymentMethod?: true
    transactionId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    bookingId?: true
    amount?: true
    currency?: true
    paymentMethod?: true
    transactionId?: true
    gatewayResponse?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: string
    bookingId: string
    amount: number
    currency: string
    paymentMethod: string
    transactionId: string | null
    gatewayResponse: JsonValue | null
    status: $Enums.PaymentStatus
    createdAt: Date
    updatedAt: Date
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    amount?: boolean
    currency?: boolean
    paymentMethod?: boolean
    transactionId?: boolean
    gatewayResponse?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    amount?: boolean
    currency?: boolean
    paymentMethod?: boolean
    transactionId?: boolean
    gatewayResponse?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    bookingId?: boolean
    amount?: boolean
    currency?: boolean
    paymentMethod?: boolean
    transactionId?: boolean
    gatewayResponse?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      booking: Prisma.$BookingPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bookingId: string
      amount: number
      currency: string
      paymentMethod: string
      transactionId: string | null
      gatewayResponse: Prisma.JsonValue | null
      status: $Enums.PaymentStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    booking<T extends BookingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BookingDefaultArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */ 
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'String'>
    readonly bookingId: FieldRef<"Payment", 'String'>
    readonly amount: FieldRef<"Payment", 'Float'>
    readonly currency: FieldRef<"Payment", 'String'>
    readonly paymentMethod: FieldRef<"Payment", 'String'>
    readonly transactionId: FieldRef<"Payment", 'String'>
    readonly gatewayResponse: FieldRef<"Payment", 'Json'>
    readonly status: FieldRef<"Payment", 'PaymentStatus'>
    readonly createdAt: FieldRef<"Payment", 'DateTime'>
    readonly updatedAt: FieldRef<"Payment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment createManyAndReturn
   */
  export type PaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model Message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageMinAggregateOutputType = {
    id: string | null
    senderId: string | null
    receiverId: string | null
    bookingId: string | null
    content: string | null
    messageType: string | null
    isRead: boolean | null
    createdAt: Date | null
  }

  export type MessageMaxAggregateOutputType = {
    id: string | null
    senderId: string | null
    receiverId: string | null
    bookingId: string | null
    content: string | null
    messageType: string | null
    isRead: boolean | null
    createdAt: Date | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    senderId: number
    receiverId: number
    bookingId: number
    content: number
    messageType: number
    attachments: number
    isRead: number
    createdAt: number
    _all: number
  }


  export type MessageMinAggregateInputType = {
    id?: true
    senderId?: true
    receiverId?: true
    bookingId?: true
    content?: true
    messageType?: true
    isRead?: true
    createdAt?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    senderId?: true
    receiverId?: true
    bookingId?: true
    content?: true
    messageType?: true
    isRead?: true
    createdAt?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    senderId?: true
    receiverId?: true
    bookingId?: true
    content?: true
    messageType?: true
    attachments?: true
    isRead?: true
    createdAt?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Message to aggregate.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithAggregationInput | MessageOrderByWithAggregationInput[]
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }

  export type MessageGroupByOutputType = {
    id: string
    senderId: string
    receiverId: string
    bookingId: string | null
    content: string
    messageType: string
    attachments: string[]
    isRead: boolean
    createdAt: Date
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    senderId?: boolean
    receiverId?: boolean
    bookingId?: boolean
    content?: boolean
    messageType?: boolean
    attachments?: boolean
    isRead?: boolean
    createdAt?: boolean
    sender?: boolean | UserDefaultArgs<ExtArgs>
    receiver?: boolean | UserDefaultArgs<ExtArgs>
    booking?: boolean | Message$bookingArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    senderId?: boolean
    receiverId?: boolean
    bookingId?: boolean
    content?: boolean
    messageType?: boolean
    attachments?: boolean
    isRead?: boolean
    createdAt?: boolean
    sender?: boolean | UserDefaultArgs<ExtArgs>
    receiver?: boolean | UserDefaultArgs<ExtArgs>
    booking?: boolean | Message$bookingArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectScalar = {
    id?: boolean
    senderId?: boolean
    receiverId?: boolean
    bookingId?: boolean
    content?: boolean
    messageType?: boolean
    attachments?: boolean
    isRead?: boolean
    createdAt?: boolean
  }

  export type MessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sender?: boolean | UserDefaultArgs<ExtArgs>
    receiver?: boolean | UserDefaultArgs<ExtArgs>
    booking?: boolean | Message$bookingArgs<ExtArgs>
  }
  export type MessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sender?: boolean | UserDefaultArgs<ExtArgs>
    receiver?: boolean | UserDefaultArgs<ExtArgs>
    booking?: boolean | Message$bookingArgs<ExtArgs>
  }

  export type $MessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Message"
    objects: {
      sender: Prisma.$UserPayload<ExtArgs>
      receiver: Prisma.$UserPayload<ExtArgs>
      booking: Prisma.$BookingPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      senderId: string
      receiverId: string
      bookingId: string | null
      content: string
      messageType: string
      attachments: string[]
      isRead: boolean
      createdAt: Date
    }, ExtArgs["result"]["message"]>
    composites: {}
  }

  type MessageGetPayload<S extends boolean | null | undefined | MessageDefaultArgs> = $Result.GetResult<Prisma.$MessagePayload, S>

  type MessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MessageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface MessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Message'], meta: { name: 'Message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageFindUniqueArgs>(args: SelectSubset<T, MessageFindUniqueArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Message that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageFindFirstArgs>(args?: SelectSubset<T, MessageFindFirstArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageFindManyArgs>(args?: SelectSubset<T, MessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
     */
    create<T extends MessageCreateArgs>(args: SelectSubset<T, MessageCreateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Messages.
     * @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageCreateManyArgs>(args?: SelectSubset<T, MessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Messages and returns the data saved in the database.
     * @param {MessageCreateManyAndReturnArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
     */
    delete<T extends MessageDeleteArgs>(args: SelectSubset<T, MessageDeleteArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageUpdateArgs>(args: SelectSubset<T, MessageUpdateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageDeleteManyArgs>(args?: SelectSubset<T, MessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageUpdateManyArgs>(args: SelectSubset<T, MessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
     */
    upsert<T extends MessageUpsertArgs>(args: SelectSubset<T, MessageUpsertArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Message model
   */
  readonly fields: MessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sender<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    receiver<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    booking<T extends Message$bookingArgs<ExtArgs> = {}>(args?: Subset<T, Message$bookingArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Message model
   */ 
  interface MessageFieldRefs {
    readonly id: FieldRef<"Message", 'String'>
    readonly senderId: FieldRef<"Message", 'String'>
    readonly receiverId: FieldRef<"Message", 'String'>
    readonly bookingId: FieldRef<"Message", 'String'>
    readonly content: FieldRef<"Message", 'String'>
    readonly messageType: FieldRef<"Message", 'String'>
    readonly attachments: FieldRef<"Message", 'String[]'>
    readonly isRead: FieldRef<"Message", 'Boolean'>
    readonly createdAt: FieldRef<"Message", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findMany
   */
  export type MessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message create
   */
  export type MessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to create a Message.
     */
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }

  /**
   * Message createMany
   */
  export type MessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Message createManyAndReturn
   */
  export type MessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message update
   */
  export type MessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to update a Message.
     */
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
  }

  /**
   * Message upsert
   */
  export type MessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The filter to search for the Message to update in case it exists.
     */
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     */
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }

  /**
   * Message delete
   */
  export type MessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter which Message to delete.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to delete
     */
    where?: MessageWhereInput
  }

  /**
   * Message.booking
   */
  export type Message$bookingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
  }

  /**
   * Message without action
   */
  export type MessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
  }


  /**
   * Model ChatSession
   */

  export type AggregateChatSession = {
    _count: ChatSessionCountAggregateOutputType | null
    _min: ChatSessionMinAggregateOutputType | null
    _max: ChatSessionMaxAggregateOutputType | null
  }

  export type ChatSessionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    vendorId: string | null
    lastMessageAt: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChatSessionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    vendorId: string | null
    lastMessageAt: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChatSessionCountAggregateOutputType = {
    id: number
    userId: number
    vendorId: number
    lastMessageAt: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ChatSessionMinAggregateInputType = {
    id?: true
    userId?: true
    vendorId?: true
    lastMessageAt?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChatSessionMaxAggregateInputType = {
    id?: true
    userId?: true
    vendorId?: true
    lastMessageAt?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChatSessionCountAggregateInputType = {
    id?: true
    userId?: true
    vendorId?: true
    lastMessageAt?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ChatSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatSession to aggregate.
     */
    where?: ChatSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatSessions to fetch.
     */
    orderBy?: ChatSessionOrderByWithRelationInput | ChatSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChatSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChatSessions
    **/
    _count?: true | ChatSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatSessionMaxAggregateInputType
  }

  export type GetChatSessionAggregateType<T extends ChatSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateChatSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChatSession[P]>
      : GetScalarType<T[P], AggregateChatSession[P]>
  }




  export type ChatSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatSessionWhereInput
    orderBy?: ChatSessionOrderByWithAggregationInput | ChatSessionOrderByWithAggregationInput[]
    by: ChatSessionScalarFieldEnum[] | ChatSessionScalarFieldEnum
    having?: ChatSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatSessionCountAggregateInputType | true
    _min?: ChatSessionMinAggregateInputType
    _max?: ChatSessionMaxAggregateInputType
  }

  export type ChatSessionGroupByOutputType = {
    id: string
    userId: string
    vendorId: string
    lastMessageAt: Date
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: ChatSessionCountAggregateOutputType | null
    _min: ChatSessionMinAggregateOutputType | null
    _max: ChatSessionMaxAggregateOutputType | null
  }

  type GetChatSessionGroupByPayload<T extends ChatSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChatSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatSessionGroupByOutputType[P]>
            : GetScalarType<T[P], ChatSessionGroupByOutputType[P]>
        }
      >
    >


  export type ChatSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    vendorId?: boolean
    lastMessageAt?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatSession"]>

  export type ChatSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    vendorId?: boolean
    lastMessageAt?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatSession"]>

  export type ChatSessionSelectScalar = {
    id?: boolean
    userId?: boolean
    vendorId?: boolean
    lastMessageAt?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ChatSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }
  export type ChatSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }

  export type $ChatSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChatSession"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      vendor: Prisma.$VendorPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      vendorId: string
      lastMessageAt: Date
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["chatSession"]>
    composites: {}
  }

  type ChatSessionGetPayload<S extends boolean | null | undefined | ChatSessionDefaultArgs> = $Result.GetResult<Prisma.$ChatSessionPayload, S>

  type ChatSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ChatSessionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ChatSessionCountAggregateInputType | true
    }

  export interface ChatSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChatSession'], meta: { name: 'ChatSession' } }
    /**
     * Find zero or one ChatSession that matches the filter.
     * @param {ChatSessionFindUniqueArgs} args - Arguments to find a ChatSession
     * @example
     * // Get one ChatSession
     * const chatSession = await prisma.chatSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChatSessionFindUniqueArgs>(args: SelectSubset<T, ChatSessionFindUniqueArgs<ExtArgs>>): Prisma__ChatSessionClient<$Result.GetResult<Prisma.$ChatSessionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ChatSession that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ChatSessionFindUniqueOrThrowArgs} args - Arguments to find a ChatSession
     * @example
     * // Get one ChatSession
     * const chatSession = await prisma.chatSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChatSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, ChatSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChatSessionClient<$Result.GetResult<Prisma.$ChatSessionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ChatSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatSessionFindFirstArgs} args - Arguments to find a ChatSession
     * @example
     * // Get one ChatSession
     * const chatSession = await prisma.chatSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChatSessionFindFirstArgs>(args?: SelectSubset<T, ChatSessionFindFirstArgs<ExtArgs>>): Prisma__ChatSessionClient<$Result.GetResult<Prisma.$ChatSessionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ChatSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatSessionFindFirstOrThrowArgs} args - Arguments to find a ChatSession
     * @example
     * // Get one ChatSession
     * const chatSession = await prisma.chatSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChatSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, ChatSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChatSessionClient<$Result.GetResult<Prisma.$ChatSessionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ChatSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChatSessions
     * const chatSessions = await prisma.chatSession.findMany()
     * 
     * // Get first 10 ChatSessions
     * const chatSessions = await prisma.chatSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chatSessionWithIdOnly = await prisma.chatSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChatSessionFindManyArgs>(args?: SelectSubset<T, ChatSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatSessionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ChatSession.
     * @param {ChatSessionCreateArgs} args - Arguments to create a ChatSession.
     * @example
     * // Create one ChatSession
     * const ChatSession = await prisma.chatSession.create({
     *   data: {
     *     // ... data to create a ChatSession
     *   }
     * })
     * 
     */
    create<T extends ChatSessionCreateArgs>(args: SelectSubset<T, ChatSessionCreateArgs<ExtArgs>>): Prisma__ChatSessionClient<$Result.GetResult<Prisma.$ChatSessionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ChatSessions.
     * @param {ChatSessionCreateManyArgs} args - Arguments to create many ChatSessions.
     * @example
     * // Create many ChatSessions
     * const chatSession = await prisma.chatSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChatSessionCreateManyArgs>(args?: SelectSubset<T, ChatSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChatSessions and returns the data saved in the database.
     * @param {ChatSessionCreateManyAndReturnArgs} args - Arguments to create many ChatSessions.
     * @example
     * // Create many ChatSessions
     * const chatSession = await prisma.chatSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChatSessions and only return the `id`
     * const chatSessionWithIdOnly = await prisma.chatSession.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChatSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, ChatSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatSessionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ChatSession.
     * @param {ChatSessionDeleteArgs} args - Arguments to delete one ChatSession.
     * @example
     * // Delete one ChatSession
     * const ChatSession = await prisma.chatSession.delete({
     *   where: {
     *     // ... filter to delete one ChatSession
     *   }
     * })
     * 
     */
    delete<T extends ChatSessionDeleteArgs>(args: SelectSubset<T, ChatSessionDeleteArgs<ExtArgs>>): Prisma__ChatSessionClient<$Result.GetResult<Prisma.$ChatSessionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ChatSession.
     * @param {ChatSessionUpdateArgs} args - Arguments to update one ChatSession.
     * @example
     * // Update one ChatSession
     * const chatSession = await prisma.chatSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChatSessionUpdateArgs>(args: SelectSubset<T, ChatSessionUpdateArgs<ExtArgs>>): Prisma__ChatSessionClient<$Result.GetResult<Prisma.$ChatSessionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ChatSessions.
     * @param {ChatSessionDeleteManyArgs} args - Arguments to filter ChatSessions to delete.
     * @example
     * // Delete a few ChatSessions
     * const { count } = await prisma.chatSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChatSessionDeleteManyArgs>(args?: SelectSubset<T, ChatSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChatSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChatSessions
     * const chatSession = await prisma.chatSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChatSessionUpdateManyArgs>(args: SelectSubset<T, ChatSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ChatSession.
     * @param {ChatSessionUpsertArgs} args - Arguments to update or create a ChatSession.
     * @example
     * // Update or create a ChatSession
     * const chatSession = await prisma.chatSession.upsert({
     *   create: {
     *     // ... data to create a ChatSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChatSession we want to update
     *   }
     * })
     */
    upsert<T extends ChatSessionUpsertArgs>(args: SelectSubset<T, ChatSessionUpsertArgs<ExtArgs>>): Prisma__ChatSessionClient<$Result.GetResult<Prisma.$ChatSessionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ChatSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatSessionCountArgs} args - Arguments to filter ChatSessions to count.
     * @example
     * // Count the number of ChatSessions
     * const count = await prisma.chatSession.count({
     *   where: {
     *     // ... the filter for the ChatSessions we want to count
     *   }
     * })
    **/
    count<T extends ChatSessionCountArgs>(
      args?: Subset<T, ChatSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChatSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatSessionAggregateArgs>(args: Subset<T, ChatSessionAggregateArgs>): Prisma.PrismaPromise<GetChatSessionAggregateType<T>>

    /**
     * Group by ChatSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChatSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChatSessionGroupByArgs['orderBy'] }
        : { orderBy?: ChatSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChatSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChatSession model
   */
  readonly fields: ChatSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChatSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChatSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    vendor<T extends VendorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VendorDefaultArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChatSession model
   */ 
  interface ChatSessionFieldRefs {
    readonly id: FieldRef<"ChatSession", 'String'>
    readonly userId: FieldRef<"ChatSession", 'String'>
    readonly vendorId: FieldRef<"ChatSession", 'String'>
    readonly lastMessageAt: FieldRef<"ChatSession", 'DateTime'>
    readonly isActive: FieldRef<"ChatSession", 'Boolean'>
    readonly createdAt: FieldRef<"ChatSession", 'DateTime'>
    readonly updatedAt: FieldRef<"ChatSession", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ChatSession findUnique
   */
  export type ChatSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatSession
     */
    select?: ChatSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatSessionInclude<ExtArgs> | null
    /**
     * Filter, which ChatSession to fetch.
     */
    where: ChatSessionWhereUniqueInput
  }

  /**
   * ChatSession findUniqueOrThrow
   */
  export type ChatSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatSession
     */
    select?: ChatSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatSessionInclude<ExtArgs> | null
    /**
     * Filter, which ChatSession to fetch.
     */
    where: ChatSessionWhereUniqueInput
  }

  /**
   * ChatSession findFirst
   */
  export type ChatSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatSession
     */
    select?: ChatSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatSessionInclude<ExtArgs> | null
    /**
     * Filter, which ChatSession to fetch.
     */
    where?: ChatSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatSessions to fetch.
     */
    orderBy?: ChatSessionOrderByWithRelationInput | ChatSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatSessions.
     */
    cursor?: ChatSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatSessions.
     */
    distinct?: ChatSessionScalarFieldEnum | ChatSessionScalarFieldEnum[]
  }

  /**
   * ChatSession findFirstOrThrow
   */
  export type ChatSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatSession
     */
    select?: ChatSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatSessionInclude<ExtArgs> | null
    /**
     * Filter, which ChatSession to fetch.
     */
    where?: ChatSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatSessions to fetch.
     */
    orderBy?: ChatSessionOrderByWithRelationInput | ChatSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatSessions.
     */
    cursor?: ChatSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatSessions.
     */
    distinct?: ChatSessionScalarFieldEnum | ChatSessionScalarFieldEnum[]
  }

  /**
   * ChatSession findMany
   */
  export type ChatSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatSession
     */
    select?: ChatSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatSessionInclude<ExtArgs> | null
    /**
     * Filter, which ChatSessions to fetch.
     */
    where?: ChatSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatSessions to fetch.
     */
    orderBy?: ChatSessionOrderByWithRelationInput | ChatSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChatSessions.
     */
    cursor?: ChatSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatSessions.
     */
    skip?: number
    distinct?: ChatSessionScalarFieldEnum | ChatSessionScalarFieldEnum[]
  }

  /**
   * ChatSession create
   */
  export type ChatSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatSession
     */
    select?: ChatSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a ChatSession.
     */
    data: XOR<ChatSessionCreateInput, ChatSessionUncheckedCreateInput>
  }

  /**
   * ChatSession createMany
   */
  export type ChatSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChatSessions.
     */
    data: ChatSessionCreateManyInput | ChatSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChatSession createManyAndReturn
   */
  export type ChatSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatSession
     */
    select?: ChatSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ChatSessions.
     */
    data: ChatSessionCreateManyInput | ChatSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChatSession update
   */
  export type ChatSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatSession
     */
    select?: ChatSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a ChatSession.
     */
    data: XOR<ChatSessionUpdateInput, ChatSessionUncheckedUpdateInput>
    /**
     * Choose, which ChatSession to update.
     */
    where: ChatSessionWhereUniqueInput
  }

  /**
   * ChatSession updateMany
   */
  export type ChatSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChatSessions.
     */
    data: XOR<ChatSessionUpdateManyMutationInput, ChatSessionUncheckedUpdateManyInput>
    /**
     * Filter which ChatSessions to update
     */
    where?: ChatSessionWhereInput
  }

  /**
   * ChatSession upsert
   */
  export type ChatSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatSession
     */
    select?: ChatSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the ChatSession to update in case it exists.
     */
    where: ChatSessionWhereUniqueInput
    /**
     * In case the ChatSession found by the `where` argument doesn't exist, create a new ChatSession with this data.
     */
    create: XOR<ChatSessionCreateInput, ChatSessionUncheckedCreateInput>
    /**
     * In case the ChatSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChatSessionUpdateInput, ChatSessionUncheckedUpdateInput>
  }

  /**
   * ChatSession delete
   */
  export type ChatSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatSession
     */
    select?: ChatSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatSessionInclude<ExtArgs> | null
    /**
     * Filter which ChatSession to delete.
     */
    where: ChatSessionWhereUniqueInput
  }

  /**
   * ChatSession deleteMany
   */
  export type ChatSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatSessions to delete
     */
    where?: ChatSessionWhereInput
  }

  /**
   * ChatSession without action
   */
  export type ChatSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatSession
     */
    select?: ChatSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatSessionInclude<ExtArgs> | null
  }


  /**
   * Model Review
   */

  export type AggregateReview = {
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  export type ReviewAvgAggregateOutputType = {
    rating: number | null
  }

  export type ReviewSumAggregateOutputType = {
    rating: number | null
  }

  export type ReviewMinAggregateOutputType = {
    id: string | null
    userId: string | null
    vendorId: string | null
    rating: number | null
    comment: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReviewMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    vendorId: string | null
    rating: number | null
    comment: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReviewCountAggregateOutputType = {
    id: number
    userId: number
    vendorId: number
    rating: number
    comment: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ReviewAvgAggregateInputType = {
    rating?: true
  }

  export type ReviewSumAggregateInputType = {
    rating?: true
  }

  export type ReviewMinAggregateInputType = {
    id?: true
    userId?: true
    vendorId?: true
    rating?: true
    comment?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReviewMaxAggregateInputType = {
    id?: true
    userId?: true
    vendorId?: true
    rating?: true
    comment?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReviewCountAggregateInputType = {
    id?: true
    userId?: true
    vendorId?: true
    rating?: true
    comment?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ReviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Review to aggregate.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reviews
    **/
    _count?: true | ReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReviewMaxAggregateInputType
  }

  export type GetReviewAggregateType<T extends ReviewAggregateArgs> = {
        [P in keyof T & keyof AggregateReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReview[P]>
      : GetScalarType<T[P], AggregateReview[P]>
  }




  export type ReviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithAggregationInput | ReviewOrderByWithAggregationInput[]
    by: ReviewScalarFieldEnum[] | ReviewScalarFieldEnum
    having?: ReviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReviewCountAggregateInputType | true
    _avg?: ReviewAvgAggregateInputType
    _sum?: ReviewSumAggregateInputType
    _min?: ReviewMinAggregateInputType
    _max?: ReviewMaxAggregateInputType
  }

  export type ReviewGroupByOutputType = {
    id: string
    userId: string
    vendorId: string
    rating: number
    comment: string | null
    createdAt: Date
    updatedAt: Date
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  type GetReviewGroupByPayload<T extends ReviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReviewGroupByOutputType[P]>
            : GetScalarType<T[P], ReviewGroupByOutputType[P]>
        }
      >
    >


  export type ReviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    vendorId?: boolean
    rating?: boolean
    comment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    vendorId?: boolean
    rating?: boolean
    comment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectScalar = {
    id?: boolean
    userId?: boolean
    vendorId?: boolean
    rating?: boolean
    comment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ReviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }
  export type ReviewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }

  export type $ReviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Review"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      vendor: Prisma.$VendorPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      vendorId: string
      rating: number
      comment: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["review"]>
    composites: {}
  }

  type ReviewGetPayload<S extends boolean | null | undefined | ReviewDefaultArgs> = $Result.GetResult<Prisma.$ReviewPayload, S>

  type ReviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReviewFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReviewCountAggregateInputType | true
    }

  export interface ReviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Review'], meta: { name: 'Review' } }
    /**
     * Find zero or one Review that matches the filter.
     * @param {ReviewFindUniqueArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReviewFindUniqueArgs>(args: SelectSubset<T, ReviewFindUniqueArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Review that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ReviewFindUniqueOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReviewFindUniqueOrThrowArgs>(args: SelectSubset<T, ReviewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Review that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReviewFindFirstArgs>(args?: SelectSubset<T, ReviewFindFirstArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Review that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReviewFindFirstOrThrowArgs>(args?: SelectSubset<T, ReviewFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Reviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reviews
     * const reviews = await prisma.review.findMany()
     * 
     * // Get first 10 Reviews
     * const reviews = await prisma.review.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reviewWithIdOnly = await prisma.review.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReviewFindManyArgs>(args?: SelectSubset<T, ReviewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Review.
     * @param {ReviewCreateArgs} args - Arguments to create a Review.
     * @example
     * // Create one Review
     * const Review = await prisma.review.create({
     *   data: {
     *     // ... data to create a Review
     *   }
     * })
     * 
     */
    create<T extends ReviewCreateArgs>(args: SelectSubset<T, ReviewCreateArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Reviews.
     * @param {ReviewCreateManyArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReviewCreateManyArgs>(args?: SelectSubset<T, ReviewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reviews and returns the data saved in the database.
     * @param {ReviewCreateManyAndReturnArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reviews and only return the `id`
     * const reviewWithIdOnly = await prisma.review.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReviewCreateManyAndReturnArgs>(args?: SelectSubset<T, ReviewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Review.
     * @param {ReviewDeleteArgs} args - Arguments to delete one Review.
     * @example
     * // Delete one Review
     * const Review = await prisma.review.delete({
     *   where: {
     *     // ... filter to delete one Review
     *   }
     * })
     * 
     */
    delete<T extends ReviewDeleteArgs>(args: SelectSubset<T, ReviewDeleteArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Review.
     * @param {ReviewUpdateArgs} args - Arguments to update one Review.
     * @example
     * // Update one Review
     * const review = await prisma.review.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReviewUpdateArgs>(args: SelectSubset<T, ReviewUpdateArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Reviews.
     * @param {ReviewDeleteManyArgs} args - Arguments to filter Reviews to delete.
     * @example
     * // Delete a few Reviews
     * const { count } = await prisma.review.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReviewDeleteManyArgs>(args?: SelectSubset<T, ReviewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReviewUpdateManyArgs>(args: SelectSubset<T, ReviewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Review.
     * @param {ReviewUpsertArgs} args - Arguments to update or create a Review.
     * @example
     * // Update or create a Review
     * const review = await prisma.review.upsert({
     *   create: {
     *     // ... data to create a Review
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Review we want to update
     *   }
     * })
     */
    upsert<T extends ReviewUpsertArgs>(args: SelectSubset<T, ReviewUpsertArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewCountArgs} args - Arguments to filter Reviews to count.
     * @example
     * // Count the number of Reviews
     * const count = await prisma.review.count({
     *   where: {
     *     // ... the filter for the Reviews we want to count
     *   }
     * })
    **/
    count<T extends ReviewCountArgs>(
      args?: Subset<T, ReviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewAggregateArgs>(args: Subset<T, ReviewAggregateArgs>): Prisma.PrismaPromise<GetReviewAggregateType<T>>

    /**
     * Group by Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReviewGroupByArgs['orderBy'] }
        : { orderBy?: ReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Review model
   */
  readonly fields: ReviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Review.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    vendor<T extends VendorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VendorDefaultArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Review model
   */ 
  interface ReviewFieldRefs {
    readonly id: FieldRef<"Review", 'String'>
    readonly userId: FieldRef<"Review", 'String'>
    readonly vendorId: FieldRef<"Review", 'String'>
    readonly rating: FieldRef<"Review", 'Int'>
    readonly comment: FieldRef<"Review", 'String'>
    readonly createdAt: FieldRef<"Review", 'DateTime'>
    readonly updatedAt: FieldRef<"Review", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Review findUnique
   */
  export type ReviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review findUniqueOrThrow
   */
  export type ReviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review findFirst
   */
  export type ReviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review findFirstOrThrow
   */
  export type ReviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review findMany
   */
  export type ReviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Reviews to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review create
   */
  export type ReviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to create a Review.
     */
    data: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
  }

  /**
   * Review createMany
   */
  export type ReviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reviews.
     */
    data: ReviewCreateManyInput | ReviewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Review createManyAndReturn
   */
  export type ReviewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Reviews.
     */
    data: ReviewCreateManyInput | ReviewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Review update
   */
  export type ReviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to update a Review.
     */
    data: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
    /**
     * Choose, which Review to update.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review updateMany
   */
  export type ReviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reviews.
     */
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyInput>
    /**
     * Filter which Reviews to update
     */
    where?: ReviewWhereInput
  }

  /**
   * Review upsert
   */
  export type ReviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The filter to search for the Review to update in case it exists.
     */
    where: ReviewWhereUniqueInput
    /**
     * In case the Review found by the `where` argument doesn't exist, create a new Review with this data.
     */
    create: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
    /**
     * In case the Review was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
  }

  /**
   * Review delete
   */
  export type ReviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter which Review to delete.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review deleteMany
   */
  export type ReviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reviews to delete
     */
    where?: ReviewWhereInput
  }

  /**
   * Review without action
   */
  export type ReviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    message: string | null
    type: string | null
    isRead: boolean | null
    createdAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    message: string | null
    type: string | null
    isRead: boolean | null
    createdAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    message: number
    type: number
    isRead: number
    createdAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    message?: true
    type?: true
    isRead?: true
    createdAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    message?: true
    type?: true
    isRead?: true
    createdAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    message?: true
    type?: true
    isRead?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    userId: string
    title: string
    message: string
    type: string
    isRead: boolean
    createdAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    isRead?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    isRead?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    isRead?: boolean
    createdAt?: boolean
  }

  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      title: string
      message: string
      type: string
      isRead: boolean
      createdAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */ 
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'String'>
    readonly isRead: FieldRef<"Notification", 'Boolean'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model WeddingChecklist
   */

  export type AggregateWeddingChecklist = {
    _count: WeddingChecklistCountAggregateOutputType | null
    _min: WeddingChecklistMinAggregateOutputType | null
    _max: WeddingChecklistMaxAggregateOutputType | null
  }

  export type WeddingChecklistMinAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    description: string | null
    category: string | null
    isCompleted: boolean | null
    dueDate: Date | null
    priority: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WeddingChecklistMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    description: string | null
    category: string | null
    isCompleted: boolean | null
    dueDate: Date | null
    priority: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WeddingChecklistCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    description: number
    category: number
    isCompleted: number
    dueDate: number
    priority: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WeddingChecklistMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    description?: true
    category?: true
    isCompleted?: true
    dueDate?: true
    priority?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WeddingChecklistMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    description?: true
    category?: true
    isCompleted?: true
    dueDate?: true
    priority?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WeddingChecklistCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    description?: true
    category?: true
    isCompleted?: true
    dueDate?: true
    priority?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WeddingChecklistAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WeddingChecklist to aggregate.
     */
    where?: WeddingChecklistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeddingChecklists to fetch.
     */
    orderBy?: WeddingChecklistOrderByWithRelationInput | WeddingChecklistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WeddingChecklistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeddingChecklists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeddingChecklists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WeddingChecklists
    **/
    _count?: true | WeddingChecklistCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WeddingChecklistMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WeddingChecklistMaxAggregateInputType
  }

  export type GetWeddingChecklistAggregateType<T extends WeddingChecklistAggregateArgs> = {
        [P in keyof T & keyof AggregateWeddingChecklist]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWeddingChecklist[P]>
      : GetScalarType<T[P], AggregateWeddingChecklist[P]>
  }




  export type WeddingChecklistGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WeddingChecklistWhereInput
    orderBy?: WeddingChecklistOrderByWithAggregationInput | WeddingChecklistOrderByWithAggregationInput[]
    by: WeddingChecklistScalarFieldEnum[] | WeddingChecklistScalarFieldEnum
    having?: WeddingChecklistScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WeddingChecklistCountAggregateInputType | true
    _min?: WeddingChecklistMinAggregateInputType
    _max?: WeddingChecklistMaxAggregateInputType
  }

  export type WeddingChecklistGroupByOutputType = {
    id: string
    userId: string
    title: string
    description: string | null
    category: string
    isCompleted: boolean
    dueDate: Date | null
    priority: string
    createdAt: Date
    updatedAt: Date
    _count: WeddingChecklistCountAggregateOutputType | null
    _min: WeddingChecklistMinAggregateOutputType | null
    _max: WeddingChecklistMaxAggregateOutputType | null
  }

  type GetWeddingChecklistGroupByPayload<T extends WeddingChecklistGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WeddingChecklistGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WeddingChecklistGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WeddingChecklistGroupByOutputType[P]>
            : GetScalarType<T[P], WeddingChecklistGroupByOutputType[P]>
        }
      >
    >


  export type WeddingChecklistSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    isCompleted?: boolean
    dueDate?: boolean
    priority?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["weddingChecklist"]>

  export type WeddingChecklistSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    isCompleted?: boolean
    dueDate?: boolean
    priority?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["weddingChecklist"]>

  export type WeddingChecklistSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    isCompleted?: boolean
    dueDate?: boolean
    priority?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $WeddingChecklistPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WeddingChecklist"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      title: string
      description: string | null
      category: string
      isCompleted: boolean
      dueDate: Date | null
      priority: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["weddingChecklist"]>
    composites: {}
  }

  type WeddingChecklistGetPayload<S extends boolean | null | undefined | WeddingChecklistDefaultArgs> = $Result.GetResult<Prisma.$WeddingChecklistPayload, S>

  type WeddingChecklistCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WeddingChecklistFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WeddingChecklistCountAggregateInputType | true
    }

  export interface WeddingChecklistDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WeddingChecklist'], meta: { name: 'WeddingChecklist' } }
    /**
     * Find zero or one WeddingChecklist that matches the filter.
     * @param {WeddingChecklistFindUniqueArgs} args - Arguments to find a WeddingChecklist
     * @example
     * // Get one WeddingChecklist
     * const weddingChecklist = await prisma.weddingChecklist.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WeddingChecklistFindUniqueArgs>(args: SelectSubset<T, WeddingChecklistFindUniqueArgs<ExtArgs>>): Prisma__WeddingChecklistClient<$Result.GetResult<Prisma.$WeddingChecklistPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WeddingChecklist that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WeddingChecklistFindUniqueOrThrowArgs} args - Arguments to find a WeddingChecklist
     * @example
     * // Get one WeddingChecklist
     * const weddingChecklist = await prisma.weddingChecklist.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WeddingChecklistFindUniqueOrThrowArgs>(args: SelectSubset<T, WeddingChecklistFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WeddingChecklistClient<$Result.GetResult<Prisma.$WeddingChecklistPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WeddingChecklist that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeddingChecklistFindFirstArgs} args - Arguments to find a WeddingChecklist
     * @example
     * // Get one WeddingChecklist
     * const weddingChecklist = await prisma.weddingChecklist.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WeddingChecklistFindFirstArgs>(args?: SelectSubset<T, WeddingChecklistFindFirstArgs<ExtArgs>>): Prisma__WeddingChecklistClient<$Result.GetResult<Prisma.$WeddingChecklistPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WeddingChecklist that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeddingChecklistFindFirstOrThrowArgs} args - Arguments to find a WeddingChecklist
     * @example
     * // Get one WeddingChecklist
     * const weddingChecklist = await prisma.weddingChecklist.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WeddingChecklistFindFirstOrThrowArgs>(args?: SelectSubset<T, WeddingChecklistFindFirstOrThrowArgs<ExtArgs>>): Prisma__WeddingChecklistClient<$Result.GetResult<Prisma.$WeddingChecklistPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WeddingChecklists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeddingChecklistFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WeddingChecklists
     * const weddingChecklists = await prisma.weddingChecklist.findMany()
     * 
     * // Get first 10 WeddingChecklists
     * const weddingChecklists = await prisma.weddingChecklist.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const weddingChecklistWithIdOnly = await prisma.weddingChecklist.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WeddingChecklistFindManyArgs>(args?: SelectSubset<T, WeddingChecklistFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeddingChecklistPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WeddingChecklist.
     * @param {WeddingChecklistCreateArgs} args - Arguments to create a WeddingChecklist.
     * @example
     * // Create one WeddingChecklist
     * const WeddingChecklist = await prisma.weddingChecklist.create({
     *   data: {
     *     // ... data to create a WeddingChecklist
     *   }
     * })
     * 
     */
    create<T extends WeddingChecklistCreateArgs>(args: SelectSubset<T, WeddingChecklistCreateArgs<ExtArgs>>): Prisma__WeddingChecklistClient<$Result.GetResult<Prisma.$WeddingChecklistPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WeddingChecklists.
     * @param {WeddingChecklistCreateManyArgs} args - Arguments to create many WeddingChecklists.
     * @example
     * // Create many WeddingChecklists
     * const weddingChecklist = await prisma.weddingChecklist.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WeddingChecklistCreateManyArgs>(args?: SelectSubset<T, WeddingChecklistCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WeddingChecklists and returns the data saved in the database.
     * @param {WeddingChecklistCreateManyAndReturnArgs} args - Arguments to create many WeddingChecklists.
     * @example
     * // Create many WeddingChecklists
     * const weddingChecklist = await prisma.weddingChecklist.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WeddingChecklists and only return the `id`
     * const weddingChecklistWithIdOnly = await prisma.weddingChecklist.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WeddingChecklistCreateManyAndReturnArgs>(args?: SelectSubset<T, WeddingChecklistCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeddingChecklistPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a WeddingChecklist.
     * @param {WeddingChecklistDeleteArgs} args - Arguments to delete one WeddingChecklist.
     * @example
     * // Delete one WeddingChecklist
     * const WeddingChecklist = await prisma.weddingChecklist.delete({
     *   where: {
     *     // ... filter to delete one WeddingChecklist
     *   }
     * })
     * 
     */
    delete<T extends WeddingChecklistDeleteArgs>(args: SelectSubset<T, WeddingChecklistDeleteArgs<ExtArgs>>): Prisma__WeddingChecklistClient<$Result.GetResult<Prisma.$WeddingChecklistPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WeddingChecklist.
     * @param {WeddingChecklistUpdateArgs} args - Arguments to update one WeddingChecklist.
     * @example
     * // Update one WeddingChecklist
     * const weddingChecklist = await prisma.weddingChecklist.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WeddingChecklistUpdateArgs>(args: SelectSubset<T, WeddingChecklistUpdateArgs<ExtArgs>>): Prisma__WeddingChecklistClient<$Result.GetResult<Prisma.$WeddingChecklistPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WeddingChecklists.
     * @param {WeddingChecklistDeleteManyArgs} args - Arguments to filter WeddingChecklists to delete.
     * @example
     * // Delete a few WeddingChecklists
     * const { count } = await prisma.weddingChecklist.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WeddingChecklistDeleteManyArgs>(args?: SelectSubset<T, WeddingChecklistDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WeddingChecklists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeddingChecklistUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WeddingChecklists
     * const weddingChecklist = await prisma.weddingChecklist.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WeddingChecklistUpdateManyArgs>(args: SelectSubset<T, WeddingChecklistUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WeddingChecklist.
     * @param {WeddingChecklistUpsertArgs} args - Arguments to update or create a WeddingChecklist.
     * @example
     * // Update or create a WeddingChecklist
     * const weddingChecklist = await prisma.weddingChecklist.upsert({
     *   create: {
     *     // ... data to create a WeddingChecklist
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WeddingChecklist we want to update
     *   }
     * })
     */
    upsert<T extends WeddingChecklistUpsertArgs>(args: SelectSubset<T, WeddingChecklistUpsertArgs<ExtArgs>>): Prisma__WeddingChecklistClient<$Result.GetResult<Prisma.$WeddingChecklistPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WeddingChecklists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeddingChecklistCountArgs} args - Arguments to filter WeddingChecklists to count.
     * @example
     * // Count the number of WeddingChecklists
     * const count = await prisma.weddingChecklist.count({
     *   where: {
     *     // ... the filter for the WeddingChecklists we want to count
     *   }
     * })
    **/
    count<T extends WeddingChecklistCountArgs>(
      args?: Subset<T, WeddingChecklistCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WeddingChecklistCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WeddingChecklist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeddingChecklistAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WeddingChecklistAggregateArgs>(args: Subset<T, WeddingChecklistAggregateArgs>): Prisma.PrismaPromise<GetWeddingChecklistAggregateType<T>>

    /**
     * Group by WeddingChecklist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeddingChecklistGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WeddingChecklistGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WeddingChecklistGroupByArgs['orderBy'] }
        : { orderBy?: WeddingChecklistGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WeddingChecklistGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWeddingChecklistGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WeddingChecklist model
   */
  readonly fields: WeddingChecklistFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WeddingChecklist.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WeddingChecklistClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WeddingChecklist model
   */ 
  interface WeddingChecklistFieldRefs {
    readonly id: FieldRef<"WeddingChecklist", 'String'>
    readonly userId: FieldRef<"WeddingChecklist", 'String'>
    readonly title: FieldRef<"WeddingChecklist", 'String'>
    readonly description: FieldRef<"WeddingChecklist", 'String'>
    readonly category: FieldRef<"WeddingChecklist", 'String'>
    readonly isCompleted: FieldRef<"WeddingChecklist", 'Boolean'>
    readonly dueDate: FieldRef<"WeddingChecklist", 'DateTime'>
    readonly priority: FieldRef<"WeddingChecklist", 'String'>
    readonly createdAt: FieldRef<"WeddingChecklist", 'DateTime'>
    readonly updatedAt: FieldRef<"WeddingChecklist", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WeddingChecklist findUnique
   */
  export type WeddingChecklistFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeddingChecklist
     */
    select?: WeddingChecklistSelect<ExtArgs> | null
    /**
     * Filter, which WeddingChecklist to fetch.
     */
    where: WeddingChecklistWhereUniqueInput
  }

  /**
   * WeddingChecklist findUniqueOrThrow
   */
  export type WeddingChecklistFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeddingChecklist
     */
    select?: WeddingChecklistSelect<ExtArgs> | null
    /**
     * Filter, which WeddingChecklist to fetch.
     */
    where: WeddingChecklistWhereUniqueInput
  }

  /**
   * WeddingChecklist findFirst
   */
  export type WeddingChecklistFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeddingChecklist
     */
    select?: WeddingChecklistSelect<ExtArgs> | null
    /**
     * Filter, which WeddingChecklist to fetch.
     */
    where?: WeddingChecklistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeddingChecklists to fetch.
     */
    orderBy?: WeddingChecklistOrderByWithRelationInput | WeddingChecklistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WeddingChecklists.
     */
    cursor?: WeddingChecklistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeddingChecklists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeddingChecklists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WeddingChecklists.
     */
    distinct?: WeddingChecklistScalarFieldEnum | WeddingChecklistScalarFieldEnum[]
  }

  /**
   * WeddingChecklist findFirstOrThrow
   */
  export type WeddingChecklistFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeddingChecklist
     */
    select?: WeddingChecklistSelect<ExtArgs> | null
    /**
     * Filter, which WeddingChecklist to fetch.
     */
    where?: WeddingChecklistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeddingChecklists to fetch.
     */
    orderBy?: WeddingChecklistOrderByWithRelationInput | WeddingChecklistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WeddingChecklists.
     */
    cursor?: WeddingChecklistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeddingChecklists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeddingChecklists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WeddingChecklists.
     */
    distinct?: WeddingChecklistScalarFieldEnum | WeddingChecklistScalarFieldEnum[]
  }

  /**
   * WeddingChecklist findMany
   */
  export type WeddingChecklistFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeddingChecklist
     */
    select?: WeddingChecklistSelect<ExtArgs> | null
    /**
     * Filter, which WeddingChecklists to fetch.
     */
    where?: WeddingChecklistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeddingChecklists to fetch.
     */
    orderBy?: WeddingChecklistOrderByWithRelationInput | WeddingChecklistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WeddingChecklists.
     */
    cursor?: WeddingChecklistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeddingChecklists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeddingChecklists.
     */
    skip?: number
    distinct?: WeddingChecklistScalarFieldEnum | WeddingChecklistScalarFieldEnum[]
  }

  /**
   * WeddingChecklist create
   */
  export type WeddingChecklistCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeddingChecklist
     */
    select?: WeddingChecklistSelect<ExtArgs> | null
    /**
     * The data needed to create a WeddingChecklist.
     */
    data: XOR<WeddingChecklistCreateInput, WeddingChecklistUncheckedCreateInput>
  }

  /**
   * WeddingChecklist createMany
   */
  export type WeddingChecklistCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WeddingChecklists.
     */
    data: WeddingChecklistCreateManyInput | WeddingChecklistCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WeddingChecklist createManyAndReturn
   */
  export type WeddingChecklistCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeddingChecklist
     */
    select?: WeddingChecklistSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many WeddingChecklists.
     */
    data: WeddingChecklistCreateManyInput | WeddingChecklistCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WeddingChecklist update
   */
  export type WeddingChecklistUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeddingChecklist
     */
    select?: WeddingChecklistSelect<ExtArgs> | null
    /**
     * The data needed to update a WeddingChecklist.
     */
    data: XOR<WeddingChecklistUpdateInput, WeddingChecklistUncheckedUpdateInput>
    /**
     * Choose, which WeddingChecklist to update.
     */
    where: WeddingChecklistWhereUniqueInput
  }

  /**
   * WeddingChecklist updateMany
   */
  export type WeddingChecklistUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WeddingChecklists.
     */
    data: XOR<WeddingChecklistUpdateManyMutationInput, WeddingChecklistUncheckedUpdateManyInput>
    /**
     * Filter which WeddingChecklists to update
     */
    where?: WeddingChecklistWhereInput
  }

  /**
   * WeddingChecklist upsert
   */
  export type WeddingChecklistUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeddingChecklist
     */
    select?: WeddingChecklistSelect<ExtArgs> | null
    /**
     * The filter to search for the WeddingChecklist to update in case it exists.
     */
    where: WeddingChecklistWhereUniqueInput
    /**
     * In case the WeddingChecklist found by the `where` argument doesn't exist, create a new WeddingChecklist with this data.
     */
    create: XOR<WeddingChecklistCreateInput, WeddingChecklistUncheckedCreateInput>
    /**
     * In case the WeddingChecklist was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WeddingChecklistUpdateInput, WeddingChecklistUncheckedUpdateInput>
  }

  /**
   * WeddingChecklist delete
   */
  export type WeddingChecklistDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeddingChecklist
     */
    select?: WeddingChecklistSelect<ExtArgs> | null
    /**
     * Filter which WeddingChecklist to delete.
     */
    where: WeddingChecklistWhereUniqueInput
  }

  /**
   * WeddingChecklist deleteMany
   */
  export type WeddingChecklistDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WeddingChecklists to delete
     */
    where?: WeddingChecklistWhereInput
  }

  /**
   * WeddingChecklist without action
   */
  export type WeddingChecklistDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeddingChecklist
     */
    select?: WeddingChecklistSelect<ExtArgs> | null
  }


  /**
   * Model AIConversation
   */

  export type AggregateAIConversation = {
    _count: AIConversationCountAggregateOutputType | null
    _min: AIConversationMinAggregateOutputType | null
    _max: AIConversationMaxAggregateOutputType | null
  }

  export type AIConversationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AIConversationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AIConversationCountAggregateOutputType = {
    id: number
    userId: number
    messages: number
    context: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AIConversationMinAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AIConversationMaxAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AIConversationCountAggregateInputType = {
    id?: true
    userId?: true
    messages?: true
    context?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AIConversationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIConversation to aggregate.
     */
    where?: AIConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIConversations to fetch.
     */
    orderBy?: AIConversationOrderByWithRelationInput | AIConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AIConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIConversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIConversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AIConversations
    **/
    _count?: true | AIConversationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AIConversationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AIConversationMaxAggregateInputType
  }

  export type GetAIConversationAggregateType<T extends AIConversationAggregateArgs> = {
        [P in keyof T & keyof AggregateAIConversation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAIConversation[P]>
      : GetScalarType<T[P], AggregateAIConversation[P]>
  }




  export type AIConversationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIConversationWhereInput
    orderBy?: AIConversationOrderByWithAggregationInput | AIConversationOrderByWithAggregationInput[]
    by: AIConversationScalarFieldEnum[] | AIConversationScalarFieldEnum
    having?: AIConversationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AIConversationCountAggregateInputType | true
    _min?: AIConversationMinAggregateInputType
    _max?: AIConversationMaxAggregateInputType
  }

  export type AIConversationGroupByOutputType = {
    id: string
    userId: string
    messages: JsonValue
    context: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: AIConversationCountAggregateOutputType | null
    _min: AIConversationMinAggregateOutputType | null
    _max: AIConversationMaxAggregateOutputType | null
  }

  type GetAIConversationGroupByPayload<T extends AIConversationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AIConversationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AIConversationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AIConversationGroupByOutputType[P]>
            : GetScalarType<T[P], AIConversationGroupByOutputType[P]>
        }
      >
    >


  export type AIConversationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    messages?: boolean
    context?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["aIConversation"]>

  export type AIConversationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    messages?: boolean
    context?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["aIConversation"]>

  export type AIConversationSelectScalar = {
    id?: boolean
    userId?: boolean
    messages?: boolean
    context?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $AIConversationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AIConversation"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      messages: Prisma.JsonValue
      context: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["aIConversation"]>
    composites: {}
  }

  type AIConversationGetPayload<S extends boolean | null | undefined | AIConversationDefaultArgs> = $Result.GetResult<Prisma.$AIConversationPayload, S>

  type AIConversationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AIConversationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AIConversationCountAggregateInputType | true
    }

  export interface AIConversationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AIConversation'], meta: { name: 'AIConversation' } }
    /**
     * Find zero or one AIConversation that matches the filter.
     * @param {AIConversationFindUniqueArgs} args - Arguments to find a AIConversation
     * @example
     * // Get one AIConversation
     * const aIConversation = await prisma.aIConversation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AIConversationFindUniqueArgs>(args: SelectSubset<T, AIConversationFindUniqueArgs<ExtArgs>>): Prisma__AIConversationClient<$Result.GetResult<Prisma.$AIConversationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AIConversation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AIConversationFindUniqueOrThrowArgs} args - Arguments to find a AIConversation
     * @example
     * // Get one AIConversation
     * const aIConversation = await prisma.aIConversation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AIConversationFindUniqueOrThrowArgs>(args: SelectSubset<T, AIConversationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AIConversationClient<$Result.GetResult<Prisma.$AIConversationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AIConversation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIConversationFindFirstArgs} args - Arguments to find a AIConversation
     * @example
     * // Get one AIConversation
     * const aIConversation = await prisma.aIConversation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AIConversationFindFirstArgs>(args?: SelectSubset<T, AIConversationFindFirstArgs<ExtArgs>>): Prisma__AIConversationClient<$Result.GetResult<Prisma.$AIConversationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AIConversation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIConversationFindFirstOrThrowArgs} args - Arguments to find a AIConversation
     * @example
     * // Get one AIConversation
     * const aIConversation = await prisma.aIConversation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AIConversationFindFirstOrThrowArgs>(args?: SelectSubset<T, AIConversationFindFirstOrThrowArgs<ExtArgs>>): Prisma__AIConversationClient<$Result.GetResult<Prisma.$AIConversationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AIConversations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIConversationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AIConversations
     * const aIConversations = await prisma.aIConversation.findMany()
     * 
     * // Get first 10 AIConversations
     * const aIConversations = await prisma.aIConversation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aIConversationWithIdOnly = await prisma.aIConversation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AIConversationFindManyArgs>(args?: SelectSubset<T, AIConversationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIConversationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AIConversation.
     * @param {AIConversationCreateArgs} args - Arguments to create a AIConversation.
     * @example
     * // Create one AIConversation
     * const AIConversation = await prisma.aIConversation.create({
     *   data: {
     *     // ... data to create a AIConversation
     *   }
     * })
     * 
     */
    create<T extends AIConversationCreateArgs>(args: SelectSubset<T, AIConversationCreateArgs<ExtArgs>>): Prisma__AIConversationClient<$Result.GetResult<Prisma.$AIConversationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AIConversations.
     * @param {AIConversationCreateManyArgs} args - Arguments to create many AIConversations.
     * @example
     * // Create many AIConversations
     * const aIConversation = await prisma.aIConversation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AIConversationCreateManyArgs>(args?: SelectSubset<T, AIConversationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AIConversations and returns the data saved in the database.
     * @param {AIConversationCreateManyAndReturnArgs} args - Arguments to create many AIConversations.
     * @example
     * // Create many AIConversations
     * const aIConversation = await prisma.aIConversation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AIConversations and only return the `id`
     * const aIConversationWithIdOnly = await prisma.aIConversation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AIConversationCreateManyAndReturnArgs>(args?: SelectSubset<T, AIConversationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIConversationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AIConversation.
     * @param {AIConversationDeleteArgs} args - Arguments to delete one AIConversation.
     * @example
     * // Delete one AIConversation
     * const AIConversation = await prisma.aIConversation.delete({
     *   where: {
     *     // ... filter to delete one AIConversation
     *   }
     * })
     * 
     */
    delete<T extends AIConversationDeleteArgs>(args: SelectSubset<T, AIConversationDeleteArgs<ExtArgs>>): Prisma__AIConversationClient<$Result.GetResult<Prisma.$AIConversationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AIConversation.
     * @param {AIConversationUpdateArgs} args - Arguments to update one AIConversation.
     * @example
     * // Update one AIConversation
     * const aIConversation = await prisma.aIConversation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AIConversationUpdateArgs>(args: SelectSubset<T, AIConversationUpdateArgs<ExtArgs>>): Prisma__AIConversationClient<$Result.GetResult<Prisma.$AIConversationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AIConversations.
     * @param {AIConversationDeleteManyArgs} args - Arguments to filter AIConversations to delete.
     * @example
     * // Delete a few AIConversations
     * const { count } = await prisma.aIConversation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AIConversationDeleteManyArgs>(args?: SelectSubset<T, AIConversationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIConversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIConversationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AIConversations
     * const aIConversation = await prisma.aIConversation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AIConversationUpdateManyArgs>(args: SelectSubset<T, AIConversationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AIConversation.
     * @param {AIConversationUpsertArgs} args - Arguments to update or create a AIConversation.
     * @example
     * // Update or create a AIConversation
     * const aIConversation = await prisma.aIConversation.upsert({
     *   create: {
     *     // ... data to create a AIConversation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AIConversation we want to update
     *   }
     * })
     */
    upsert<T extends AIConversationUpsertArgs>(args: SelectSubset<T, AIConversationUpsertArgs<ExtArgs>>): Prisma__AIConversationClient<$Result.GetResult<Prisma.$AIConversationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AIConversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIConversationCountArgs} args - Arguments to filter AIConversations to count.
     * @example
     * // Count the number of AIConversations
     * const count = await prisma.aIConversation.count({
     *   where: {
     *     // ... the filter for the AIConversations we want to count
     *   }
     * })
    **/
    count<T extends AIConversationCountArgs>(
      args?: Subset<T, AIConversationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AIConversationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AIConversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIConversationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AIConversationAggregateArgs>(args: Subset<T, AIConversationAggregateArgs>): Prisma.PrismaPromise<GetAIConversationAggregateType<T>>

    /**
     * Group by AIConversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIConversationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AIConversationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AIConversationGroupByArgs['orderBy'] }
        : { orderBy?: AIConversationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AIConversationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAIConversationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AIConversation model
   */
  readonly fields: AIConversationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AIConversation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AIConversationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AIConversation model
   */ 
  interface AIConversationFieldRefs {
    readonly id: FieldRef<"AIConversation", 'String'>
    readonly userId: FieldRef<"AIConversation", 'String'>
    readonly messages: FieldRef<"AIConversation", 'Json'>
    readonly context: FieldRef<"AIConversation", 'Json'>
    readonly createdAt: FieldRef<"AIConversation", 'DateTime'>
    readonly updatedAt: FieldRef<"AIConversation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AIConversation findUnique
   */
  export type AIConversationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIConversation
     */
    select?: AIConversationSelect<ExtArgs> | null
    /**
     * Filter, which AIConversation to fetch.
     */
    where: AIConversationWhereUniqueInput
  }

  /**
   * AIConversation findUniqueOrThrow
   */
  export type AIConversationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIConversation
     */
    select?: AIConversationSelect<ExtArgs> | null
    /**
     * Filter, which AIConversation to fetch.
     */
    where: AIConversationWhereUniqueInput
  }

  /**
   * AIConversation findFirst
   */
  export type AIConversationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIConversation
     */
    select?: AIConversationSelect<ExtArgs> | null
    /**
     * Filter, which AIConversation to fetch.
     */
    where?: AIConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIConversations to fetch.
     */
    orderBy?: AIConversationOrderByWithRelationInput | AIConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIConversations.
     */
    cursor?: AIConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIConversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIConversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIConversations.
     */
    distinct?: AIConversationScalarFieldEnum | AIConversationScalarFieldEnum[]
  }

  /**
   * AIConversation findFirstOrThrow
   */
  export type AIConversationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIConversation
     */
    select?: AIConversationSelect<ExtArgs> | null
    /**
     * Filter, which AIConversation to fetch.
     */
    where?: AIConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIConversations to fetch.
     */
    orderBy?: AIConversationOrderByWithRelationInput | AIConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIConversations.
     */
    cursor?: AIConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIConversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIConversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIConversations.
     */
    distinct?: AIConversationScalarFieldEnum | AIConversationScalarFieldEnum[]
  }

  /**
   * AIConversation findMany
   */
  export type AIConversationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIConversation
     */
    select?: AIConversationSelect<ExtArgs> | null
    /**
     * Filter, which AIConversations to fetch.
     */
    where?: AIConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIConversations to fetch.
     */
    orderBy?: AIConversationOrderByWithRelationInput | AIConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AIConversations.
     */
    cursor?: AIConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIConversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIConversations.
     */
    skip?: number
    distinct?: AIConversationScalarFieldEnum | AIConversationScalarFieldEnum[]
  }

  /**
   * AIConversation create
   */
  export type AIConversationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIConversation
     */
    select?: AIConversationSelect<ExtArgs> | null
    /**
     * The data needed to create a AIConversation.
     */
    data: XOR<AIConversationCreateInput, AIConversationUncheckedCreateInput>
  }

  /**
   * AIConversation createMany
   */
  export type AIConversationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AIConversations.
     */
    data: AIConversationCreateManyInput | AIConversationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AIConversation createManyAndReturn
   */
  export type AIConversationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIConversation
     */
    select?: AIConversationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AIConversations.
     */
    data: AIConversationCreateManyInput | AIConversationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AIConversation update
   */
  export type AIConversationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIConversation
     */
    select?: AIConversationSelect<ExtArgs> | null
    /**
     * The data needed to update a AIConversation.
     */
    data: XOR<AIConversationUpdateInput, AIConversationUncheckedUpdateInput>
    /**
     * Choose, which AIConversation to update.
     */
    where: AIConversationWhereUniqueInput
  }

  /**
   * AIConversation updateMany
   */
  export type AIConversationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AIConversations.
     */
    data: XOR<AIConversationUpdateManyMutationInput, AIConversationUncheckedUpdateManyInput>
    /**
     * Filter which AIConversations to update
     */
    where?: AIConversationWhereInput
  }

  /**
   * AIConversation upsert
   */
  export type AIConversationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIConversation
     */
    select?: AIConversationSelect<ExtArgs> | null
    /**
     * The filter to search for the AIConversation to update in case it exists.
     */
    where: AIConversationWhereUniqueInput
    /**
     * In case the AIConversation found by the `where` argument doesn't exist, create a new AIConversation with this data.
     */
    create: XOR<AIConversationCreateInput, AIConversationUncheckedCreateInput>
    /**
     * In case the AIConversation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AIConversationUpdateInput, AIConversationUncheckedUpdateInput>
  }

  /**
   * AIConversation delete
   */
  export type AIConversationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIConversation
     */
    select?: AIConversationSelect<ExtArgs> | null
    /**
     * Filter which AIConversation to delete.
     */
    where: AIConversationWhereUniqueInput
  }

  /**
   * AIConversation deleteMany
   */
  export type AIConversationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIConversations to delete
     */
    where?: AIConversationWhereInput
  }

  /**
   * AIConversation without action
   */
  export type AIConversationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIConversation
     */
    select?: AIConversationSelect<ExtArgs> | null
  }


  /**
   * Model MatrimonialProfile
   */

  export type AggregateMatrimonialProfile = {
    _count: MatrimonialProfileCountAggregateOutputType | null
    _avg: MatrimonialProfileAvgAggregateOutputType | null
    _sum: MatrimonialProfileSumAggregateOutputType | null
    _min: MatrimonialProfileMinAggregateOutputType | null
    _max: MatrimonialProfileMaxAggregateOutputType | null
  }

  export type MatrimonialProfileAvgAggregateOutputType = {
    age: number | null
    compatibilityScore: number | null
  }

  export type MatrimonialProfileSumAggregateOutputType = {
    age: number | null
    compatibilityScore: number | null
  }

  export type MatrimonialProfileMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    phone: string | null
    gender: $Enums.Gender | null
    dateOfBirth: Date | null
    age: number | null
    city: string | null
    profession: string | null
    education: string | null
    religion: string | null
    height: string | null
    bio: string | null
    familyBackground: string | null
    partnerPreferences: string | null
    isVerified: boolean | null
    isOnline: boolean | null
    lastSeen: Date | null
    compatibilityScore: number | null
    isInterested: boolean | null
    isMatched: boolean | null
    isBlocked: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MatrimonialProfileMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    phone: string | null
    gender: $Enums.Gender | null
    dateOfBirth: Date | null
    age: number | null
    city: string | null
    profession: string | null
    education: string | null
    religion: string | null
    height: string | null
    bio: string | null
    familyBackground: string | null
    partnerPreferences: string | null
    isVerified: boolean | null
    isOnline: boolean | null
    lastSeen: Date | null
    compatibilityScore: number | null
    isInterested: boolean | null
    isMatched: boolean | null
    isBlocked: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MatrimonialProfileCountAggregateOutputType = {
    id: number
    name: number
    email: number
    phone: number
    gender: number
    dateOfBirth: number
    age: number
    city: number
    profession: number
    education: number
    religion: number
    height: number
    bio: number
    interests: number
    photos: number
    familyBackground: number
    partnerPreferences: number
    isVerified: number
    isOnline: number
    lastSeen: number
    compatibilityScore: number
    isInterested: number
    isMatched: number
    isBlocked: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MatrimonialProfileAvgAggregateInputType = {
    age?: true
    compatibilityScore?: true
  }

  export type MatrimonialProfileSumAggregateInputType = {
    age?: true
    compatibilityScore?: true
  }

  export type MatrimonialProfileMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    gender?: true
    dateOfBirth?: true
    age?: true
    city?: true
    profession?: true
    education?: true
    religion?: true
    height?: true
    bio?: true
    familyBackground?: true
    partnerPreferences?: true
    isVerified?: true
    isOnline?: true
    lastSeen?: true
    compatibilityScore?: true
    isInterested?: true
    isMatched?: true
    isBlocked?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MatrimonialProfileMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    gender?: true
    dateOfBirth?: true
    age?: true
    city?: true
    profession?: true
    education?: true
    religion?: true
    height?: true
    bio?: true
    familyBackground?: true
    partnerPreferences?: true
    isVerified?: true
    isOnline?: true
    lastSeen?: true
    compatibilityScore?: true
    isInterested?: true
    isMatched?: true
    isBlocked?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MatrimonialProfileCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    gender?: true
    dateOfBirth?: true
    age?: true
    city?: true
    profession?: true
    education?: true
    religion?: true
    height?: true
    bio?: true
    interests?: true
    photos?: true
    familyBackground?: true
    partnerPreferences?: true
    isVerified?: true
    isOnline?: true
    lastSeen?: true
    compatibilityScore?: true
    isInterested?: true
    isMatched?: true
    isBlocked?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MatrimonialProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MatrimonialProfile to aggregate.
     */
    where?: MatrimonialProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatrimonialProfiles to fetch.
     */
    orderBy?: MatrimonialProfileOrderByWithRelationInput | MatrimonialProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MatrimonialProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatrimonialProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatrimonialProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MatrimonialProfiles
    **/
    _count?: true | MatrimonialProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MatrimonialProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MatrimonialProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MatrimonialProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MatrimonialProfileMaxAggregateInputType
  }

  export type GetMatrimonialProfileAggregateType<T extends MatrimonialProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateMatrimonialProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMatrimonialProfile[P]>
      : GetScalarType<T[P], AggregateMatrimonialProfile[P]>
  }




  export type MatrimonialProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatrimonialProfileWhereInput
    orderBy?: MatrimonialProfileOrderByWithAggregationInput | MatrimonialProfileOrderByWithAggregationInput[]
    by: MatrimonialProfileScalarFieldEnum[] | MatrimonialProfileScalarFieldEnum
    having?: MatrimonialProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MatrimonialProfileCountAggregateInputType | true
    _avg?: MatrimonialProfileAvgAggregateInputType
    _sum?: MatrimonialProfileSumAggregateInputType
    _min?: MatrimonialProfileMinAggregateInputType
    _max?: MatrimonialProfileMaxAggregateInputType
  }

  export type MatrimonialProfileGroupByOutputType = {
    id: string
    name: string
    email: string
    phone: string | null
    gender: $Enums.Gender
    dateOfBirth: Date | null
    age: number | null
    city: string
    profession: string
    education: string
    religion: string
    height: string | null
    bio: string | null
    interests: string[]
    photos: string[]
    familyBackground: string | null
    partnerPreferences: string | null
    isVerified: boolean
    isOnline: boolean
    lastSeen: Date | null
    compatibilityScore: number
    isInterested: boolean
    isMatched: boolean
    isBlocked: boolean
    createdAt: Date
    updatedAt: Date
    _count: MatrimonialProfileCountAggregateOutputType | null
    _avg: MatrimonialProfileAvgAggregateOutputType | null
    _sum: MatrimonialProfileSumAggregateOutputType | null
    _min: MatrimonialProfileMinAggregateOutputType | null
    _max: MatrimonialProfileMaxAggregateOutputType | null
  }

  type GetMatrimonialProfileGroupByPayload<T extends MatrimonialProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MatrimonialProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MatrimonialProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MatrimonialProfileGroupByOutputType[P]>
            : GetScalarType<T[P], MatrimonialProfileGroupByOutputType[P]>
        }
      >
    >


  export type MatrimonialProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    gender?: boolean
    dateOfBirth?: boolean
    age?: boolean
    city?: boolean
    profession?: boolean
    education?: boolean
    religion?: boolean
    height?: boolean
    bio?: boolean
    interests?: boolean
    photos?: boolean
    familyBackground?: boolean
    partnerPreferences?: boolean
    isVerified?: boolean
    isOnline?: boolean
    lastSeen?: boolean
    compatibilityScore?: boolean
    isInterested?: boolean
    isMatched?: boolean
    isBlocked?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sentMessages?: boolean | MatrimonialProfile$sentMessagesArgs<ExtArgs>
    receivedMessages?: boolean | MatrimonialProfile$receivedMessagesArgs<ExtArgs>
    _count?: boolean | MatrimonialProfileCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["matrimonialProfile"]>

  export type MatrimonialProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    gender?: boolean
    dateOfBirth?: boolean
    age?: boolean
    city?: boolean
    profession?: boolean
    education?: boolean
    religion?: boolean
    height?: boolean
    bio?: boolean
    interests?: boolean
    photos?: boolean
    familyBackground?: boolean
    partnerPreferences?: boolean
    isVerified?: boolean
    isOnline?: boolean
    lastSeen?: boolean
    compatibilityScore?: boolean
    isInterested?: boolean
    isMatched?: boolean
    isBlocked?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["matrimonialProfile"]>

  export type MatrimonialProfileSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    gender?: boolean
    dateOfBirth?: boolean
    age?: boolean
    city?: boolean
    profession?: boolean
    education?: boolean
    religion?: boolean
    height?: boolean
    bio?: boolean
    interests?: boolean
    photos?: boolean
    familyBackground?: boolean
    partnerPreferences?: boolean
    isVerified?: boolean
    isOnline?: boolean
    lastSeen?: boolean
    compatibilityScore?: boolean
    isInterested?: boolean
    isMatched?: boolean
    isBlocked?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MatrimonialProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sentMessages?: boolean | MatrimonialProfile$sentMessagesArgs<ExtArgs>
    receivedMessages?: boolean | MatrimonialProfile$receivedMessagesArgs<ExtArgs>
    _count?: boolean | MatrimonialProfileCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MatrimonialProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $MatrimonialProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MatrimonialProfile"
    objects: {
      sentMessages: Prisma.$MatrimonialMessagePayload<ExtArgs>[]
      receivedMessages: Prisma.$MatrimonialMessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      phone: string | null
      gender: $Enums.Gender
      dateOfBirth: Date | null
      age: number | null
      city: string
      profession: string
      education: string
      religion: string
      height: string | null
      bio: string | null
      interests: string[]
      photos: string[]
      familyBackground: string | null
      partnerPreferences: string | null
      isVerified: boolean
      isOnline: boolean
      lastSeen: Date | null
      compatibilityScore: number
      isInterested: boolean
      isMatched: boolean
      isBlocked: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["matrimonialProfile"]>
    composites: {}
  }

  type MatrimonialProfileGetPayload<S extends boolean | null | undefined | MatrimonialProfileDefaultArgs> = $Result.GetResult<Prisma.$MatrimonialProfilePayload, S>

  type MatrimonialProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MatrimonialProfileFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MatrimonialProfileCountAggregateInputType | true
    }

  export interface MatrimonialProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MatrimonialProfile'], meta: { name: 'MatrimonialProfile' } }
    /**
     * Find zero or one MatrimonialProfile that matches the filter.
     * @param {MatrimonialProfileFindUniqueArgs} args - Arguments to find a MatrimonialProfile
     * @example
     * // Get one MatrimonialProfile
     * const matrimonialProfile = await prisma.matrimonialProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MatrimonialProfileFindUniqueArgs>(args: SelectSubset<T, MatrimonialProfileFindUniqueArgs<ExtArgs>>): Prisma__MatrimonialProfileClient<$Result.GetResult<Prisma.$MatrimonialProfilePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MatrimonialProfile that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MatrimonialProfileFindUniqueOrThrowArgs} args - Arguments to find a MatrimonialProfile
     * @example
     * // Get one MatrimonialProfile
     * const matrimonialProfile = await prisma.matrimonialProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MatrimonialProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, MatrimonialProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MatrimonialProfileClient<$Result.GetResult<Prisma.$MatrimonialProfilePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MatrimonialProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatrimonialProfileFindFirstArgs} args - Arguments to find a MatrimonialProfile
     * @example
     * // Get one MatrimonialProfile
     * const matrimonialProfile = await prisma.matrimonialProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MatrimonialProfileFindFirstArgs>(args?: SelectSubset<T, MatrimonialProfileFindFirstArgs<ExtArgs>>): Prisma__MatrimonialProfileClient<$Result.GetResult<Prisma.$MatrimonialProfilePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MatrimonialProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatrimonialProfileFindFirstOrThrowArgs} args - Arguments to find a MatrimonialProfile
     * @example
     * // Get one MatrimonialProfile
     * const matrimonialProfile = await prisma.matrimonialProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MatrimonialProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, MatrimonialProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__MatrimonialProfileClient<$Result.GetResult<Prisma.$MatrimonialProfilePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MatrimonialProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatrimonialProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MatrimonialProfiles
     * const matrimonialProfiles = await prisma.matrimonialProfile.findMany()
     * 
     * // Get first 10 MatrimonialProfiles
     * const matrimonialProfiles = await prisma.matrimonialProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const matrimonialProfileWithIdOnly = await prisma.matrimonialProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MatrimonialProfileFindManyArgs>(args?: SelectSubset<T, MatrimonialProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatrimonialProfilePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MatrimonialProfile.
     * @param {MatrimonialProfileCreateArgs} args - Arguments to create a MatrimonialProfile.
     * @example
     * // Create one MatrimonialProfile
     * const MatrimonialProfile = await prisma.matrimonialProfile.create({
     *   data: {
     *     // ... data to create a MatrimonialProfile
     *   }
     * })
     * 
     */
    create<T extends MatrimonialProfileCreateArgs>(args: SelectSubset<T, MatrimonialProfileCreateArgs<ExtArgs>>): Prisma__MatrimonialProfileClient<$Result.GetResult<Prisma.$MatrimonialProfilePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MatrimonialProfiles.
     * @param {MatrimonialProfileCreateManyArgs} args - Arguments to create many MatrimonialProfiles.
     * @example
     * // Create many MatrimonialProfiles
     * const matrimonialProfile = await prisma.matrimonialProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MatrimonialProfileCreateManyArgs>(args?: SelectSubset<T, MatrimonialProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MatrimonialProfiles and returns the data saved in the database.
     * @param {MatrimonialProfileCreateManyAndReturnArgs} args - Arguments to create many MatrimonialProfiles.
     * @example
     * // Create many MatrimonialProfiles
     * const matrimonialProfile = await prisma.matrimonialProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MatrimonialProfiles and only return the `id`
     * const matrimonialProfileWithIdOnly = await prisma.matrimonialProfile.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MatrimonialProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, MatrimonialProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatrimonialProfilePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MatrimonialProfile.
     * @param {MatrimonialProfileDeleteArgs} args - Arguments to delete one MatrimonialProfile.
     * @example
     * // Delete one MatrimonialProfile
     * const MatrimonialProfile = await prisma.matrimonialProfile.delete({
     *   where: {
     *     // ... filter to delete one MatrimonialProfile
     *   }
     * })
     * 
     */
    delete<T extends MatrimonialProfileDeleteArgs>(args: SelectSubset<T, MatrimonialProfileDeleteArgs<ExtArgs>>): Prisma__MatrimonialProfileClient<$Result.GetResult<Prisma.$MatrimonialProfilePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MatrimonialProfile.
     * @param {MatrimonialProfileUpdateArgs} args - Arguments to update one MatrimonialProfile.
     * @example
     * // Update one MatrimonialProfile
     * const matrimonialProfile = await prisma.matrimonialProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MatrimonialProfileUpdateArgs>(args: SelectSubset<T, MatrimonialProfileUpdateArgs<ExtArgs>>): Prisma__MatrimonialProfileClient<$Result.GetResult<Prisma.$MatrimonialProfilePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MatrimonialProfiles.
     * @param {MatrimonialProfileDeleteManyArgs} args - Arguments to filter MatrimonialProfiles to delete.
     * @example
     * // Delete a few MatrimonialProfiles
     * const { count } = await prisma.matrimonialProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MatrimonialProfileDeleteManyArgs>(args?: SelectSubset<T, MatrimonialProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MatrimonialProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatrimonialProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MatrimonialProfiles
     * const matrimonialProfile = await prisma.matrimonialProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MatrimonialProfileUpdateManyArgs>(args: SelectSubset<T, MatrimonialProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MatrimonialProfile.
     * @param {MatrimonialProfileUpsertArgs} args - Arguments to update or create a MatrimonialProfile.
     * @example
     * // Update or create a MatrimonialProfile
     * const matrimonialProfile = await prisma.matrimonialProfile.upsert({
     *   create: {
     *     // ... data to create a MatrimonialProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MatrimonialProfile we want to update
     *   }
     * })
     */
    upsert<T extends MatrimonialProfileUpsertArgs>(args: SelectSubset<T, MatrimonialProfileUpsertArgs<ExtArgs>>): Prisma__MatrimonialProfileClient<$Result.GetResult<Prisma.$MatrimonialProfilePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MatrimonialProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatrimonialProfileCountArgs} args - Arguments to filter MatrimonialProfiles to count.
     * @example
     * // Count the number of MatrimonialProfiles
     * const count = await prisma.matrimonialProfile.count({
     *   where: {
     *     // ... the filter for the MatrimonialProfiles we want to count
     *   }
     * })
    **/
    count<T extends MatrimonialProfileCountArgs>(
      args?: Subset<T, MatrimonialProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MatrimonialProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MatrimonialProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatrimonialProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MatrimonialProfileAggregateArgs>(args: Subset<T, MatrimonialProfileAggregateArgs>): Prisma.PrismaPromise<GetMatrimonialProfileAggregateType<T>>

    /**
     * Group by MatrimonialProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatrimonialProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MatrimonialProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MatrimonialProfileGroupByArgs['orderBy'] }
        : { orderBy?: MatrimonialProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MatrimonialProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMatrimonialProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MatrimonialProfile model
   */
  readonly fields: MatrimonialProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MatrimonialProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MatrimonialProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sentMessages<T extends MatrimonialProfile$sentMessagesArgs<ExtArgs> = {}>(args?: Subset<T, MatrimonialProfile$sentMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatrimonialMessagePayload<ExtArgs>, T, "findMany"> | Null>
    receivedMessages<T extends MatrimonialProfile$receivedMessagesArgs<ExtArgs> = {}>(args?: Subset<T, MatrimonialProfile$receivedMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatrimonialMessagePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MatrimonialProfile model
   */ 
  interface MatrimonialProfileFieldRefs {
    readonly id: FieldRef<"MatrimonialProfile", 'String'>
    readonly name: FieldRef<"MatrimonialProfile", 'String'>
    readonly email: FieldRef<"MatrimonialProfile", 'String'>
    readonly phone: FieldRef<"MatrimonialProfile", 'String'>
    readonly gender: FieldRef<"MatrimonialProfile", 'Gender'>
    readonly dateOfBirth: FieldRef<"MatrimonialProfile", 'DateTime'>
    readonly age: FieldRef<"MatrimonialProfile", 'Int'>
    readonly city: FieldRef<"MatrimonialProfile", 'String'>
    readonly profession: FieldRef<"MatrimonialProfile", 'String'>
    readonly education: FieldRef<"MatrimonialProfile", 'String'>
    readonly religion: FieldRef<"MatrimonialProfile", 'String'>
    readonly height: FieldRef<"MatrimonialProfile", 'String'>
    readonly bio: FieldRef<"MatrimonialProfile", 'String'>
    readonly interests: FieldRef<"MatrimonialProfile", 'String[]'>
    readonly photos: FieldRef<"MatrimonialProfile", 'String[]'>
    readonly familyBackground: FieldRef<"MatrimonialProfile", 'String'>
    readonly partnerPreferences: FieldRef<"MatrimonialProfile", 'String'>
    readonly isVerified: FieldRef<"MatrimonialProfile", 'Boolean'>
    readonly isOnline: FieldRef<"MatrimonialProfile", 'Boolean'>
    readonly lastSeen: FieldRef<"MatrimonialProfile", 'DateTime'>
    readonly compatibilityScore: FieldRef<"MatrimonialProfile", 'Int'>
    readonly isInterested: FieldRef<"MatrimonialProfile", 'Boolean'>
    readonly isMatched: FieldRef<"MatrimonialProfile", 'Boolean'>
    readonly isBlocked: FieldRef<"MatrimonialProfile", 'Boolean'>
    readonly createdAt: FieldRef<"MatrimonialProfile", 'DateTime'>
    readonly updatedAt: FieldRef<"MatrimonialProfile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MatrimonialProfile findUnique
   */
  export type MatrimonialProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatrimonialProfile
     */
    select?: MatrimonialProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatrimonialProfileInclude<ExtArgs> | null
    /**
     * Filter, which MatrimonialProfile to fetch.
     */
    where: MatrimonialProfileWhereUniqueInput
  }

  /**
   * MatrimonialProfile findUniqueOrThrow
   */
  export type MatrimonialProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatrimonialProfile
     */
    select?: MatrimonialProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatrimonialProfileInclude<ExtArgs> | null
    /**
     * Filter, which MatrimonialProfile to fetch.
     */
    where: MatrimonialProfileWhereUniqueInput
  }

  /**
   * MatrimonialProfile findFirst
   */
  export type MatrimonialProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatrimonialProfile
     */
    select?: MatrimonialProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatrimonialProfileInclude<ExtArgs> | null
    /**
     * Filter, which MatrimonialProfile to fetch.
     */
    where?: MatrimonialProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatrimonialProfiles to fetch.
     */
    orderBy?: MatrimonialProfileOrderByWithRelationInput | MatrimonialProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MatrimonialProfiles.
     */
    cursor?: MatrimonialProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatrimonialProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatrimonialProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MatrimonialProfiles.
     */
    distinct?: MatrimonialProfileScalarFieldEnum | MatrimonialProfileScalarFieldEnum[]
  }

  /**
   * MatrimonialProfile findFirstOrThrow
   */
  export type MatrimonialProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatrimonialProfile
     */
    select?: MatrimonialProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatrimonialProfileInclude<ExtArgs> | null
    /**
     * Filter, which MatrimonialProfile to fetch.
     */
    where?: MatrimonialProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatrimonialProfiles to fetch.
     */
    orderBy?: MatrimonialProfileOrderByWithRelationInput | MatrimonialProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MatrimonialProfiles.
     */
    cursor?: MatrimonialProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatrimonialProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatrimonialProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MatrimonialProfiles.
     */
    distinct?: MatrimonialProfileScalarFieldEnum | MatrimonialProfileScalarFieldEnum[]
  }

  /**
   * MatrimonialProfile findMany
   */
  export type MatrimonialProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatrimonialProfile
     */
    select?: MatrimonialProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatrimonialProfileInclude<ExtArgs> | null
    /**
     * Filter, which MatrimonialProfiles to fetch.
     */
    where?: MatrimonialProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatrimonialProfiles to fetch.
     */
    orderBy?: MatrimonialProfileOrderByWithRelationInput | MatrimonialProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MatrimonialProfiles.
     */
    cursor?: MatrimonialProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatrimonialProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatrimonialProfiles.
     */
    skip?: number
    distinct?: MatrimonialProfileScalarFieldEnum | MatrimonialProfileScalarFieldEnum[]
  }

  /**
   * MatrimonialProfile create
   */
  export type MatrimonialProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatrimonialProfile
     */
    select?: MatrimonialProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatrimonialProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a MatrimonialProfile.
     */
    data: XOR<MatrimonialProfileCreateInput, MatrimonialProfileUncheckedCreateInput>
  }

  /**
   * MatrimonialProfile createMany
   */
  export type MatrimonialProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MatrimonialProfiles.
     */
    data: MatrimonialProfileCreateManyInput | MatrimonialProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MatrimonialProfile createManyAndReturn
   */
  export type MatrimonialProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatrimonialProfile
     */
    select?: MatrimonialProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MatrimonialProfiles.
     */
    data: MatrimonialProfileCreateManyInput | MatrimonialProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MatrimonialProfile update
   */
  export type MatrimonialProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatrimonialProfile
     */
    select?: MatrimonialProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatrimonialProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a MatrimonialProfile.
     */
    data: XOR<MatrimonialProfileUpdateInput, MatrimonialProfileUncheckedUpdateInput>
    /**
     * Choose, which MatrimonialProfile to update.
     */
    where: MatrimonialProfileWhereUniqueInput
  }

  /**
   * MatrimonialProfile updateMany
   */
  export type MatrimonialProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MatrimonialProfiles.
     */
    data: XOR<MatrimonialProfileUpdateManyMutationInput, MatrimonialProfileUncheckedUpdateManyInput>
    /**
     * Filter which MatrimonialProfiles to update
     */
    where?: MatrimonialProfileWhereInput
  }

  /**
   * MatrimonialProfile upsert
   */
  export type MatrimonialProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatrimonialProfile
     */
    select?: MatrimonialProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatrimonialProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the MatrimonialProfile to update in case it exists.
     */
    where: MatrimonialProfileWhereUniqueInput
    /**
     * In case the MatrimonialProfile found by the `where` argument doesn't exist, create a new MatrimonialProfile with this data.
     */
    create: XOR<MatrimonialProfileCreateInput, MatrimonialProfileUncheckedCreateInput>
    /**
     * In case the MatrimonialProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MatrimonialProfileUpdateInput, MatrimonialProfileUncheckedUpdateInput>
  }

  /**
   * MatrimonialProfile delete
   */
  export type MatrimonialProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatrimonialProfile
     */
    select?: MatrimonialProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatrimonialProfileInclude<ExtArgs> | null
    /**
     * Filter which MatrimonialProfile to delete.
     */
    where: MatrimonialProfileWhereUniqueInput
  }

  /**
   * MatrimonialProfile deleteMany
   */
  export type MatrimonialProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MatrimonialProfiles to delete
     */
    where?: MatrimonialProfileWhereInput
  }

  /**
   * MatrimonialProfile.sentMessages
   */
  export type MatrimonialProfile$sentMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatrimonialMessage
     */
    select?: MatrimonialMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatrimonialMessageInclude<ExtArgs> | null
    where?: MatrimonialMessageWhereInput
    orderBy?: MatrimonialMessageOrderByWithRelationInput | MatrimonialMessageOrderByWithRelationInput[]
    cursor?: MatrimonialMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MatrimonialMessageScalarFieldEnum | MatrimonialMessageScalarFieldEnum[]
  }

  /**
   * MatrimonialProfile.receivedMessages
   */
  export type MatrimonialProfile$receivedMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatrimonialMessage
     */
    select?: MatrimonialMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatrimonialMessageInclude<ExtArgs> | null
    where?: MatrimonialMessageWhereInput
    orderBy?: MatrimonialMessageOrderByWithRelationInput | MatrimonialMessageOrderByWithRelationInput[]
    cursor?: MatrimonialMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MatrimonialMessageScalarFieldEnum | MatrimonialMessageScalarFieldEnum[]
  }

  /**
   * MatrimonialProfile without action
   */
  export type MatrimonialProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatrimonialProfile
     */
    select?: MatrimonialProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatrimonialProfileInclude<ExtArgs> | null
  }


  /**
   * Model MatrimonialMessage
   */

  export type AggregateMatrimonialMessage = {
    _count: MatrimonialMessageCountAggregateOutputType | null
    _min: MatrimonialMessageMinAggregateOutputType | null
    _max: MatrimonialMessageMaxAggregateOutputType | null
  }

  export type MatrimonialMessageMinAggregateOutputType = {
    id: string | null
    fromProfileId: string | null
    toProfileId: string | null
    content: string | null
    createdAt: Date | null
  }

  export type MatrimonialMessageMaxAggregateOutputType = {
    id: string | null
    fromProfileId: string | null
    toProfileId: string | null
    content: string | null
    createdAt: Date | null
  }

  export type MatrimonialMessageCountAggregateOutputType = {
    id: number
    fromProfileId: number
    toProfileId: number
    content: number
    createdAt: number
    _all: number
  }


  export type MatrimonialMessageMinAggregateInputType = {
    id?: true
    fromProfileId?: true
    toProfileId?: true
    content?: true
    createdAt?: true
  }

  export type MatrimonialMessageMaxAggregateInputType = {
    id?: true
    fromProfileId?: true
    toProfileId?: true
    content?: true
    createdAt?: true
  }

  export type MatrimonialMessageCountAggregateInputType = {
    id?: true
    fromProfileId?: true
    toProfileId?: true
    content?: true
    createdAt?: true
    _all?: true
  }

  export type MatrimonialMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MatrimonialMessage to aggregate.
     */
    where?: MatrimonialMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatrimonialMessages to fetch.
     */
    orderBy?: MatrimonialMessageOrderByWithRelationInput | MatrimonialMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MatrimonialMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatrimonialMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatrimonialMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MatrimonialMessages
    **/
    _count?: true | MatrimonialMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MatrimonialMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MatrimonialMessageMaxAggregateInputType
  }

  export type GetMatrimonialMessageAggregateType<T extends MatrimonialMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMatrimonialMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMatrimonialMessage[P]>
      : GetScalarType<T[P], AggregateMatrimonialMessage[P]>
  }




  export type MatrimonialMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatrimonialMessageWhereInput
    orderBy?: MatrimonialMessageOrderByWithAggregationInput | MatrimonialMessageOrderByWithAggregationInput[]
    by: MatrimonialMessageScalarFieldEnum[] | MatrimonialMessageScalarFieldEnum
    having?: MatrimonialMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MatrimonialMessageCountAggregateInputType | true
    _min?: MatrimonialMessageMinAggregateInputType
    _max?: MatrimonialMessageMaxAggregateInputType
  }

  export type MatrimonialMessageGroupByOutputType = {
    id: string
    fromProfileId: string
    toProfileId: string
    content: string
    createdAt: Date
    _count: MatrimonialMessageCountAggregateOutputType | null
    _min: MatrimonialMessageMinAggregateOutputType | null
    _max: MatrimonialMessageMaxAggregateOutputType | null
  }

  type GetMatrimonialMessageGroupByPayload<T extends MatrimonialMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MatrimonialMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MatrimonialMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MatrimonialMessageGroupByOutputType[P]>
            : GetScalarType<T[P], MatrimonialMessageGroupByOutputType[P]>
        }
      >
    >


  export type MatrimonialMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fromProfileId?: boolean
    toProfileId?: boolean
    content?: boolean
    createdAt?: boolean
    fromProfile?: boolean | MatrimonialProfileDefaultArgs<ExtArgs>
    toProfile?: boolean | MatrimonialProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["matrimonialMessage"]>

  export type MatrimonialMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fromProfileId?: boolean
    toProfileId?: boolean
    content?: boolean
    createdAt?: boolean
    fromProfile?: boolean | MatrimonialProfileDefaultArgs<ExtArgs>
    toProfile?: boolean | MatrimonialProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["matrimonialMessage"]>

  export type MatrimonialMessageSelectScalar = {
    id?: boolean
    fromProfileId?: boolean
    toProfileId?: boolean
    content?: boolean
    createdAt?: boolean
  }

  export type MatrimonialMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fromProfile?: boolean | MatrimonialProfileDefaultArgs<ExtArgs>
    toProfile?: boolean | MatrimonialProfileDefaultArgs<ExtArgs>
  }
  export type MatrimonialMessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fromProfile?: boolean | MatrimonialProfileDefaultArgs<ExtArgs>
    toProfile?: boolean | MatrimonialProfileDefaultArgs<ExtArgs>
  }

  export type $MatrimonialMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MatrimonialMessage"
    objects: {
      fromProfile: Prisma.$MatrimonialProfilePayload<ExtArgs>
      toProfile: Prisma.$MatrimonialProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      fromProfileId: string
      toProfileId: string
      content: string
      createdAt: Date
    }, ExtArgs["result"]["matrimonialMessage"]>
    composites: {}
  }

  type MatrimonialMessageGetPayload<S extends boolean | null | undefined | MatrimonialMessageDefaultArgs> = $Result.GetResult<Prisma.$MatrimonialMessagePayload, S>

  type MatrimonialMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MatrimonialMessageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MatrimonialMessageCountAggregateInputType | true
    }

  export interface MatrimonialMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MatrimonialMessage'], meta: { name: 'MatrimonialMessage' } }
    /**
     * Find zero or one MatrimonialMessage that matches the filter.
     * @param {MatrimonialMessageFindUniqueArgs} args - Arguments to find a MatrimonialMessage
     * @example
     * // Get one MatrimonialMessage
     * const matrimonialMessage = await prisma.matrimonialMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MatrimonialMessageFindUniqueArgs>(args: SelectSubset<T, MatrimonialMessageFindUniqueArgs<ExtArgs>>): Prisma__MatrimonialMessageClient<$Result.GetResult<Prisma.$MatrimonialMessagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MatrimonialMessage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MatrimonialMessageFindUniqueOrThrowArgs} args - Arguments to find a MatrimonialMessage
     * @example
     * // Get one MatrimonialMessage
     * const matrimonialMessage = await prisma.matrimonialMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MatrimonialMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, MatrimonialMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MatrimonialMessageClient<$Result.GetResult<Prisma.$MatrimonialMessagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MatrimonialMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatrimonialMessageFindFirstArgs} args - Arguments to find a MatrimonialMessage
     * @example
     * // Get one MatrimonialMessage
     * const matrimonialMessage = await prisma.matrimonialMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MatrimonialMessageFindFirstArgs>(args?: SelectSubset<T, MatrimonialMessageFindFirstArgs<ExtArgs>>): Prisma__MatrimonialMessageClient<$Result.GetResult<Prisma.$MatrimonialMessagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MatrimonialMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatrimonialMessageFindFirstOrThrowArgs} args - Arguments to find a MatrimonialMessage
     * @example
     * // Get one MatrimonialMessage
     * const matrimonialMessage = await prisma.matrimonialMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MatrimonialMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, MatrimonialMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__MatrimonialMessageClient<$Result.GetResult<Prisma.$MatrimonialMessagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MatrimonialMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatrimonialMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MatrimonialMessages
     * const matrimonialMessages = await prisma.matrimonialMessage.findMany()
     * 
     * // Get first 10 MatrimonialMessages
     * const matrimonialMessages = await prisma.matrimonialMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const matrimonialMessageWithIdOnly = await prisma.matrimonialMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MatrimonialMessageFindManyArgs>(args?: SelectSubset<T, MatrimonialMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatrimonialMessagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MatrimonialMessage.
     * @param {MatrimonialMessageCreateArgs} args - Arguments to create a MatrimonialMessage.
     * @example
     * // Create one MatrimonialMessage
     * const MatrimonialMessage = await prisma.matrimonialMessage.create({
     *   data: {
     *     // ... data to create a MatrimonialMessage
     *   }
     * })
     * 
     */
    create<T extends MatrimonialMessageCreateArgs>(args: SelectSubset<T, MatrimonialMessageCreateArgs<ExtArgs>>): Prisma__MatrimonialMessageClient<$Result.GetResult<Prisma.$MatrimonialMessagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MatrimonialMessages.
     * @param {MatrimonialMessageCreateManyArgs} args - Arguments to create many MatrimonialMessages.
     * @example
     * // Create many MatrimonialMessages
     * const matrimonialMessage = await prisma.matrimonialMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MatrimonialMessageCreateManyArgs>(args?: SelectSubset<T, MatrimonialMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MatrimonialMessages and returns the data saved in the database.
     * @param {MatrimonialMessageCreateManyAndReturnArgs} args - Arguments to create many MatrimonialMessages.
     * @example
     * // Create many MatrimonialMessages
     * const matrimonialMessage = await prisma.matrimonialMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MatrimonialMessages and only return the `id`
     * const matrimonialMessageWithIdOnly = await prisma.matrimonialMessage.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MatrimonialMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, MatrimonialMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatrimonialMessagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MatrimonialMessage.
     * @param {MatrimonialMessageDeleteArgs} args - Arguments to delete one MatrimonialMessage.
     * @example
     * // Delete one MatrimonialMessage
     * const MatrimonialMessage = await prisma.matrimonialMessage.delete({
     *   where: {
     *     // ... filter to delete one MatrimonialMessage
     *   }
     * })
     * 
     */
    delete<T extends MatrimonialMessageDeleteArgs>(args: SelectSubset<T, MatrimonialMessageDeleteArgs<ExtArgs>>): Prisma__MatrimonialMessageClient<$Result.GetResult<Prisma.$MatrimonialMessagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MatrimonialMessage.
     * @param {MatrimonialMessageUpdateArgs} args - Arguments to update one MatrimonialMessage.
     * @example
     * // Update one MatrimonialMessage
     * const matrimonialMessage = await prisma.matrimonialMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MatrimonialMessageUpdateArgs>(args: SelectSubset<T, MatrimonialMessageUpdateArgs<ExtArgs>>): Prisma__MatrimonialMessageClient<$Result.GetResult<Prisma.$MatrimonialMessagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MatrimonialMessages.
     * @param {MatrimonialMessageDeleteManyArgs} args - Arguments to filter MatrimonialMessages to delete.
     * @example
     * // Delete a few MatrimonialMessages
     * const { count } = await prisma.matrimonialMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MatrimonialMessageDeleteManyArgs>(args?: SelectSubset<T, MatrimonialMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MatrimonialMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatrimonialMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MatrimonialMessages
     * const matrimonialMessage = await prisma.matrimonialMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MatrimonialMessageUpdateManyArgs>(args: SelectSubset<T, MatrimonialMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MatrimonialMessage.
     * @param {MatrimonialMessageUpsertArgs} args - Arguments to update or create a MatrimonialMessage.
     * @example
     * // Update or create a MatrimonialMessage
     * const matrimonialMessage = await prisma.matrimonialMessage.upsert({
     *   create: {
     *     // ... data to create a MatrimonialMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MatrimonialMessage we want to update
     *   }
     * })
     */
    upsert<T extends MatrimonialMessageUpsertArgs>(args: SelectSubset<T, MatrimonialMessageUpsertArgs<ExtArgs>>): Prisma__MatrimonialMessageClient<$Result.GetResult<Prisma.$MatrimonialMessagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MatrimonialMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatrimonialMessageCountArgs} args - Arguments to filter MatrimonialMessages to count.
     * @example
     * // Count the number of MatrimonialMessages
     * const count = await prisma.matrimonialMessage.count({
     *   where: {
     *     // ... the filter for the MatrimonialMessages we want to count
     *   }
     * })
    **/
    count<T extends MatrimonialMessageCountArgs>(
      args?: Subset<T, MatrimonialMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MatrimonialMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MatrimonialMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatrimonialMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MatrimonialMessageAggregateArgs>(args: Subset<T, MatrimonialMessageAggregateArgs>): Prisma.PrismaPromise<GetMatrimonialMessageAggregateType<T>>

    /**
     * Group by MatrimonialMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatrimonialMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MatrimonialMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MatrimonialMessageGroupByArgs['orderBy'] }
        : { orderBy?: MatrimonialMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MatrimonialMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMatrimonialMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MatrimonialMessage model
   */
  readonly fields: MatrimonialMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MatrimonialMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MatrimonialMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    fromProfile<T extends MatrimonialProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MatrimonialProfileDefaultArgs<ExtArgs>>): Prisma__MatrimonialProfileClient<$Result.GetResult<Prisma.$MatrimonialProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    toProfile<T extends MatrimonialProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MatrimonialProfileDefaultArgs<ExtArgs>>): Prisma__MatrimonialProfileClient<$Result.GetResult<Prisma.$MatrimonialProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MatrimonialMessage model
   */ 
  interface MatrimonialMessageFieldRefs {
    readonly id: FieldRef<"MatrimonialMessage", 'String'>
    readonly fromProfileId: FieldRef<"MatrimonialMessage", 'String'>
    readonly toProfileId: FieldRef<"MatrimonialMessage", 'String'>
    readonly content: FieldRef<"MatrimonialMessage", 'String'>
    readonly createdAt: FieldRef<"MatrimonialMessage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MatrimonialMessage findUnique
   */
  export type MatrimonialMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatrimonialMessage
     */
    select?: MatrimonialMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatrimonialMessageInclude<ExtArgs> | null
    /**
     * Filter, which MatrimonialMessage to fetch.
     */
    where: MatrimonialMessageWhereUniqueInput
  }

  /**
   * MatrimonialMessage findUniqueOrThrow
   */
  export type MatrimonialMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatrimonialMessage
     */
    select?: MatrimonialMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatrimonialMessageInclude<ExtArgs> | null
    /**
     * Filter, which MatrimonialMessage to fetch.
     */
    where: MatrimonialMessageWhereUniqueInput
  }

  /**
   * MatrimonialMessage findFirst
   */
  export type MatrimonialMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatrimonialMessage
     */
    select?: MatrimonialMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatrimonialMessageInclude<ExtArgs> | null
    /**
     * Filter, which MatrimonialMessage to fetch.
     */
    where?: MatrimonialMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatrimonialMessages to fetch.
     */
    orderBy?: MatrimonialMessageOrderByWithRelationInput | MatrimonialMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MatrimonialMessages.
     */
    cursor?: MatrimonialMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatrimonialMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatrimonialMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MatrimonialMessages.
     */
    distinct?: MatrimonialMessageScalarFieldEnum | MatrimonialMessageScalarFieldEnum[]
  }

  /**
   * MatrimonialMessage findFirstOrThrow
   */
  export type MatrimonialMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatrimonialMessage
     */
    select?: MatrimonialMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatrimonialMessageInclude<ExtArgs> | null
    /**
     * Filter, which MatrimonialMessage to fetch.
     */
    where?: MatrimonialMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatrimonialMessages to fetch.
     */
    orderBy?: MatrimonialMessageOrderByWithRelationInput | MatrimonialMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MatrimonialMessages.
     */
    cursor?: MatrimonialMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatrimonialMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatrimonialMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MatrimonialMessages.
     */
    distinct?: MatrimonialMessageScalarFieldEnum | MatrimonialMessageScalarFieldEnum[]
  }

  /**
   * MatrimonialMessage findMany
   */
  export type MatrimonialMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatrimonialMessage
     */
    select?: MatrimonialMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatrimonialMessageInclude<ExtArgs> | null
    /**
     * Filter, which MatrimonialMessages to fetch.
     */
    where?: MatrimonialMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatrimonialMessages to fetch.
     */
    orderBy?: MatrimonialMessageOrderByWithRelationInput | MatrimonialMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MatrimonialMessages.
     */
    cursor?: MatrimonialMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatrimonialMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatrimonialMessages.
     */
    skip?: number
    distinct?: MatrimonialMessageScalarFieldEnum | MatrimonialMessageScalarFieldEnum[]
  }

  /**
   * MatrimonialMessage create
   */
  export type MatrimonialMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatrimonialMessage
     */
    select?: MatrimonialMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatrimonialMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a MatrimonialMessage.
     */
    data: XOR<MatrimonialMessageCreateInput, MatrimonialMessageUncheckedCreateInput>
  }

  /**
   * MatrimonialMessage createMany
   */
  export type MatrimonialMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MatrimonialMessages.
     */
    data: MatrimonialMessageCreateManyInput | MatrimonialMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MatrimonialMessage createManyAndReturn
   */
  export type MatrimonialMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatrimonialMessage
     */
    select?: MatrimonialMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MatrimonialMessages.
     */
    data: MatrimonialMessageCreateManyInput | MatrimonialMessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatrimonialMessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MatrimonialMessage update
   */
  export type MatrimonialMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatrimonialMessage
     */
    select?: MatrimonialMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatrimonialMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a MatrimonialMessage.
     */
    data: XOR<MatrimonialMessageUpdateInput, MatrimonialMessageUncheckedUpdateInput>
    /**
     * Choose, which MatrimonialMessage to update.
     */
    where: MatrimonialMessageWhereUniqueInput
  }

  /**
   * MatrimonialMessage updateMany
   */
  export type MatrimonialMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MatrimonialMessages.
     */
    data: XOR<MatrimonialMessageUpdateManyMutationInput, MatrimonialMessageUncheckedUpdateManyInput>
    /**
     * Filter which MatrimonialMessages to update
     */
    where?: MatrimonialMessageWhereInput
  }

  /**
   * MatrimonialMessage upsert
   */
  export type MatrimonialMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatrimonialMessage
     */
    select?: MatrimonialMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatrimonialMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the MatrimonialMessage to update in case it exists.
     */
    where: MatrimonialMessageWhereUniqueInput
    /**
     * In case the MatrimonialMessage found by the `where` argument doesn't exist, create a new MatrimonialMessage with this data.
     */
    create: XOR<MatrimonialMessageCreateInput, MatrimonialMessageUncheckedCreateInput>
    /**
     * In case the MatrimonialMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MatrimonialMessageUpdateInput, MatrimonialMessageUncheckedUpdateInput>
  }

  /**
   * MatrimonialMessage delete
   */
  export type MatrimonialMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatrimonialMessage
     */
    select?: MatrimonialMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatrimonialMessageInclude<ExtArgs> | null
    /**
     * Filter which MatrimonialMessage to delete.
     */
    where: MatrimonialMessageWhereUniqueInput
  }

  /**
   * MatrimonialMessage deleteMany
   */
  export type MatrimonialMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MatrimonialMessages to delete
     */
    where?: MatrimonialMessageWhereInput
  }

  /**
   * MatrimonialMessage without action
   */
  export type MatrimonialMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatrimonialMessage
     */
    select?: MatrimonialMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatrimonialMessageInclude<ExtArgs> | null
  }


  /**
   * Model VendorVerificationDocument
   */

  export type AggregateVendorVerificationDocument = {
    _count: VendorVerificationDocumentCountAggregateOutputType | null
    _min: VendorVerificationDocumentMinAggregateOutputType | null
    _max: VendorVerificationDocumentMaxAggregateOutputType | null
  }

  export type VendorVerificationDocumentMinAggregateOutputType = {
    id: string | null
    vendorId: string | null
    documentType: string | null
    documentTitle: string | null
    documentContent: string | null
    documentHash: string | null
    signingToken: string | null
    tokenExpiresAt: Date | null
    signedAt: Date | null
    status: string | null
    ipAddress: string | null
    userAgent: string | null
    reviewedBy: string | null
    reviewedAt: Date | null
    reviewNotes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VendorVerificationDocumentMaxAggregateOutputType = {
    id: string | null
    vendorId: string | null
    documentType: string | null
    documentTitle: string | null
    documentContent: string | null
    documentHash: string | null
    signingToken: string | null
    tokenExpiresAt: Date | null
    signedAt: Date | null
    status: string | null
    ipAddress: string | null
    userAgent: string | null
    reviewedBy: string | null
    reviewedAt: Date | null
    reviewNotes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VendorVerificationDocumentCountAggregateOutputType = {
    id: number
    vendorId: number
    documentType: number
    documentTitle: number
    documentContent: number
    documentHash: number
    signingToken: number
    tokenExpiresAt: number
    signedAt: number
    signatureData: number
    status: number
    ipAddress: number
    userAgent: number
    reviewedBy: number
    reviewedAt: number
    reviewNotes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VendorVerificationDocumentMinAggregateInputType = {
    id?: true
    vendorId?: true
    documentType?: true
    documentTitle?: true
    documentContent?: true
    documentHash?: true
    signingToken?: true
    tokenExpiresAt?: true
    signedAt?: true
    status?: true
    ipAddress?: true
    userAgent?: true
    reviewedBy?: true
    reviewedAt?: true
    reviewNotes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VendorVerificationDocumentMaxAggregateInputType = {
    id?: true
    vendorId?: true
    documentType?: true
    documentTitle?: true
    documentContent?: true
    documentHash?: true
    signingToken?: true
    tokenExpiresAt?: true
    signedAt?: true
    status?: true
    ipAddress?: true
    userAgent?: true
    reviewedBy?: true
    reviewedAt?: true
    reviewNotes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VendorVerificationDocumentCountAggregateInputType = {
    id?: true
    vendorId?: true
    documentType?: true
    documentTitle?: true
    documentContent?: true
    documentHash?: true
    signingToken?: true
    tokenExpiresAt?: true
    signedAt?: true
    signatureData?: true
    status?: true
    ipAddress?: true
    userAgent?: true
    reviewedBy?: true
    reviewedAt?: true
    reviewNotes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VendorVerificationDocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VendorVerificationDocument to aggregate.
     */
    where?: VendorVerificationDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorVerificationDocuments to fetch.
     */
    orderBy?: VendorVerificationDocumentOrderByWithRelationInput | VendorVerificationDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VendorVerificationDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorVerificationDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorVerificationDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VendorVerificationDocuments
    **/
    _count?: true | VendorVerificationDocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VendorVerificationDocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VendorVerificationDocumentMaxAggregateInputType
  }

  export type GetVendorVerificationDocumentAggregateType<T extends VendorVerificationDocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateVendorVerificationDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVendorVerificationDocument[P]>
      : GetScalarType<T[P], AggregateVendorVerificationDocument[P]>
  }




  export type VendorVerificationDocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VendorVerificationDocumentWhereInput
    orderBy?: VendorVerificationDocumentOrderByWithAggregationInput | VendorVerificationDocumentOrderByWithAggregationInput[]
    by: VendorVerificationDocumentScalarFieldEnum[] | VendorVerificationDocumentScalarFieldEnum
    having?: VendorVerificationDocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VendorVerificationDocumentCountAggregateInputType | true
    _min?: VendorVerificationDocumentMinAggregateInputType
    _max?: VendorVerificationDocumentMaxAggregateInputType
  }

  export type VendorVerificationDocumentGroupByOutputType = {
    id: string
    vendorId: string
    documentType: string
    documentTitle: string
    documentContent: string
    documentHash: string
    signingToken: string
    tokenExpiresAt: Date
    signedAt: Date | null
    signatureData: JsonValue | null
    status: string
    ipAddress: string | null
    userAgent: string | null
    reviewedBy: string | null
    reviewedAt: Date | null
    reviewNotes: string | null
    createdAt: Date
    updatedAt: Date
    _count: VendorVerificationDocumentCountAggregateOutputType | null
    _min: VendorVerificationDocumentMinAggregateOutputType | null
    _max: VendorVerificationDocumentMaxAggregateOutputType | null
  }

  type GetVendorVerificationDocumentGroupByPayload<T extends VendorVerificationDocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VendorVerificationDocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VendorVerificationDocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VendorVerificationDocumentGroupByOutputType[P]>
            : GetScalarType<T[P], VendorVerificationDocumentGroupByOutputType[P]>
        }
      >
    >


  export type VendorVerificationDocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendorId?: boolean
    documentType?: boolean
    documentTitle?: boolean
    documentContent?: boolean
    documentHash?: boolean
    signingToken?: boolean
    tokenExpiresAt?: boolean
    signedAt?: boolean
    signatureData?: boolean
    status?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    reviewedBy?: boolean
    reviewedAt?: boolean
    reviewNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vendorVerificationDocument"]>

  export type VendorVerificationDocumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendorId?: boolean
    documentType?: boolean
    documentTitle?: boolean
    documentContent?: boolean
    documentHash?: boolean
    signingToken?: boolean
    tokenExpiresAt?: boolean
    signedAt?: boolean
    signatureData?: boolean
    status?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    reviewedBy?: boolean
    reviewedAt?: boolean
    reviewNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vendorVerificationDocument"]>

  export type VendorVerificationDocumentSelectScalar = {
    id?: boolean
    vendorId?: boolean
    documentType?: boolean
    documentTitle?: boolean
    documentContent?: boolean
    documentHash?: boolean
    signingToken?: boolean
    tokenExpiresAt?: boolean
    signedAt?: boolean
    signatureData?: boolean
    status?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    reviewedBy?: boolean
    reviewedAt?: boolean
    reviewNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VendorVerificationDocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }
  export type VendorVerificationDocumentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }

  export type $VendorVerificationDocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VendorVerificationDocument"
    objects: {
      vendor: Prisma.$VendorPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      vendorId: string
      documentType: string
      documentTitle: string
      documentContent: string
      documentHash: string
      signingToken: string
      tokenExpiresAt: Date
      signedAt: Date | null
      signatureData: Prisma.JsonValue | null
      status: string
      ipAddress: string | null
      userAgent: string | null
      reviewedBy: string | null
      reviewedAt: Date | null
      reviewNotes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["vendorVerificationDocument"]>
    composites: {}
  }

  type VendorVerificationDocumentGetPayload<S extends boolean | null | undefined | VendorVerificationDocumentDefaultArgs> = $Result.GetResult<Prisma.$VendorVerificationDocumentPayload, S>

  type VendorVerificationDocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VendorVerificationDocumentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VendorVerificationDocumentCountAggregateInputType | true
    }

  export interface VendorVerificationDocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VendorVerificationDocument'], meta: { name: 'VendorVerificationDocument' } }
    /**
     * Find zero or one VendorVerificationDocument that matches the filter.
     * @param {VendorVerificationDocumentFindUniqueArgs} args - Arguments to find a VendorVerificationDocument
     * @example
     * // Get one VendorVerificationDocument
     * const vendorVerificationDocument = await prisma.vendorVerificationDocument.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VendorVerificationDocumentFindUniqueArgs>(args: SelectSubset<T, VendorVerificationDocumentFindUniqueArgs<ExtArgs>>): Prisma__VendorVerificationDocumentClient<$Result.GetResult<Prisma.$VendorVerificationDocumentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one VendorVerificationDocument that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VendorVerificationDocumentFindUniqueOrThrowArgs} args - Arguments to find a VendorVerificationDocument
     * @example
     * // Get one VendorVerificationDocument
     * const vendorVerificationDocument = await prisma.vendorVerificationDocument.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VendorVerificationDocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, VendorVerificationDocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VendorVerificationDocumentClient<$Result.GetResult<Prisma.$VendorVerificationDocumentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first VendorVerificationDocument that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorVerificationDocumentFindFirstArgs} args - Arguments to find a VendorVerificationDocument
     * @example
     * // Get one VendorVerificationDocument
     * const vendorVerificationDocument = await prisma.vendorVerificationDocument.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VendorVerificationDocumentFindFirstArgs>(args?: SelectSubset<T, VendorVerificationDocumentFindFirstArgs<ExtArgs>>): Prisma__VendorVerificationDocumentClient<$Result.GetResult<Prisma.$VendorVerificationDocumentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first VendorVerificationDocument that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorVerificationDocumentFindFirstOrThrowArgs} args - Arguments to find a VendorVerificationDocument
     * @example
     * // Get one VendorVerificationDocument
     * const vendorVerificationDocument = await prisma.vendorVerificationDocument.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VendorVerificationDocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, VendorVerificationDocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__VendorVerificationDocumentClient<$Result.GetResult<Prisma.$VendorVerificationDocumentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more VendorVerificationDocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorVerificationDocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VendorVerificationDocuments
     * const vendorVerificationDocuments = await prisma.vendorVerificationDocument.findMany()
     * 
     * // Get first 10 VendorVerificationDocuments
     * const vendorVerificationDocuments = await prisma.vendorVerificationDocument.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vendorVerificationDocumentWithIdOnly = await prisma.vendorVerificationDocument.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VendorVerificationDocumentFindManyArgs>(args?: SelectSubset<T, VendorVerificationDocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorVerificationDocumentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a VendorVerificationDocument.
     * @param {VendorVerificationDocumentCreateArgs} args - Arguments to create a VendorVerificationDocument.
     * @example
     * // Create one VendorVerificationDocument
     * const VendorVerificationDocument = await prisma.vendorVerificationDocument.create({
     *   data: {
     *     // ... data to create a VendorVerificationDocument
     *   }
     * })
     * 
     */
    create<T extends VendorVerificationDocumentCreateArgs>(args: SelectSubset<T, VendorVerificationDocumentCreateArgs<ExtArgs>>): Prisma__VendorVerificationDocumentClient<$Result.GetResult<Prisma.$VendorVerificationDocumentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many VendorVerificationDocuments.
     * @param {VendorVerificationDocumentCreateManyArgs} args - Arguments to create many VendorVerificationDocuments.
     * @example
     * // Create many VendorVerificationDocuments
     * const vendorVerificationDocument = await prisma.vendorVerificationDocument.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VendorVerificationDocumentCreateManyArgs>(args?: SelectSubset<T, VendorVerificationDocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VendorVerificationDocuments and returns the data saved in the database.
     * @param {VendorVerificationDocumentCreateManyAndReturnArgs} args - Arguments to create many VendorVerificationDocuments.
     * @example
     * // Create many VendorVerificationDocuments
     * const vendorVerificationDocument = await prisma.vendorVerificationDocument.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VendorVerificationDocuments and only return the `id`
     * const vendorVerificationDocumentWithIdOnly = await prisma.vendorVerificationDocument.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VendorVerificationDocumentCreateManyAndReturnArgs>(args?: SelectSubset<T, VendorVerificationDocumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorVerificationDocumentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a VendorVerificationDocument.
     * @param {VendorVerificationDocumentDeleteArgs} args - Arguments to delete one VendorVerificationDocument.
     * @example
     * // Delete one VendorVerificationDocument
     * const VendorVerificationDocument = await prisma.vendorVerificationDocument.delete({
     *   where: {
     *     // ... filter to delete one VendorVerificationDocument
     *   }
     * })
     * 
     */
    delete<T extends VendorVerificationDocumentDeleteArgs>(args: SelectSubset<T, VendorVerificationDocumentDeleteArgs<ExtArgs>>): Prisma__VendorVerificationDocumentClient<$Result.GetResult<Prisma.$VendorVerificationDocumentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one VendorVerificationDocument.
     * @param {VendorVerificationDocumentUpdateArgs} args - Arguments to update one VendorVerificationDocument.
     * @example
     * // Update one VendorVerificationDocument
     * const vendorVerificationDocument = await prisma.vendorVerificationDocument.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VendorVerificationDocumentUpdateArgs>(args: SelectSubset<T, VendorVerificationDocumentUpdateArgs<ExtArgs>>): Prisma__VendorVerificationDocumentClient<$Result.GetResult<Prisma.$VendorVerificationDocumentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more VendorVerificationDocuments.
     * @param {VendorVerificationDocumentDeleteManyArgs} args - Arguments to filter VendorVerificationDocuments to delete.
     * @example
     * // Delete a few VendorVerificationDocuments
     * const { count } = await prisma.vendorVerificationDocument.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VendorVerificationDocumentDeleteManyArgs>(args?: SelectSubset<T, VendorVerificationDocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VendorVerificationDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorVerificationDocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VendorVerificationDocuments
     * const vendorVerificationDocument = await prisma.vendorVerificationDocument.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VendorVerificationDocumentUpdateManyArgs>(args: SelectSubset<T, VendorVerificationDocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VendorVerificationDocument.
     * @param {VendorVerificationDocumentUpsertArgs} args - Arguments to update or create a VendorVerificationDocument.
     * @example
     * // Update or create a VendorVerificationDocument
     * const vendorVerificationDocument = await prisma.vendorVerificationDocument.upsert({
     *   create: {
     *     // ... data to create a VendorVerificationDocument
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VendorVerificationDocument we want to update
     *   }
     * })
     */
    upsert<T extends VendorVerificationDocumentUpsertArgs>(args: SelectSubset<T, VendorVerificationDocumentUpsertArgs<ExtArgs>>): Prisma__VendorVerificationDocumentClient<$Result.GetResult<Prisma.$VendorVerificationDocumentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of VendorVerificationDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorVerificationDocumentCountArgs} args - Arguments to filter VendorVerificationDocuments to count.
     * @example
     * // Count the number of VendorVerificationDocuments
     * const count = await prisma.vendorVerificationDocument.count({
     *   where: {
     *     // ... the filter for the VendorVerificationDocuments we want to count
     *   }
     * })
    **/
    count<T extends VendorVerificationDocumentCountArgs>(
      args?: Subset<T, VendorVerificationDocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VendorVerificationDocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VendorVerificationDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorVerificationDocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VendorVerificationDocumentAggregateArgs>(args: Subset<T, VendorVerificationDocumentAggregateArgs>): Prisma.PrismaPromise<GetVendorVerificationDocumentAggregateType<T>>

    /**
     * Group by VendorVerificationDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorVerificationDocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VendorVerificationDocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VendorVerificationDocumentGroupByArgs['orderBy'] }
        : { orderBy?: VendorVerificationDocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VendorVerificationDocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVendorVerificationDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VendorVerificationDocument model
   */
  readonly fields: VendorVerificationDocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VendorVerificationDocument.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VendorVerificationDocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vendor<T extends VendorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VendorDefaultArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VendorVerificationDocument model
   */ 
  interface VendorVerificationDocumentFieldRefs {
    readonly id: FieldRef<"VendorVerificationDocument", 'String'>
    readonly vendorId: FieldRef<"VendorVerificationDocument", 'String'>
    readonly documentType: FieldRef<"VendorVerificationDocument", 'String'>
    readonly documentTitle: FieldRef<"VendorVerificationDocument", 'String'>
    readonly documentContent: FieldRef<"VendorVerificationDocument", 'String'>
    readonly documentHash: FieldRef<"VendorVerificationDocument", 'String'>
    readonly signingToken: FieldRef<"VendorVerificationDocument", 'String'>
    readonly tokenExpiresAt: FieldRef<"VendorVerificationDocument", 'DateTime'>
    readonly signedAt: FieldRef<"VendorVerificationDocument", 'DateTime'>
    readonly signatureData: FieldRef<"VendorVerificationDocument", 'Json'>
    readonly status: FieldRef<"VendorVerificationDocument", 'String'>
    readonly ipAddress: FieldRef<"VendorVerificationDocument", 'String'>
    readonly userAgent: FieldRef<"VendorVerificationDocument", 'String'>
    readonly reviewedBy: FieldRef<"VendorVerificationDocument", 'String'>
    readonly reviewedAt: FieldRef<"VendorVerificationDocument", 'DateTime'>
    readonly reviewNotes: FieldRef<"VendorVerificationDocument", 'String'>
    readonly createdAt: FieldRef<"VendorVerificationDocument", 'DateTime'>
    readonly updatedAt: FieldRef<"VendorVerificationDocument", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VendorVerificationDocument findUnique
   */
  export type VendorVerificationDocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorVerificationDocument
     */
    select?: VendorVerificationDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorVerificationDocumentInclude<ExtArgs> | null
    /**
     * Filter, which VendorVerificationDocument to fetch.
     */
    where: VendorVerificationDocumentWhereUniqueInput
  }

  /**
   * VendorVerificationDocument findUniqueOrThrow
   */
  export type VendorVerificationDocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorVerificationDocument
     */
    select?: VendorVerificationDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorVerificationDocumentInclude<ExtArgs> | null
    /**
     * Filter, which VendorVerificationDocument to fetch.
     */
    where: VendorVerificationDocumentWhereUniqueInput
  }

  /**
   * VendorVerificationDocument findFirst
   */
  export type VendorVerificationDocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorVerificationDocument
     */
    select?: VendorVerificationDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorVerificationDocumentInclude<ExtArgs> | null
    /**
     * Filter, which VendorVerificationDocument to fetch.
     */
    where?: VendorVerificationDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorVerificationDocuments to fetch.
     */
    orderBy?: VendorVerificationDocumentOrderByWithRelationInput | VendorVerificationDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VendorVerificationDocuments.
     */
    cursor?: VendorVerificationDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorVerificationDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorVerificationDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VendorVerificationDocuments.
     */
    distinct?: VendorVerificationDocumentScalarFieldEnum | VendorVerificationDocumentScalarFieldEnum[]
  }

  /**
   * VendorVerificationDocument findFirstOrThrow
   */
  export type VendorVerificationDocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorVerificationDocument
     */
    select?: VendorVerificationDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorVerificationDocumentInclude<ExtArgs> | null
    /**
     * Filter, which VendorVerificationDocument to fetch.
     */
    where?: VendorVerificationDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorVerificationDocuments to fetch.
     */
    orderBy?: VendorVerificationDocumentOrderByWithRelationInput | VendorVerificationDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VendorVerificationDocuments.
     */
    cursor?: VendorVerificationDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorVerificationDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorVerificationDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VendorVerificationDocuments.
     */
    distinct?: VendorVerificationDocumentScalarFieldEnum | VendorVerificationDocumentScalarFieldEnum[]
  }

  /**
   * VendorVerificationDocument findMany
   */
  export type VendorVerificationDocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorVerificationDocument
     */
    select?: VendorVerificationDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorVerificationDocumentInclude<ExtArgs> | null
    /**
     * Filter, which VendorVerificationDocuments to fetch.
     */
    where?: VendorVerificationDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorVerificationDocuments to fetch.
     */
    orderBy?: VendorVerificationDocumentOrderByWithRelationInput | VendorVerificationDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VendorVerificationDocuments.
     */
    cursor?: VendorVerificationDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorVerificationDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorVerificationDocuments.
     */
    skip?: number
    distinct?: VendorVerificationDocumentScalarFieldEnum | VendorVerificationDocumentScalarFieldEnum[]
  }

  /**
   * VendorVerificationDocument create
   */
  export type VendorVerificationDocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorVerificationDocument
     */
    select?: VendorVerificationDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorVerificationDocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a VendorVerificationDocument.
     */
    data: XOR<VendorVerificationDocumentCreateInput, VendorVerificationDocumentUncheckedCreateInput>
  }

  /**
   * VendorVerificationDocument createMany
   */
  export type VendorVerificationDocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VendorVerificationDocuments.
     */
    data: VendorVerificationDocumentCreateManyInput | VendorVerificationDocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VendorVerificationDocument createManyAndReturn
   */
  export type VendorVerificationDocumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorVerificationDocument
     */
    select?: VendorVerificationDocumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many VendorVerificationDocuments.
     */
    data: VendorVerificationDocumentCreateManyInput | VendorVerificationDocumentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorVerificationDocumentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VendorVerificationDocument update
   */
  export type VendorVerificationDocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorVerificationDocument
     */
    select?: VendorVerificationDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorVerificationDocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a VendorVerificationDocument.
     */
    data: XOR<VendorVerificationDocumentUpdateInput, VendorVerificationDocumentUncheckedUpdateInput>
    /**
     * Choose, which VendorVerificationDocument to update.
     */
    where: VendorVerificationDocumentWhereUniqueInput
  }

  /**
   * VendorVerificationDocument updateMany
   */
  export type VendorVerificationDocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VendorVerificationDocuments.
     */
    data: XOR<VendorVerificationDocumentUpdateManyMutationInput, VendorVerificationDocumentUncheckedUpdateManyInput>
    /**
     * Filter which VendorVerificationDocuments to update
     */
    where?: VendorVerificationDocumentWhereInput
  }

  /**
   * VendorVerificationDocument upsert
   */
  export type VendorVerificationDocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorVerificationDocument
     */
    select?: VendorVerificationDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorVerificationDocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the VendorVerificationDocument to update in case it exists.
     */
    where: VendorVerificationDocumentWhereUniqueInput
    /**
     * In case the VendorVerificationDocument found by the `where` argument doesn't exist, create a new VendorVerificationDocument with this data.
     */
    create: XOR<VendorVerificationDocumentCreateInput, VendorVerificationDocumentUncheckedCreateInput>
    /**
     * In case the VendorVerificationDocument was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VendorVerificationDocumentUpdateInput, VendorVerificationDocumentUncheckedUpdateInput>
  }

  /**
   * VendorVerificationDocument delete
   */
  export type VendorVerificationDocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorVerificationDocument
     */
    select?: VendorVerificationDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorVerificationDocumentInclude<ExtArgs> | null
    /**
     * Filter which VendorVerificationDocument to delete.
     */
    where: VendorVerificationDocumentWhereUniqueInput
  }

  /**
   * VendorVerificationDocument deleteMany
   */
  export type VendorVerificationDocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VendorVerificationDocuments to delete
     */
    where?: VendorVerificationDocumentWhereInput
  }

  /**
   * VendorVerificationDocument without action
   */
  export type VendorVerificationDocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorVerificationDocument
     */
    select?: VendorVerificationDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorVerificationDocumentInclude<ExtArgs> | null
  }


  /**
   * Model VendorDynamicField
   */

  export type AggregateVendorDynamicField = {
    _count: VendorDynamicFieldCountAggregateOutputType | null
    _avg: VendorDynamicFieldAvgAggregateOutputType | null
    _sum: VendorDynamicFieldSumAggregateOutputType | null
    _min: VendorDynamicFieldMinAggregateOutputType | null
    _max: VendorDynamicFieldMaxAggregateOutputType | null
  }

  export type VendorDynamicFieldAvgAggregateOutputType = {
    displayOrder: number | null
  }

  export type VendorDynamicFieldSumAggregateOutputType = {
    displayOrder: number | null
  }

  export type VendorDynamicFieldMinAggregateOutputType = {
    id: string | null
    vendorId: string | null
    fieldName: string | null
    fieldLabel: string | null
    fieldType: string | null
    fieldValue: string | null
    isRequired: boolean | null
    displayOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VendorDynamicFieldMaxAggregateOutputType = {
    id: string | null
    vendorId: string | null
    fieldName: string | null
    fieldLabel: string | null
    fieldType: string | null
    fieldValue: string | null
    isRequired: boolean | null
    displayOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VendorDynamicFieldCountAggregateOutputType = {
    id: number
    vendorId: number
    fieldName: number
    fieldLabel: number
    fieldType: number
    fieldOptions: number
    fieldValue: number
    isRequired: number
    displayOrder: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VendorDynamicFieldAvgAggregateInputType = {
    displayOrder?: true
  }

  export type VendorDynamicFieldSumAggregateInputType = {
    displayOrder?: true
  }

  export type VendorDynamicFieldMinAggregateInputType = {
    id?: true
    vendorId?: true
    fieldName?: true
    fieldLabel?: true
    fieldType?: true
    fieldValue?: true
    isRequired?: true
    displayOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VendorDynamicFieldMaxAggregateInputType = {
    id?: true
    vendorId?: true
    fieldName?: true
    fieldLabel?: true
    fieldType?: true
    fieldValue?: true
    isRequired?: true
    displayOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VendorDynamicFieldCountAggregateInputType = {
    id?: true
    vendorId?: true
    fieldName?: true
    fieldLabel?: true
    fieldType?: true
    fieldOptions?: true
    fieldValue?: true
    isRequired?: true
    displayOrder?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VendorDynamicFieldAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VendorDynamicField to aggregate.
     */
    where?: VendorDynamicFieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorDynamicFields to fetch.
     */
    orderBy?: VendorDynamicFieldOrderByWithRelationInput | VendorDynamicFieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VendorDynamicFieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorDynamicFields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorDynamicFields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VendorDynamicFields
    **/
    _count?: true | VendorDynamicFieldCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VendorDynamicFieldAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VendorDynamicFieldSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VendorDynamicFieldMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VendorDynamicFieldMaxAggregateInputType
  }

  export type GetVendorDynamicFieldAggregateType<T extends VendorDynamicFieldAggregateArgs> = {
        [P in keyof T & keyof AggregateVendorDynamicField]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVendorDynamicField[P]>
      : GetScalarType<T[P], AggregateVendorDynamicField[P]>
  }




  export type VendorDynamicFieldGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VendorDynamicFieldWhereInput
    orderBy?: VendorDynamicFieldOrderByWithAggregationInput | VendorDynamicFieldOrderByWithAggregationInput[]
    by: VendorDynamicFieldScalarFieldEnum[] | VendorDynamicFieldScalarFieldEnum
    having?: VendorDynamicFieldScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VendorDynamicFieldCountAggregateInputType | true
    _avg?: VendorDynamicFieldAvgAggregateInputType
    _sum?: VendorDynamicFieldSumAggregateInputType
    _min?: VendorDynamicFieldMinAggregateInputType
    _max?: VendorDynamicFieldMaxAggregateInputType
  }

  export type VendorDynamicFieldGroupByOutputType = {
    id: string
    vendorId: string
    fieldName: string
    fieldLabel: string
    fieldType: string
    fieldOptions: string[]
    fieldValue: string | null
    isRequired: boolean
    displayOrder: number
    createdAt: Date
    updatedAt: Date
    _count: VendorDynamicFieldCountAggregateOutputType | null
    _avg: VendorDynamicFieldAvgAggregateOutputType | null
    _sum: VendorDynamicFieldSumAggregateOutputType | null
    _min: VendorDynamicFieldMinAggregateOutputType | null
    _max: VendorDynamicFieldMaxAggregateOutputType | null
  }

  type GetVendorDynamicFieldGroupByPayload<T extends VendorDynamicFieldGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VendorDynamicFieldGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VendorDynamicFieldGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VendorDynamicFieldGroupByOutputType[P]>
            : GetScalarType<T[P], VendorDynamicFieldGroupByOutputType[P]>
        }
      >
    >


  export type VendorDynamicFieldSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendorId?: boolean
    fieldName?: boolean
    fieldLabel?: boolean
    fieldType?: boolean
    fieldOptions?: boolean
    fieldValue?: boolean
    isRequired?: boolean
    displayOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vendorDynamicField"]>

  export type VendorDynamicFieldSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendorId?: boolean
    fieldName?: boolean
    fieldLabel?: boolean
    fieldType?: boolean
    fieldOptions?: boolean
    fieldValue?: boolean
    isRequired?: boolean
    displayOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vendorDynamicField"]>

  export type VendorDynamicFieldSelectScalar = {
    id?: boolean
    vendorId?: boolean
    fieldName?: boolean
    fieldLabel?: boolean
    fieldType?: boolean
    fieldOptions?: boolean
    fieldValue?: boolean
    isRequired?: boolean
    displayOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VendorDynamicFieldInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }
  export type VendorDynamicFieldIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }

  export type $VendorDynamicFieldPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VendorDynamicField"
    objects: {
      vendor: Prisma.$VendorPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      vendorId: string
      fieldName: string
      fieldLabel: string
      fieldType: string
      fieldOptions: string[]
      fieldValue: string | null
      isRequired: boolean
      displayOrder: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["vendorDynamicField"]>
    composites: {}
  }

  type VendorDynamicFieldGetPayload<S extends boolean | null | undefined | VendorDynamicFieldDefaultArgs> = $Result.GetResult<Prisma.$VendorDynamicFieldPayload, S>

  type VendorDynamicFieldCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VendorDynamicFieldFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VendorDynamicFieldCountAggregateInputType | true
    }

  export interface VendorDynamicFieldDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VendorDynamicField'], meta: { name: 'VendorDynamicField' } }
    /**
     * Find zero or one VendorDynamicField that matches the filter.
     * @param {VendorDynamicFieldFindUniqueArgs} args - Arguments to find a VendorDynamicField
     * @example
     * // Get one VendorDynamicField
     * const vendorDynamicField = await prisma.vendorDynamicField.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VendorDynamicFieldFindUniqueArgs>(args: SelectSubset<T, VendorDynamicFieldFindUniqueArgs<ExtArgs>>): Prisma__VendorDynamicFieldClient<$Result.GetResult<Prisma.$VendorDynamicFieldPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one VendorDynamicField that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VendorDynamicFieldFindUniqueOrThrowArgs} args - Arguments to find a VendorDynamicField
     * @example
     * // Get one VendorDynamicField
     * const vendorDynamicField = await prisma.vendorDynamicField.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VendorDynamicFieldFindUniqueOrThrowArgs>(args: SelectSubset<T, VendorDynamicFieldFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VendorDynamicFieldClient<$Result.GetResult<Prisma.$VendorDynamicFieldPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first VendorDynamicField that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorDynamicFieldFindFirstArgs} args - Arguments to find a VendorDynamicField
     * @example
     * // Get one VendorDynamicField
     * const vendorDynamicField = await prisma.vendorDynamicField.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VendorDynamicFieldFindFirstArgs>(args?: SelectSubset<T, VendorDynamicFieldFindFirstArgs<ExtArgs>>): Prisma__VendorDynamicFieldClient<$Result.GetResult<Prisma.$VendorDynamicFieldPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first VendorDynamicField that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorDynamicFieldFindFirstOrThrowArgs} args - Arguments to find a VendorDynamicField
     * @example
     * // Get one VendorDynamicField
     * const vendorDynamicField = await prisma.vendorDynamicField.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VendorDynamicFieldFindFirstOrThrowArgs>(args?: SelectSubset<T, VendorDynamicFieldFindFirstOrThrowArgs<ExtArgs>>): Prisma__VendorDynamicFieldClient<$Result.GetResult<Prisma.$VendorDynamicFieldPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more VendorDynamicFields that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorDynamicFieldFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VendorDynamicFields
     * const vendorDynamicFields = await prisma.vendorDynamicField.findMany()
     * 
     * // Get first 10 VendorDynamicFields
     * const vendorDynamicFields = await prisma.vendorDynamicField.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vendorDynamicFieldWithIdOnly = await prisma.vendorDynamicField.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VendorDynamicFieldFindManyArgs>(args?: SelectSubset<T, VendorDynamicFieldFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorDynamicFieldPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a VendorDynamicField.
     * @param {VendorDynamicFieldCreateArgs} args - Arguments to create a VendorDynamicField.
     * @example
     * // Create one VendorDynamicField
     * const VendorDynamicField = await prisma.vendorDynamicField.create({
     *   data: {
     *     // ... data to create a VendorDynamicField
     *   }
     * })
     * 
     */
    create<T extends VendorDynamicFieldCreateArgs>(args: SelectSubset<T, VendorDynamicFieldCreateArgs<ExtArgs>>): Prisma__VendorDynamicFieldClient<$Result.GetResult<Prisma.$VendorDynamicFieldPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many VendorDynamicFields.
     * @param {VendorDynamicFieldCreateManyArgs} args - Arguments to create many VendorDynamicFields.
     * @example
     * // Create many VendorDynamicFields
     * const vendorDynamicField = await prisma.vendorDynamicField.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VendorDynamicFieldCreateManyArgs>(args?: SelectSubset<T, VendorDynamicFieldCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VendorDynamicFields and returns the data saved in the database.
     * @param {VendorDynamicFieldCreateManyAndReturnArgs} args - Arguments to create many VendorDynamicFields.
     * @example
     * // Create many VendorDynamicFields
     * const vendorDynamicField = await prisma.vendorDynamicField.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VendorDynamicFields and only return the `id`
     * const vendorDynamicFieldWithIdOnly = await prisma.vendorDynamicField.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VendorDynamicFieldCreateManyAndReturnArgs>(args?: SelectSubset<T, VendorDynamicFieldCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorDynamicFieldPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a VendorDynamicField.
     * @param {VendorDynamicFieldDeleteArgs} args - Arguments to delete one VendorDynamicField.
     * @example
     * // Delete one VendorDynamicField
     * const VendorDynamicField = await prisma.vendorDynamicField.delete({
     *   where: {
     *     // ... filter to delete one VendorDynamicField
     *   }
     * })
     * 
     */
    delete<T extends VendorDynamicFieldDeleteArgs>(args: SelectSubset<T, VendorDynamicFieldDeleteArgs<ExtArgs>>): Prisma__VendorDynamicFieldClient<$Result.GetResult<Prisma.$VendorDynamicFieldPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one VendorDynamicField.
     * @param {VendorDynamicFieldUpdateArgs} args - Arguments to update one VendorDynamicField.
     * @example
     * // Update one VendorDynamicField
     * const vendorDynamicField = await prisma.vendorDynamicField.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VendorDynamicFieldUpdateArgs>(args: SelectSubset<T, VendorDynamicFieldUpdateArgs<ExtArgs>>): Prisma__VendorDynamicFieldClient<$Result.GetResult<Prisma.$VendorDynamicFieldPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more VendorDynamicFields.
     * @param {VendorDynamicFieldDeleteManyArgs} args - Arguments to filter VendorDynamicFields to delete.
     * @example
     * // Delete a few VendorDynamicFields
     * const { count } = await prisma.vendorDynamicField.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VendorDynamicFieldDeleteManyArgs>(args?: SelectSubset<T, VendorDynamicFieldDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VendorDynamicFields.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorDynamicFieldUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VendorDynamicFields
     * const vendorDynamicField = await prisma.vendorDynamicField.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VendorDynamicFieldUpdateManyArgs>(args: SelectSubset<T, VendorDynamicFieldUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VendorDynamicField.
     * @param {VendorDynamicFieldUpsertArgs} args - Arguments to update or create a VendorDynamicField.
     * @example
     * // Update or create a VendorDynamicField
     * const vendorDynamicField = await prisma.vendorDynamicField.upsert({
     *   create: {
     *     // ... data to create a VendorDynamicField
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VendorDynamicField we want to update
     *   }
     * })
     */
    upsert<T extends VendorDynamicFieldUpsertArgs>(args: SelectSubset<T, VendorDynamicFieldUpsertArgs<ExtArgs>>): Prisma__VendorDynamicFieldClient<$Result.GetResult<Prisma.$VendorDynamicFieldPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of VendorDynamicFields.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorDynamicFieldCountArgs} args - Arguments to filter VendorDynamicFields to count.
     * @example
     * // Count the number of VendorDynamicFields
     * const count = await prisma.vendorDynamicField.count({
     *   where: {
     *     // ... the filter for the VendorDynamicFields we want to count
     *   }
     * })
    **/
    count<T extends VendorDynamicFieldCountArgs>(
      args?: Subset<T, VendorDynamicFieldCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VendorDynamicFieldCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VendorDynamicField.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorDynamicFieldAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VendorDynamicFieldAggregateArgs>(args: Subset<T, VendorDynamicFieldAggregateArgs>): Prisma.PrismaPromise<GetVendorDynamicFieldAggregateType<T>>

    /**
     * Group by VendorDynamicField.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorDynamicFieldGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VendorDynamicFieldGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VendorDynamicFieldGroupByArgs['orderBy'] }
        : { orderBy?: VendorDynamicFieldGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VendorDynamicFieldGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVendorDynamicFieldGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VendorDynamicField model
   */
  readonly fields: VendorDynamicFieldFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VendorDynamicField.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VendorDynamicFieldClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vendor<T extends VendorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VendorDefaultArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VendorDynamicField model
   */ 
  interface VendorDynamicFieldFieldRefs {
    readonly id: FieldRef<"VendorDynamicField", 'String'>
    readonly vendorId: FieldRef<"VendorDynamicField", 'String'>
    readonly fieldName: FieldRef<"VendorDynamicField", 'String'>
    readonly fieldLabel: FieldRef<"VendorDynamicField", 'String'>
    readonly fieldType: FieldRef<"VendorDynamicField", 'String'>
    readonly fieldOptions: FieldRef<"VendorDynamicField", 'String[]'>
    readonly fieldValue: FieldRef<"VendorDynamicField", 'String'>
    readonly isRequired: FieldRef<"VendorDynamicField", 'Boolean'>
    readonly displayOrder: FieldRef<"VendorDynamicField", 'Int'>
    readonly createdAt: FieldRef<"VendorDynamicField", 'DateTime'>
    readonly updatedAt: FieldRef<"VendorDynamicField", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VendorDynamicField findUnique
   */
  export type VendorDynamicFieldFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorDynamicField
     */
    select?: VendorDynamicFieldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorDynamicFieldInclude<ExtArgs> | null
    /**
     * Filter, which VendorDynamicField to fetch.
     */
    where: VendorDynamicFieldWhereUniqueInput
  }

  /**
   * VendorDynamicField findUniqueOrThrow
   */
  export type VendorDynamicFieldFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorDynamicField
     */
    select?: VendorDynamicFieldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorDynamicFieldInclude<ExtArgs> | null
    /**
     * Filter, which VendorDynamicField to fetch.
     */
    where: VendorDynamicFieldWhereUniqueInput
  }

  /**
   * VendorDynamicField findFirst
   */
  export type VendorDynamicFieldFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorDynamicField
     */
    select?: VendorDynamicFieldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorDynamicFieldInclude<ExtArgs> | null
    /**
     * Filter, which VendorDynamicField to fetch.
     */
    where?: VendorDynamicFieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorDynamicFields to fetch.
     */
    orderBy?: VendorDynamicFieldOrderByWithRelationInput | VendorDynamicFieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VendorDynamicFields.
     */
    cursor?: VendorDynamicFieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorDynamicFields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorDynamicFields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VendorDynamicFields.
     */
    distinct?: VendorDynamicFieldScalarFieldEnum | VendorDynamicFieldScalarFieldEnum[]
  }

  /**
   * VendorDynamicField findFirstOrThrow
   */
  export type VendorDynamicFieldFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorDynamicField
     */
    select?: VendorDynamicFieldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorDynamicFieldInclude<ExtArgs> | null
    /**
     * Filter, which VendorDynamicField to fetch.
     */
    where?: VendorDynamicFieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorDynamicFields to fetch.
     */
    orderBy?: VendorDynamicFieldOrderByWithRelationInput | VendorDynamicFieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VendorDynamicFields.
     */
    cursor?: VendorDynamicFieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorDynamicFields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorDynamicFields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VendorDynamicFields.
     */
    distinct?: VendorDynamicFieldScalarFieldEnum | VendorDynamicFieldScalarFieldEnum[]
  }

  /**
   * VendorDynamicField findMany
   */
  export type VendorDynamicFieldFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorDynamicField
     */
    select?: VendorDynamicFieldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorDynamicFieldInclude<ExtArgs> | null
    /**
     * Filter, which VendorDynamicFields to fetch.
     */
    where?: VendorDynamicFieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorDynamicFields to fetch.
     */
    orderBy?: VendorDynamicFieldOrderByWithRelationInput | VendorDynamicFieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VendorDynamicFields.
     */
    cursor?: VendorDynamicFieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorDynamicFields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorDynamicFields.
     */
    skip?: number
    distinct?: VendorDynamicFieldScalarFieldEnum | VendorDynamicFieldScalarFieldEnum[]
  }

  /**
   * VendorDynamicField create
   */
  export type VendorDynamicFieldCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorDynamicField
     */
    select?: VendorDynamicFieldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorDynamicFieldInclude<ExtArgs> | null
    /**
     * The data needed to create a VendorDynamicField.
     */
    data: XOR<VendorDynamicFieldCreateInput, VendorDynamicFieldUncheckedCreateInput>
  }

  /**
   * VendorDynamicField createMany
   */
  export type VendorDynamicFieldCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VendorDynamicFields.
     */
    data: VendorDynamicFieldCreateManyInput | VendorDynamicFieldCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VendorDynamicField createManyAndReturn
   */
  export type VendorDynamicFieldCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorDynamicField
     */
    select?: VendorDynamicFieldSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many VendorDynamicFields.
     */
    data: VendorDynamicFieldCreateManyInput | VendorDynamicFieldCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorDynamicFieldIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VendorDynamicField update
   */
  export type VendorDynamicFieldUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorDynamicField
     */
    select?: VendorDynamicFieldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorDynamicFieldInclude<ExtArgs> | null
    /**
     * The data needed to update a VendorDynamicField.
     */
    data: XOR<VendorDynamicFieldUpdateInput, VendorDynamicFieldUncheckedUpdateInput>
    /**
     * Choose, which VendorDynamicField to update.
     */
    where: VendorDynamicFieldWhereUniqueInput
  }

  /**
   * VendorDynamicField updateMany
   */
  export type VendorDynamicFieldUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VendorDynamicFields.
     */
    data: XOR<VendorDynamicFieldUpdateManyMutationInput, VendorDynamicFieldUncheckedUpdateManyInput>
    /**
     * Filter which VendorDynamicFields to update
     */
    where?: VendorDynamicFieldWhereInput
  }

  /**
   * VendorDynamicField upsert
   */
  export type VendorDynamicFieldUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorDynamicField
     */
    select?: VendorDynamicFieldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorDynamicFieldInclude<ExtArgs> | null
    /**
     * The filter to search for the VendorDynamicField to update in case it exists.
     */
    where: VendorDynamicFieldWhereUniqueInput
    /**
     * In case the VendorDynamicField found by the `where` argument doesn't exist, create a new VendorDynamicField with this data.
     */
    create: XOR<VendorDynamicFieldCreateInput, VendorDynamicFieldUncheckedCreateInput>
    /**
     * In case the VendorDynamicField was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VendorDynamicFieldUpdateInput, VendorDynamicFieldUncheckedUpdateInput>
  }

  /**
   * VendorDynamicField delete
   */
  export type VendorDynamicFieldDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorDynamicField
     */
    select?: VendorDynamicFieldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorDynamicFieldInclude<ExtArgs> | null
    /**
     * Filter which VendorDynamicField to delete.
     */
    where: VendorDynamicFieldWhereUniqueInput
  }

  /**
   * VendorDynamicField deleteMany
   */
  export type VendorDynamicFieldDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VendorDynamicFields to delete
     */
    where?: VendorDynamicFieldWhereInput
  }

  /**
   * VendorDynamicField without action
   */
  export type VendorDynamicFieldDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorDynamicField
     */
    select?: VendorDynamicFieldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorDynamicFieldInclude<ExtArgs> | null
  }


  /**
   * Model PackageDynamicField
   */

  export type AggregatePackageDynamicField = {
    _count: PackageDynamicFieldCountAggregateOutputType | null
    _avg: PackageDynamicFieldAvgAggregateOutputType | null
    _sum: PackageDynamicFieldSumAggregateOutputType | null
    _min: PackageDynamicFieldMinAggregateOutputType | null
    _max: PackageDynamicFieldMaxAggregateOutputType | null
  }

  export type PackageDynamicFieldAvgAggregateOutputType = {
    displayOrder: number | null
  }

  export type PackageDynamicFieldSumAggregateOutputType = {
    displayOrder: number | null
  }

  export type PackageDynamicFieldMinAggregateOutputType = {
    id: string | null
    packageId: string | null
    fieldName: string | null
    fieldLabel: string | null
    fieldType: string | null
    fieldValue: string | null
    isRequired: boolean | null
    displayOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PackageDynamicFieldMaxAggregateOutputType = {
    id: string | null
    packageId: string | null
    fieldName: string | null
    fieldLabel: string | null
    fieldType: string | null
    fieldValue: string | null
    isRequired: boolean | null
    displayOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PackageDynamicFieldCountAggregateOutputType = {
    id: number
    packageId: number
    fieldName: number
    fieldLabel: number
    fieldType: number
    fieldOptions: number
    fieldValue: number
    isRequired: number
    displayOrder: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PackageDynamicFieldAvgAggregateInputType = {
    displayOrder?: true
  }

  export type PackageDynamicFieldSumAggregateInputType = {
    displayOrder?: true
  }

  export type PackageDynamicFieldMinAggregateInputType = {
    id?: true
    packageId?: true
    fieldName?: true
    fieldLabel?: true
    fieldType?: true
    fieldValue?: true
    isRequired?: true
    displayOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PackageDynamicFieldMaxAggregateInputType = {
    id?: true
    packageId?: true
    fieldName?: true
    fieldLabel?: true
    fieldType?: true
    fieldValue?: true
    isRequired?: true
    displayOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PackageDynamicFieldCountAggregateInputType = {
    id?: true
    packageId?: true
    fieldName?: true
    fieldLabel?: true
    fieldType?: true
    fieldOptions?: true
    fieldValue?: true
    isRequired?: true
    displayOrder?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PackageDynamicFieldAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PackageDynamicField to aggregate.
     */
    where?: PackageDynamicFieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PackageDynamicFields to fetch.
     */
    orderBy?: PackageDynamicFieldOrderByWithRelationInput | PackageDynamicFieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PackageDynamicFieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PackageDynamicFields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PackageDynamicFields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PackageDynamicFields
    **/
    _count?: true | PackageDynamicFieldCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PackageDynamicFieldAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PackageDynamicFieldSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PackageDynamicFieldMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PackageDynamicFieldMaxAggregateInputType
  }

  export type GetPackageDynamicFieldAggregateType<T extends PackageDynamicFieldAggregateArgs> = {
        [P in keyof T & keyof AggregatePackageDynamicField]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePackageDynamicField[P]>
      : GetScalarType<T[P], AggregatePackageDynamicField[P]>
  }




  export type PackageDynamicFieldGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PackageDynamicFieldWhereInput
    orderBy?: PackageDynamicFieldOrderByWithAggregationInput | PackageDynamicFieldOrderByWithAggregationInput[]
    by: PackageDynamicFieldScalarFieldEnum[] | PackageDynamicFieldScalarFieldEnum
    having?: PackageDynamicFieldScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PackageDynamicFieldCountAggregateInputType | true
    _avg?: PackageDynamicFieldAvgAggregateInputType
    _sum?: PackageDynamicFieldSumAggregateInputType
    _min?: PackageDynamicFieldMinAggregateInputType
    _max?: PackageDynamicFieldMaxAggregateInputType
  }

  export type PackageDynamicFieldGroupByOutputType = {
    id: string
    packageId: string
    fieldName: string
    fieldLabel: string
    fieldType: string
    fieldOptions: string[]
    fieldValue: string | null
    isRequired: boolean
    displayOrder: number
    createdAt: Date
    updatedAt: Date
    _count: PackageDynamicFieldCountAggregateOutputType | null
    _avg: PackageDynamicFieldAvgAggregateOutputType | null
    _sum: PackageDynamicFieldSumAggregateOutputType | null
    _min: PackageDynamicFieldMinAggregateOutputType | null
    _max: PackageDynamicFieldMaxAggregateOutputType | null
  }

  type GetPackageDynamicFieldGroupByPayload<T extends PackageDynamicFieldGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PackageDynamicFieldGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PackageDynamicFieldGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PackageDynamicFieldGroupByOutputType[P]>
            : GetScalarType<T[P], PackageDynamicFieldGroupByOutputType[P]>
        }
      >
    >


  export type PackageDynamicFieldSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    packageId?: boolean
    fieldName?: boolean
    fieldLabel?: boolean
    fieldType?: boolean
    fieldOptions?: boolean
    fieldValue?: boolean
    isRequired?: boolean
    displayOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["packageDynamicField"]>

  export type PackageDynamicFieldSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    packageId?: boolean
    fieldName?: boolean
    fieldLabel?: boolean
    fieldType?: boolean
    fieldOptions?: boolean
    fieldValue?: boolean
    isRequired?: boolean
    displayOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["packageDynamicField"]>

  export type PackageDynamicFieldSelectScalar = {
    id?: boolean
    packageId?: boolean
    fieldName?: boolean
    fieldLabel?: boolean
    fieldType?: boolean
    fieldOptions?: boolean
    fieldValue?: boolean
    isRequired?: boolean
    displayOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $PackageDynamicFieldPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PackageDynamicField"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      packageId: string
      fieldName: string
      fieldLabel: string
      fieldType: string
      fieldOptions: string[]
      fieldValue: string | null
      isRequired: boolean
      displayOrder: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["packageDynamicField"]>
    composites: {}
  }

  type PackageDynamicFieldGetPayload<S extends boolean | null | undefined | PackageDynamicFieldDefaultArgs> = $Result.GetResult<Prisma.$PackageDynamicFieldPayload, S>

  type PackageDynamicFieldCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PackageDynamicFieldFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PackageDynamicFieldCountAggregateInputType | true
    }

  export interface PackageDynamicFieldDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PackageDynamicField'], meta: { name: 'PackageDynamicField' } }
    /**
     * Find zero or one PackageDynamicField that matches the filter.
     * @param {PackageDynamicFieldFindUniqueArgs} args - Arguments to find a PackageDynamicField
     * @example
     * // Get one PackageDynamicField
     * const packageDynamicField = await prisma.packageDynamicField.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PackageDynamicFieldFindUniqueArgs>(args: SelectSubset<T, PackageDynamicFieldFindUniqueArgs<ExtArgs>>): Prisma__PackageDynamicFieldClient<$Result.GetResult<Prisma.$PackageDynamicFieldPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PackageDynamicField that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PackageDynamicFieldFindUniqueOrThrowArgs} args - Arguments to find a PackageDynamicField
     * @example
     * // Get one PackageDynamicField
     * const packageDynamicField = await prisma.packageDynamicField.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PackageDynamicFieldFindUniqueOrThrowArgs>(args: SelectSubset<T, PackageDynamicFieldFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PackageDynamicFieldClient<$Result.GetResult<Prisma.$PackageDynamicFieldPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PackageDynamicField that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageDynamicFieldFindFirstArgs} args - Arguments to find a PackageDynamicField
     * @example
     * // Get one PackageDynamicField
     * const packageDynamicField = await prisma.packageDynamicField.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PackageDynamicFieldFindFirstArgs>(args?: SelectSubset<T, PackageDynamicFieldFindFirstArgs<ExtArgs>>): Prisma__PackageDynamicFieldClient<$Result.GetResult<Prisma.$PackageDynamicFieldPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PackageDynamicField that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageDynamicFieldFindFirstOrThrowArgs} args - Arguments to find a PackageDynamicField
     * @example
     * // Get one PackageDynamicField
     * const packageDynamicField = await prisma.packageDynamicField.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PackageDynamicFieldFindFirstOrThrowArgs>(args?: SelectSubset<T, PackageDynamicFieldFindFirstOrThrowArgs<ExtArgs>>): Prisma__PackageDynamicFieldClient<$Result.GetResult<Prisma.$PackageDynamicFieldPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PackageDynamicFields that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageDynamicFieldFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PackageDynamicFields
     * const packageDynamicFields = await prisma.packageDynamicField.findMany()
     * 
     * // Get first 10 PackageDynamicFields
     * const packageDynamicFields = await prisma.packageDynamicField.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const packageDynamicFieldWithIdOnly = await prisma.packageDynamicField.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PackageDynamicFieldFindManyArgs>(args?: SelectSubset<T, PackageDynamicFieldFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PackageDynamicFieldPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PackageDynamicField.
     * @param {PackageDynamicFieldCreateArgs} args - Arguments to create a PackageDynamicField.
     * @example
     * // Create one PackageDynamicField
     * const PackageDynamicField = await prisma.packageDynamicField.create({
     *   data: {
     *     // ... data to create a PackageDynamicField
     *   }
     * })
     * 
     */
    create<T extends PackageDynamicFieldCreateArgs>(args: SelectSubset<T, PackageDynamicFieldCreateArgs<ExtArgs>>): Prisma__PackageDynamicFieldClient<$Result.GetResult<Prisma.$PackageDynamicFieldPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PackageDynamicFields.
     * @param {PackageDynamicFieldCreateManyArgs} args - Arguments to create many PackageDynamicFields.
     * @example
     * // Create many PackageDynamicFields
     * const packageDynamicField = await prisma.packageDynamicField.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PackageDynamicFieldCreateManyArgs>(args?: SelectSubset<T, PackageDynamicFieldCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PackageDynamicFields and returns the data saved in the database.
     * @param {PackageDynamicFieldCreateManyAndReturnArgs} args - Arguments to create many PackageDynamicFields.
     * @example
     * // Create many PackageDynamicFields
     * const packageDynamicField = await prisma.packageDynamicField.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PackageDynamicFields and only return the `id`
     * const packageDynamicFieldWithIdOnly = await prisma.packageDynamicField.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PackageDynamicFieldCreateManyAndReturnArgs>(args?: SelectSubset<T, PackageDynamicFieldCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PackageDynamicFieldPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PackageDynamicField.
     * @param {PackageDynamicFieldDeleteArgs} args - Arguments to delete one PackageDynamicField.
     * @example
     * // Delete one PackageDynamicField
     * const PackageDynamicField = await prisma.packageDynamicField.delete({
     *   where: {
     *     // ... filter to delete one PackageDynamicField
     *   }
     * })
     * 
     */
    delete<T extends PackageDynamicFieldDeleteArgs>(args: SelectSubset<T, PackageDynamicFieldDeleteArgs<ExtArgs>>): Prisma__PackageDynamicFieldClient<$Result.GetResult<Prisma.$PackageDynamicFieldPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PackageDynamicField.
     * @param {PackageDynamicFieldUpdateArgs} args - Arguments to update one PackageDynamicField.
     * @example
     * // Update one PackageDynamicField
     * const packageDynamicField = await prisma.packageDynamicField.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PackageDynamicFieldUpdateArgs>(args: SelectSubset<T, PackageDynamicFieldUpdateArgs<ExtArgs>>): Prisma__PackageDynamicFieldClient<$Result.GetResult<Prisma.$PackageDynamicFieldPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PackageDynamicFields.
     * @param {PackageDynamicFieldDeleteManyArgs} args - Arguments to filter PackageDynamicFields to delete.
     * @example
     * // Delete a few PackageDynamicFields
     * const { count } = await prisma.packageDynamicField.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PackageDynamicFieldDeleteManyArgs>(args?: SelectSubset<T, PackageDynamicFieldDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PackageDynamicFields.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageDynamicFieldUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PackageDynamicFields
     * const packageDynamicField = await prisma.packageDynamicField.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PackageDynamicFieldUpdateManyArgs>(args: SelectSubset<T, PackageDynamicFieldUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PackageDynamicField.
     * @param {PackageDynamicFieldUpsertArgs} args - Arguments to update or create a PackageDynamicField.
     * @example
     * // Update or create a PackageDynamicField
     * const packageDynamicField = await prisma.packageDynamicField.upsert({
     *   create: {
     *     // ... data to create a PackageDynamicField
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PackageDynamicField we want to update
     *   }
     * })
     */
    upsert<T extends PackageDynamicFieldUpsertArgs>(args: SelectSubset<T, PackageDynamicFieldUpsertArgs<ExtArgs>>): Prisma__PackageDynamicFieldClient<$Result.GetResult<Prisma.$PackageDynamicFieldPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PackageDynamicFields.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageDynamicFieldCountArgs} args - Arguments to filter PackageDynamicFields to count.
     * @example
     * // Count the number of PackageDynamicFields
     * const count = await prisma.packageDynamicField.count({
     *   where: {
     *     // ... the filter for the PackageDynamicFields we want to count
     *   }
     * })
    **/
    count<T extends PackageDynamicFieldCountArgs>(
      args?: Subset<T, PackageDynamicFieldCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PackageDynamicFieldCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PackageDynamicField.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageDynamicFieldAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PackageDynamicFieldAggregateArgs>(args: Subset<T, PackageDynamicFieldAggregateArgs>): Prisma.PrismaPromise<GetPackageDynamicFieldAggregateType<T>>

    /**
     * Group by PackageDynamicField.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageDynamicFieldGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PackageDynamicFieldGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PackageDynamicFieldGroupByArgs['orderBy'] }
        : { orderBy?: PackageDynamicFieldGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PackageDynamicFieldGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPackageDynamicFieldGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PackageDynamicField model
   */
  readonly fields: PackageDynamicFieldFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PackageDynamicField.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PackageDynamicFieldClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PackageDynamicField model
   */ 
  interface PackageDynamicFieldFieldRefs {
    readonly id: FieldRef<"PackageDynamicField", 'String'>
    readonly packageId: FieldRef<"PackageDynamicField", 'String'>
    readonly fieldName: FieldRef<"PackageDynamicField", 'String'>
    readonly fieldLabel: FieldRef<"PackageDynamicField", 'String'>
    readonly fieldType: FieldRef<"PackageDynamicField", 'String'>
    readonly fieldOptions: FieldRef<"PackageDynamicField", 'String[]'>
    readonly fieldValue: FieldRef<"PackageDynamicField", 'String'>
    readonly isRequired: FieldRef<"PackageDynamicField", 'Boolean'>
    readonly displayOrder: FieldRef<"PackageDynamicField", 'Int'>
    readonly createdAt: FieldRef<"PackageDynamicField", 'DateTime'>
    readonly updatedAt: FieldRef<"PackageDynamicField", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PackageDynamicField findUnique
   */
  export type PackageDynamicFieldFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageDynamicField
     */
    select?: PackageDynamicFieldSelect<ExtArgs> | null
    /**
     * Filter, which PackageDynamicField to fetch.
     */
    where: PackageDynamicFieldWhereUniqueInput
  }

  /**
   * PackageDynamicField findUniqueOrThrow
   */
  export type PackageDynamicFieldFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageDynamicField
     */
    select?: PackageDynamicFieldSelect<ExtArgs> | null
    /**
     * Filter, which PackageDynamicField to fetch.
     */
    where: PackageDynamicFieldWhereUniqueInput
  }

  /**
   * PackageDynamicField findFirst
   */
  export type PackageDynamicFieldFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageDynamicField
     */
    select?: PackageDynamicFieldSelect<ExtArgs> | null
    /**
     * Filter, which PackageDynamicField to fetch.
     */
    where?: PackageDynamicFieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PackageDynamicFields to fetch.
     */
    orderBy?: PackageDynamicFieldOrderByWithRelationInput | PackageDynamicFieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PackageDynamicFields.
     */
    cursor?: PackageDynamicFieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PackageDynamicFields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PackageDynamicFields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PackageDynamicFields.
     */
    distinct?: PackageDynamicFieldScalarFieldEnum | PackageDynamicFieldScalarFieldEnum[]
  }

  /**
   * PackageDynamicField findFirstOrThrow
   */
  export type PackageDynamicFieldFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageDynamicField
     */
    select?: PackageDynamicFieldSelect<ExtArgs> | null
    /**
     * Filter, which PackageDynamicField to fetch.
     */
    where?: PackageDynamicFieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PackageDynamicFields to fetch.
     */
    orderBy?: PackageDynamicFieldOrderByWithRelationInput | PackageDynamicFieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PackageDynamicFields.
     */
    cursor?: PackageDynamicFieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PackageDynamicFields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PackageDynamicFields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PackageDynamicFields.
     */
    distinct?: PackageDynamicFieldScalarFieldEnum | PackageDynamicFieldScalarFieldEnum[]
  }

  /**
   * PackageDynamicField findMany
   */
  export type PackageDynamicFieldFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageDynamicField
     */
    select?: PackageDynamicFieldSelect<ExtArgs> | null
    /**
     * Filter, which PackageDynamicFields to fetch.
     */
    where?: PackageDynamicFieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PackageDynamicFields to fetch.
     */
    orderBy?: PackageDynamicFieldOrderByWithRelationInput | PackageDynamicFieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PackageDynamicFields.
     */
    cursor?: PackageDynamicFieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PackageDynamicFields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PackageDynamicFields.
     */
    skip?: number
    distinct?: PackageDynamicFieldScalarFieldEnum | PackageDynamicFieldScalarFieldEnum[]
  }

  /**
   * PackageDynamicField create
   */
  export type PackageDynamicFieldCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageDynamicField
     */
    select?: PackageDynamicFieldSelect<ExtArgs> | null
    /**
     * The data needed to create a PackageDynamicField.
     */
    data: XOR<PackageDynamicFieldCreateInput, PackageDynamicFieldUncheckedCreateInput>
  }

  /**
   * PackageDynamicField createMany
   */
  export type PackageDynamicFieldCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PackageDynamicFields.
     */
    data: PackageDynamicFieldCreateManyInput | PackageDynamicFieldCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PackageDynamicField createManyAndReturn
   */
  export type PackageDynamicFieldCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageDynamicField
     */
    select?: PackageDynamicFieldSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PackageDynamicFields.
     */
    data: PackageDynamicFieldCreateManyInput | PackageDynamicFieldCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PackageDynamicField update
   */
  export type PackageDynamicFieldUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageDynamicField
     */
    select?: PackageDynamicFieldSelect<ExtArgs> | null
    /**
     * The data needed to update a PackageDynamicField.
     */
    data: XOR<PackageDynamicFieldUpdateInput, PackageDynamicFieldUncheckedUpdateInput>
    /**
     * Choose, which PackageDynamicField to update.
     */
    where: PackageDynamicFieldWhereUniqueInput
  }

  /**
   * PackageDynamicField updateMany
   */
  export type PackageDynamicFieldUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PackageDynamicFields.
     */
    data: XOR<PackageDynamicFieldUpdateManyMutationInput, PackageDynamicFieldUncheckedUpdateManyInput>
    /**
     * Filter which PackageDynamicFields to update
     */
    where?: PackageDynamicFieldWhereInput
  }

  /**
   * PackageDynamicField upsert
   */
  export type PackageDynamicFieldUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageDynamicField
     */
    select?: PackageDynamicFieldSelect<ExtArgs> | null
    /**
     * The filter to search for the PackageDynamicField to update in case it exists.
     */
    where: PackageDynamicFieldWhereUniqueInput
    /**
     * In case the PackageDynamicField found by the `where` argument doesn't exist, create a new PackageDynamicField with this data.
     */
    create: XOR<PackageDynamicFieldCreateInput, PackageDynamicFieldUncheckedCreateInput>
    /**
     * In case the PackageDynamicField was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PackageDynamicFieldUpdateInput, PackageDynamicFieldUncheckedUpdateInput>
  }

  /**
   * PackageDynamicField delete
   */
  export type PackageDynamicFieldDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageDynamicField
     */
    select?: PackageDynamicFieldSelect<ExtArgs> | null
    /**
     * Filter which PackageDynamicField to delete.
     */
    where: PackageDynamicFieldWhereUniqueInput
  }

  /**
   * PackageDynamicField deleteMany
   */
  export type PackageDynamicFieldDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PackageDynamicFields to delete
     */
    where?: PackageDynamicFieldWhereInput
  }

  /**
   * PackageDynamicField without action
   */
  export type PackageDynamicFieldDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageDynamicField
     */
    select?: PackageDynamicFieldSelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    firstName: 'firstName',
    lastName: 'lastName',
    phone: 'phone',
    role: 'role',
    isVerified: 'isVerified',
    profileImage: 'profileImage',
    weddingDate: 'weddingDate',
    budget: 'budget',
    location: 'location',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const VendorScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    businessName: 'businessName',
    category: 'category',
    description: 'description',
    location: 'location',
    phone: 'phone',
    email: 'email',
    website: 'website',
    experience: 'experience',
    rating: 'rating',
    totalReviews: 'totalReviews',
    isVerified: 'isVerified',
    isActive: 'isActive',
    verificationStatus: 'verificationStatus',
    documentSignedAt: 'documentSignedAt',
    verificationNotes: 'verificationNotes',
    basePrice: 'basePrice',
    priceRange: 'priceRange',
    profileImage: 'profileImage',
    gallery: 'gallery',
    availability: 'availability',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VendorScalarFieldEnum = (typeof VendorScalarFieldEnum)[keyof typeof VendorScalarFieldEnum]


  export const ServiceScalarFieldEnum: {
    id: 'id',
    vendorId: 'vendorId',
    name: 'name',
    description: 'description',
    price: 'price',
    duration: 'duration',
    maxCapacity: 'maxCapacity',
    includes: 'includes',
    addOns: 'addOns',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ServiceScalarFieldEnum = (typeof ServiceScalarFieldEnum)[keyof typeof ServiceScalarFieldEnum]


  export const BookingScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    vendorId: 'vendorId',
    serviceId: 'serviceId',
    eventDate: 'eventDate',
    eventTime: 'eventTime',
    eventDuration: 'eventDuration',
    guestCount: 'guestCount',
    location: 'location',
    specialRequests: 'specialRequests',
    basePrice: 'basePrice',
    additionalCosts: 'additionalCosts',
    totalAmount: 'totalAmount',
    status: 'status',
    paymentStatus: 'paymentStatus',
    requestedAt: 'requestedAt',
    approvedAt: 'approvedAt',
    confirmedAt: 'confirmedAt',
    completedAt: 'completedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BookingScalarFieldEnum = (typeof BookingScalarFieldEnum)[keyof typeof BookingScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    bookingId: 'bookingId',
    amount: 'amount',
    currency: 'currency',
    paymentMethod: 'paymentMethod',
    transactionId: 'transactionId',
    gatewayResponse: 'gatewayResponse',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    senderId: 'senderId',
    receiverId: 'receiverId',
    bookingId: 'bookingId',
    content: 'content',
    messageType: 'messageType',
    attachments: 'attachments',
    isRead: 'isRead',
    createdAt: 'createdAt'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const ChatSessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    vendorId: 'vendorId',
    lastMessageAt: 'lastMessageAt',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ChatSessionScalarFieldEnum = (typeof ChatSessionScalarFieldEnum)[keyof typeof ChatSessionScalarFieldEnum]


  export const ReviewScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    vendorId: 'vendorId',
    rating: 'rating',
    comment: 'comment',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ReviewScalarFieldEnum = (typeof ReviewScalarFieldEnum)[keyof typeof ReviewScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    message: 'message',
    type: 'type',
    isRead: 'isRead',
    createdAt: 'createdAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const WeddingChecklistScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    description: 'description',
    category: 'category',
    isCompleted: 'isCompleted',
    dueDate: 'dueDate',
    priority: 'priority',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WeddingChecklistScalarFieldEnum = (typeof WeddingChecklistScalarFieldEnum)[keyof typeof WeddingChecklistScalarFieldEnum]


  export const AIConversationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    messages: 'messages',
    context: 'context',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AIConversationScalarFieldEnum = (typeof AIConversationScalarFieldEnum)[keyof typeof AIConversationScalarFieldEnum]


  export const MatrimonialProfileScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    phone: 'phone',
    gender: 'gender',
    dateOfBirth: 'dateOfBirth',
    age: 'age',
    city: 'city',
    profession: 'profession',
    education: 'education',
    religion: 'religion',
    height: 'height',
    bio: 'bio',
    interests: 'interests',
    photos: 'photos',
    familyBackground: 'familyBackground',
    partnerPreferences: 'partnerPreferences',
    isVerified: 'isVerified',
    isOnline: 'isOnline',
    lastSeen: 'lastSeen',
    compatibilityScore: 'compatibilityScore',
    isInterested: 'isInterested',
    isMatched: 'isMatched',
    isBlocked: 'isBlocked',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MatrimonialProfileScalarFieldEnum = (typeof MatrimonialProfileScalarFieldEnum)[keyof typeof MatrimonialProfileScalarFieldEnum]


  export const MatrimonialMessageScalarFieldEnum: {
    id: 'id',
    fromProfileId: 'fromProfileId',
    toProfileId: 'toProfileId',
    content: 'content',
    createdAt: 'createdAt'
  };

  export type MatrimonialMessageScalarFieldEnum = (typeof MatrimonialMessageScalarFieldEnum)[keyof typeof MatrimonialMessageScalarFieldEnum]


  export const VendorVerificationDocumentScalarFieldEnum: {
    id: 'id',
    vendorId: 'vendorId',
    documentType: 'documentType',
    documentTitle: 'documentTitle',
    documentContent: 'documentContent',
    documentHash: 'documentHash',
    signingToken: 'signingToken',
    tokenExpiresAt: 'tokenExpiresAt',
    signedAt: 'signedAt',
    signatureData: 'signatureData',
    status: 'status',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    reviewedBy: 'reviewedBy',
    reviewedAt: 'reviewedAt',
    reviewNotes: 'reviewNotes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VendorVerificationDocumentScalarFieldEnum = (typeof VendorVerificationDocumentScalarFieldEnum)[keyof typeof VendorVerificationDocumentScalarFieldEnum]


  export const VendorDynamicFieldScalarFieldEnum: {
    id: 'id',
    vendorId: 'vendorId',
    fieldName: 'fieldName',
    fieldLabel: 'fieldLabel',
    fieldType: 'fieldType',
    fieldOptions: 'fieldOptions',
    fieldValue: 'fieldValue',
    isRequired: 'isRequired',
    displayOrder: 'displayOrder',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VendorDynamicFieldScalarFieldEnum = (typeof VendorDynamicFieldScalarFieldEnum)[keyof typeof VendorDynamicFieldScalarFieldEnum]


  export const PackageDynamicFieldScalarFieldEnum: {
    id: 'id',
    packageId: 'packageId',
    fieldName: 'fieldName',
    fieldLabel: 'fieldLabel',
    fieldType: 'fieldType',
    fieldOptions: 'fieldOptions',
    fieldValue: 'fieldValue',
    isRequired: 'isRequired',
    displayOrder: 'displayOrder',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PackageDynamicFieldScalarFieldEnum = (typeof PackageDynamicFieldScalarFieldEnum)[keyof typeof PackageDynamicFieldScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'VendorCategory'
   */
  export type EnumVendorCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VendorCategory'>
    


  /**
   * Reference to a field of type 'VendorCategory[]'
   */
  export type ListEnumVendorCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VendorCategory[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'VerificationStatus'
   */
  export type EnumVerificationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VerificationStatus'>
    


  /**
   * Reference to a field of type 'VerificationStatus[]'
   */
  export type ListEnumVerificationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VerificationStatus[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'BookingStatus'
   */
  export type EnumBookingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BookingStatus'>
    


  /**
   * Reference to a field of type 'BookingStatus[]'
   */
  export type ListEnumBookingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BookingStatus[]'>
    


  /**
   * Reference to a field of type 'PaymentStatus'
   */
  export type EnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus'>
    


  /**
   * Reference to a field of type 'PaymentStatus[]'
   */
  export type ListEnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus[]'>
    


  /**
   * Reference to a field of type 'Gender'
   */
  export type EnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender'>
    


  /**
   * Reference to a field of type 'Gender[]'
   */
  export type ListEnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isVerified?: BoolFilter<"User"> | boolean
    profileImage?: StringNullableFilter<"User"> | string | null
    weddingDate?: DateTimeNullableFilter<"User"> | Date | string | null
    budget?: FloatNullableFilter<"User"> | number | null
    location?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    bookings?: BookingListRelationFilter
    sentMessages?: MessageListRelationFilter
    receivedMessages?: MessageListRelationFilter
    reviews?: ReviewListRelationFilter
    notifications?: NotificationListRelationFilter
    chatSessions?: ChatSessionListRelationFilter
    vendor?: XOR<VendorNullableRelationFilter, VendorWhereInput> | null
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrderInput | SortOrder
    role?: SortOrder
    isVerified?: SortOrder
    profileImage?: SortOrderInput | SortOrder
    weddingDate?: SortOrderInput | SortOrder
    budget?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bookings?: BookingOrderByRelationAggregateInput
    sentMessages?: MessageOrderByRelationAggregateInput
    receivedMessages?: MessageOrderByRelationAggregateInput
    reviews?: ReviewOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    chatSessions?: ChatSessionOrderByRelationAggregateInput
    vendor?: VendorOrderByWithRelationInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isVerified?: BoolFilter<"User"> | boolean
    profileImage?: StringNullableFilter<"User"> | string | null
    weddingDate?: DateTimeNullableFilter<"User"> | Date | string | null
    budget?: FloatNullableFilter<"User"> | number | null
    location?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    bookings?: BookingListRelationFilter
    sentMessages?: MessageListRelationFilter
    receivedMessages?: MessageListRelationFilter
    reviews?: ReviewListRelationFilter
    notifications?: NotificationListRelationFilter
    chatSessions?: ChatSessionListRelationFilter
    vendor?: XOR<VendorNullableRelationFilter, VendorWhereInput> | null
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrderInput | SortOrder
    role?: SortOrder
    isVerified?: SortOrder
    profileImage?: SortOrderInput | SortOrder
    weddingDate?: SortOrderInput | SortOrder
    budget?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    firstName?: StringWithAggregatesFilter<"User"> | string
    lastName?: StringWithAggregatesFilter<"User"> | string
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    isVerified?: BoolWithAggregatesFilter<"User"> | boolean
    profileImage?: StringNullableWithAggregatesFilter<"User"> | string | null
    weddingDate?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    budget?: FloatNullableWithAggregatesFilter<"User"> | number | null
    location?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type VendorWhereInput = {
    AND?: VendorWhereInput | VendorWhereInput[]
    OR?: VendorWhereInput[]
    NOT?: VendorWhereInput | VendorWhereInput[]
    id?: StringFilter<"Vendor"> | string
    userId?: StringFilter<"Vendor"> | string
    businessName?: StringFilter<"Vendor"> | string
    category?: EnumVendorCategoryFilter<"Vendor"> | $Enums.VendorCategory
    description?: StringFilter<"Vendor"> | string
    location?: StringFilter<"Vendor"> | string
    phone?: StringFilter<"Vendor"> | string
    email?: StringFilter<"Vendor"> | string
    website?: StringNullableFilter<"Vendor"> | string | null
    experience?: IntFilter<"Vendor"> | number
    rating?: FloatFilter<"Vendor"> | number
    totalReviews?: IntFilter<"Vendor"> | number
    isVerified?: BoolFilter<"Vendor"> | boolean
    isActive?: BoolFilter<"Vendor"> | boolean
    verificationStatus?: EnumVerificationStatusFilter<"Vendor"> | $Enums.VerificationStatus
    documentSignedAt?: DateTimeNullableFilter<"Vendor"> | Date | string | null
    verificationNotes?: StringNullableFilter<"Vendor"> | string | null
    basePrice?: FloatNullableFilter<"Vendor"> | number | null
    priceRange?: StringNullableFilter<"Vendor"> | string | null
    profileImage?: StringNullableFilter<"Vendor"> | string | null
    gallery?: StringNullableListFilter<"Vendor">
    availability?: JsonNullableFilter<"Vendor">
    createdAt?: DateTimeFilter<"Vendor"> | Date | string
    updatedAt?: DateTimeFilter<"Vendor"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    bookings?: BookingListRelationFilter
    services?: ServiceListRelationFilter
    reviews?: ReviewListRelationFilter
    chatSessions?: ChatSessionListRelationFilter
    verificationDocuments?: VendorVerificationDocumentListRelationFilter
    dynamicFields?: VendorDynamicFieldListRelationFilter
  }

  export type VendorOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    businessName?: SortOrder
    category?: SortOrder
    description?: SortOrder
    location?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    website?: SortOrderInput | SortOrder
    experience?: SortOrder
    rating?: SortOrder
    totalReviews?: SortOrder
    isVerified?: SortOrder
    isActive?: SortOrder
    verificationStatus?: SortOrder
    documentSignedAt?: SortOrderInput | SortOrder
    verificationNotes?: SortOrderInput | SortOrder
    basePrice?: SortOrderInput | SortOrder
    priceRange?: SortOrderInput | SortOrder
    profileImage?: SortOrderInput | SortOrder
    gallery?: SortOrder
    availability?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    bookings?: BookingOrderByRelationAggregateInput
    services?: ServiceOrderByRelationAggregateInput
    reviews?: ReviewOrderByRelationAggregateInput
    chatSessions?: ChatSessionOrderByRelationAggregateInput
    verificationDocuments?: VendorVerificationDocumentOrderByRelationAggregateInput
    dynamicFields?: VendorDynamicFieldOrderByRelationAggregateInput
  }

  export type VendorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: VendorWhereInput | VendorWhereInput[]
    OR?: VendorWhereInput[]
    NOT?: VendorWhereInput | VendorWhereInput[]
    businessName?: StringFilter<"Vendor"> | string
    category?: EnumVendorCategoryFilter<"Vendor"> | $Enums.VendorCategory
    description?: StringFilter<"Vendor"> | string
    location?: StringFilter<"Vendor"> | string
    phone?: StringFilter<"Vendor"> | string
    email?: StringFilter<"Vendor"> | string
    website?: StringNullableFilter<"Vendor"> | string | null
    experience?: IntFilter<"Vendor"> | number
    rating?: FloatFilter<"Vendor"> | number
    totalReviews?: IntFilter<"Vendor"> | number
    isVerified?: BoolFilter<"Vendor"> | boolean
    isActive?: BoolFilter<"Vendor"> | boolean
    verificationStatus?: EnumVerificationStatusFilter<"Vendor"> | $Enums.VerificationStatus
    documentSignedAt?: DateTimeNullableFilter<"Vendor"> | Date | string | null
    verificationNotes?: StringNullableFilter<"Vendor"> | string | null
    basePrice?: FloatNullableFilter<"Vendor"> | number | null
    priceRange?: StringNullableFilter<"Vendor"> | string | null
    profileImage?: StringNullableFilter<"Vendor"> | string | null
    gallery?: StringNullableListFilter<"Vendor">
    availability?: JsonNullableFilter<"Vendor">
    createdAt?: DateTimeFilter<"Vendor"> | Date | string
    updatedAt?: DateTimeFilter<"Vendor"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    bookings?: BookingListRelationFilter
    services?: ServiceListRelationFilter
    reviews?: ReviewListRelationFilter
    chatSessions?: ChatSessionListRelationFilter
    verificationDocuments?: VendorVerificationDocumentListRelationFilter
    dynamicFields?: VendorDynamicFieldListRelationFilter
  }, "id" | "userId">

  export type VendorOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    businessName?: SortOrder
    category?: SortOrder
    description?: SortOrder
    location?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    website?: SortOrderInput | SortOrder
    experience?: SortOrder
    rating?: SortOrder
    totalReviews?: SortOrder
    isVerified?: SortOrder
    isActive?: SortOrder
    verificationStatus?: SortOrder
    documentSignedAt?: SortOrderInput | SortOrder
    verificationNotes?: SortOrderInput | SortOrder
    basePrice?: SortOrderInput | SortOrder
    priceRange?: SortOrderInput | SortOrder
    profileImage?: SortOrderInput | SortOrder
    gallery?: SortOrder
    availability?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VendorCountOrderByAggregateInput
    _avg?: VendorAvgOrderByAggregateInput
    _max?: VendorMaxOrderByAggregateInput
    _min?: VendorMinOrderByAggregateInput
    _sum?: VendorSumOrderByAggregateInput
  }

  export type VendorScalarWhereWithAggregatesInput = {
    AND?: VendorScalarWhereWithAggregatesInput | VendorScalarWhereWithAggregatesInput[]
    OR?: VendorScalarWhereWithAggregatesInput[]
    NOT?: VendorScalarWhereWithAggregatesInput | VendorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Vendor"> | string
    userId?: StringWithAggregatesFilter<"Vendor"> | string
    businessName?: StringWithAggregatesFilter<"Vendor"> | string
    category?: EnumVendorCategoryWithAggregatesFilter<"Vendor"> | $Enums.VendorCategory
    description?: StringWithAggregatesFilter<"Vendor"> | string
    location?: StringWithAggregatesFilter<"Vendor"> | string
    phone?: StringWithAggregatesFilter<"Vendor"> | string
    email?: StringWithAggregatesFilter<"Vendor"> | string
    website?: StringNullableWithAggregatesFilter<"Vendor"> | string | null
    experience?: IntWithAggregatesFilter<"Vendor"> | number
    rating?: FloatWithAggregatesFilter<"Vendor"> | number
    totalReviews?: IntWithAggregatesFilter<"Vendor"> | number
    isVerified?: BoolWithAggregatesFilter<"Vendor"> | boolean
    isActive?: BoolWithAggregatesFilter<"Vendor"> | boolean
    verificationStatus?: EnumVerificationStatusWithAggregatesFilter<"Vendor"> | $Enums.VerificationStatus
    documentSignedAt?: DateTimeNullableWithAggregatesFilter<"Vendor"> | Date | string | null
    verificationNotes?: StringNullableWithAggregatesFilter<"Vendor"> | string | null
    basePrice?: FloatNullableWithAggregatesFilter<"Vendor"> | number | null
    priceRange?: StringNullableWithAggregatesFilter<"Vendor"> | string | null
    profileImage?: StringNullableWithAggregatesFilter<"Vendor"> | string | null
    gallery?: StringNullableListFilter<"Vendor">
    availability?: JsonNullableWithAggregatesFilter<"Vendor">
    createdAt?: DateTimeWithAggregatesFilter<"Vendor"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Vendor"> | Date | string
  }

  export type ServiceWhereInput = {
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    id?: StringFilter<"Service"> | string
    vendorId?: StringFilter<"Service"> | string
    name?: StringFilter<"Service"> | string
    description?: StringFilter<"Service"> | string
    price?: FloatFilter<"Service"> | number
    duration?: IntNullableFilter<"Service"> | number | null
    maxCapacity?: IntNullableFilter<"Service"> | number | null
    includes?: StringNullableListFilter<"Service">
    addOns?: JsonNullableFilter<"Service">
    isActive?: BoolFilter<"Service"> | boolean
    createdAt?: DateTimeFilter<"Service"> | Date | string
    updatedAt?: DateTimeFilter<"Service"> | Date | string
    vendor?: XOR<VendorRelationFilter, VendorWhereInput>
    bookings?: BookingListRelationFilter
  }

  export type ServiceOrderByWithRelationInput = {
    id?: SortOrder
    vendorId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    duration?: SortOrderInput | SortOrder
    maxCapacity?: SortOrderInput | SortOrder
    includes?: SortOrder
    addOns?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    vendor?: VendorOrderByWithRelationInput
    bookings?: BookingOrderByRelationAggregateInput
  }

  export type ServiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    vendorId?: StringFilter<"Service"> | string
    name?: StringFilter<"Service"> | string
    description?: StringFilter<"Service"> | string
    price?: FloatFilter<"Service"> | number
    duration?: IntNullableFilter<"Service"> | number | null
    maxCapacity?: IntNullableFilter<"Service"> | number | null
    includes?: StringNullableListFilter<"Service">
    addOns?: JsonNullableFilter<"Service">
    isActive?: BoolFilter<"Service"> | boolean
    createdAt?: DateTimeFilter<"Service"> | Date | string
    updatedAt?: DateTimeFilter<"Service"> | Date | string
    vendor?: XOR<VendorRelationFilter, VendorWhereInput>
    bookings?: BookingListRelationFilter
  }, "id">

  export type ServiceOrderByWithAggregationInput = {
    id?: SortOrder
    vendorId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    duration?: SortOrderInput | SortOrder
    maxCapacity?: SortOrderInput | SortOrder
    includes?: SortOrder
    addOns?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ServiceCountOrderByAggregateInput
    _avg?: ServiceAvgOrderByAggregateInput
    _max?: ServiceMaxOrderByAggregateInput
    _min?: ServiceMinOrderByAggregateInput
    _sum?: ServiceSumOrderByAggregateInput
  }

  export type ServiceScalarWhereWithAggregatesInput = {
    AND?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    OR?: ServiceScalarWhereWithAggregatesInput[]
    NOT?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Service"> | string
    vendorId?: StringWithAggregatesFilter<"Service"> | string
    name?: StringWithAggregatesFilter<"Service"> | string
    description?: StringWithAggregatesFilter<"Service"> | string
    price?: FloatWithAggregatesFilter<"Service"> | number
    duration?: IntNullableWithAggregatesFilter<"Service"> | number | null
    maxCapacity?: IntNullableWithAggregatesFilter<"Service"> | number | null
    includes?: StringNullableListFilter<"Service">
    addOns?: JsonNullableWithAggregatesFilter<"Service">
    isActive?: BoolWithAggregatesFilter<"Service"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Service"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Service"> | Date | string
  }

  export type BookingWhereInput = {
    AND?: BookingWhereInput | BookingWhereInput[]
    OR?: BookingWhereInput[]
    NOT?: BookingWhereInput | BookingWhereInput[]
    id?: StringFilter<"Booking"> | string
    userId?: StringFilter<"Booking"> | string
    vendorId?: StringFilter<"Booking"> | string
    serviceId?: StringFilter<"Booking"> | string
    eventDate?: DateTimeFilter<"Booking"> | Date | string
    eventTime?: StringFilter<"Booking"> | string
    eventDuration?: IntFilter<"Booking"> | number
    guestCount?: IntNullableFilter<"Booking"> | number | null
    location?: StringNullableFilter<"Booking"> | string | null
    specialRequests?: StringNullableFilter<"Booking"> | string | null
    basePrice?: FloatFilter<"Booking"> | number
    additionalCosts?: FloatFilter<"Booking"> | number
    totalAmount?: FloatFilter<"Booking"> | number
    status?: EnumBookingStatusFilter<"Booking"> | $Enums.BookingStatus
    paymentStatus?: EnumPaymentStatusFilter<"Booking"> | $Enums.PaymentStatus
    requestedAt?: DateTimeFilter<"Booking"> | Date | string
    approvedAt?: DateTimeNullableFilter<"Booking"> | Date | string | null
    confirmedAt?: DateTimeNullableFilter<"Booking"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Booking"> | Date | string | null
    createdAt?: DateTimeFilter<"Booking"> | Date | string
    updatedAt?: DateTimeFilter<"Booking"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    vendor?: XOR<VendorRelationFilter, VendorWhereInput>
    service?: XOR<ServiceRelationFilter, ServiceWhereInput>
    payments?: PaymentListRelationFilter
    messages?: MessageListRelationFilter
  }

  export type BookingOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    vendorId?: SortOrder
    serviceId?: SortOrder
    eventDate?: SortOrder
    eventTime?: SortOrder
    eventDuration?: SortOrder
    guestCount?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    specialRequests?: SortOrderInput | SortOrder
    basePrice?: SortOrder
    additionalCosts?: SortOrder
    totalAmount?: SortOrder
    status?: SortOrder
    paymentStatus?: SortOrder
    requestedAt?: SortOrder
    approvedAt?: SortOrderInput | SortOrder
    confirmedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    vendor?: VendorOrderByWithRelationInput
    service?: ServiceOrderByWithRelationInput
    payments?: PaymentOrderByRelationAggregateInput
    messages?: MessageOrderByRelationAggregateInput
  }

  export type BookingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BookingWhereInput | BookingWhereInput[]
    OR?: BookingWhereInput[]
    NOT?: BookingWhereInput | BookingWhereInput[]
    userId?: StringFilter<"Booking"> | string
    vendorId?: StringFilter<"Booking"> | string
    serviceId?: StringFilter<"Booking"> | string
    eventDate?: DateTimeFilter<"Booking"> | Date | string
    eventTime?: StringFilter<"Booking"> | string
    eventDuration?: IntFilter<"Booking"> | number
    guestCount?: IntNullableFilter<"Booking"> | number | null
    location?: StringNullableFilter<"Booking"> | string | null
    specialRequests?: StringNullableFilter<"Booking"> | string | null
    basePrice?: FloatFilter<"Booking"> | number
    additionalCosts?: FloatFilter<"Booking"> | number
    totalAmount?: FloatFilter<"Booking"> | number
    status?: EnumBookingStatusFilter<"Booking"> | $Enums.BookingStatus
    paymentStatus?: EnumPaymentStatusFilter<"Booking"> | $Enums.PaymentStatus
    requestedAt?: DateTimeFilter<"Booking"> | Date | string
    approvedAt?: DateTimeNullableFilter<"Booking"> | Date | string | null
    confirmedAt?: DateTimeNullableFilter<"Booking"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Booking"> | Date | string | null
    createdAt?: DateTimeFilter<"Booking"> | Date | string
    updatedAt?: DateTimeFilter<"Booking"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    vendor?: XOR<VendorRelationFilter, VendorWhereInput>
    service?: XOR<ServiceRelationFilter, ServiceWhereInput>
    payments?: PaymentListRelationFilter
    messages?: MessageListRelationFilter
  }, "id">

  export type BookingOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    vendorId?: SortOrder
    serviceId?: SortOrder
    eventDate?: SortOrder
    eventTime?: SortOrder
    eventDuration?: SortOrder
    guestCount?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    specialRequests?: SortOrderInput | SortOrder
    basePrice?: SortOrder
    additionalCosts?: SortOrder
    totalAmount?: SortOrder
    status?: SortOrder
    paymentStatus?: SortOrder
    requestedAt?: SortOrder
    approvedAt?: SortOrderInput | SortOrder
    confirmedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BookingCountOrderByAggregateInput
    _avg?: BookingAvgOrderByAggregateInput
    _max?: BookingMaxOrderByAggregateInput
    _min?: BookingMinOrderByAggregateInput
    _sum?: BookingSumOrderByAggregateInput
  }

  export type BookingScalarWhereWithAggregatesInput = {
    AND?: BookingScalarWhereWithAggregatesInput | BookingScalarWhereWithAggregatesInput[]
    OR?: BookingScalarWhereWithAggregatesInput[]
    NOT?: BookingScalarWhereWithAggregatesInput | BookingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Booking"> | string
    userId?: StringWithAggregatesFilter<"Booking"> | string
    vendorId?: StringWithAggregatesFilter<"Booking"> | string
    serviceId?: StringWithAggregatesFilter<"Booking"> | string
    eventDate?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
    eventTime?: StringWithAggregatesFilter<"Booking"> | string
    eventDuration?: IntWithAggregatesFilter<"Booking"> | number
    guestCount?: IntNullableWithAggregatesFilter<"Booking"> | number | null
    location?: StringNullableWithAggregatesFilter<"Booking"> | string | null
    specialRequests?: StringNullableWithAggregatesFilter<"Booking"> | string | null
    basePrice?: FloatWithAggregatesFilter<"Booking"> | number
    additionalCosts?: FloatWithAggregatesFilter<"Booking"> | number
    totalAmount?: FloatWithAggregatesFilter<"Booking"> | number
    status?: EnumBookingStatusWithAggregatesFilter<"Booking"> | $Enums.BookingStatus
    paymentStatus?: EnumPaymentStatusWithAggregatesFilter<"Booking"> | $Enums.PaymentStatus
    requestedAt?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
    approvedAt?: DateTimeNullableWithAggregatesFilter<"Booking"> | Date | string | null
    confirmedAt?: DateTimeNullableWithAggregatesFilter<"Booking"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"Booking"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: StringFilter<"Payment"> | string
    bookingId?: StringFilter<"Payment"> | string
    amount?: FloatFilter<"Payment"> | number
    currency?: StringFilter<"Payment"> | string
    paymentMethod?: StringFilter<"Payment"> | string
    transactionId?: StringNullableFilter<"Payment"> | string | null
    gatewayResponse?: JsonNullableFilter<"Payment">
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    booking?: XOR<BookingRelationFilter, BookingWhereInput>
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    paymentMethod?: SortOrder
    transactionId?: SortOrderInput | SortOrder
    gatewayResponse?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    booking?: BookingOrderByWithRelationInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    bookingId?: StringFilter<"Payment"> | string
    amount?: FloatFilter<"Payment"> | number
    currency?: StringFilter<"Payment"> | string
    paymentMethod?: StringFilter<"Payment"> | string
    transactionId?: StringNullableFilter<"Payment"> | string | null
    gatewayResponse?: JsonNullableFilter<"Payment">
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    booking?: XOR<BookingRelationFilter, BookingWhereInput>
  }, "id">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    paymentMethod?: SortOrder
    transactionId?: SortOrderInput | SortOrder
    gatewayResponse?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Payment"> | string
    bookingId?: StringWithAggregatesFilter<"Payment"> | string
    amount?: FloatWithAggregatesFilter<"Payment"> | number
    currency?: StringWithAggregatesFilter<"Payment"> | string
    paymentMethod?: StringWithAggregatesFilter<"Payment"> | string
    transactionId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    gatewayResponse?: JsonNullableWithAggregatesFilter<"Payment">
    status?: EnumPaymentStatusWithAggregatesFilter<"Payment"> | $Enums.PaymentStatus
    createdAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
  }

  export type MessageWhereInput = {
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    id?: StringFilter<"Message"> | string
    senderId?: StringFilter<"Message"> | string
    receiverId?: StringFilter<"Message"> | string
    bookingId?: StringNullableFilter<"Message"> | string | null
    content?: StringFilter<"Message"> | string
    messageType?: StringFilter<"Message"> | string
    attachments?: StringNullableListFilter<"Message">
    isRead?: BoolFilter<"Message"> | boolean
    createdAt?: DateTimeFilter<"Message"> | Date | string
    sender?: XOR<UserRelationFilter, UserWhereInput>
    receiver?: XOR<UserRelationFilter, UserWhereInput>
    booking?: XOR<BookingNullableRelationFilter, BookingWhereInput> | null
  }

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    bookingId?: SortOrderInput | SortOrder
    content?: SortOrder
    messageType?: SortOrder
    attachments?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    sender?: UserOrderByWithRelationInput
    receiver?: UserOrderByWithRelationInput
    booking?: BookingOrderByWithRelationInput
  }

  export type MessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    senderId?: StringFilter<"Message"> | string
    receiverId?: StringFilter<"Message"> | string
    bookingId?: StringNullableFilter<"Message"> | string | null
    content?: StringFilter<"Message"> | string
    messageType?: StringFilter<"Message"> | string
    attachments?: StringNullableListFilter<"Message">
    isRead?: BoolFilter<"Message"> | boolean
    createdAt?: DateTimeFilter<"Message"> | Date | string
    sender?: XOR<UserRelationFilter, UserWhereInput>
    receiver?: XOR<UserRelationFilter, UserWhereInput>
    booking?: XOR<BookingNullableRelationFilter, BookingWhereInput> | null
  }, "id">

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    bookingId?: SortOrderInput | SortOrder
    content?: SortOrder
    messageType?: SortOrder
    attachments?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    _count?: MessageCountOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    OR?: MessageScalarWhereWithAggregatesInput[]
    NOT?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Message"> | string
    senderId?: StringWithAggregatesFilter<"Message"> | string
    receiverId?: StringWithAggregatesFilter<"Message"> | string
    bookingId?: StringNullableWithAggregatesFilter<"Message"> | string | null
    content?: StringWithAggregatesFilter<"Message"> | string
    messageType?: StringWithAggregatesFilter<"Message"> | string
    attachments?: StringNullableListFilter<"Message">
    isRead?: BoolWithAggregatesFilter<"Message"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
  }

  export type ChatSessionWhereInput = {
    AND?: ChatSessionWhereInput | ChatSessionWhereInput[]
    OR?: ChatSessionWhereInput[]
    NOT?: ChatSessionWhereInput | ChatSessionWhereInput[]
    id?: StringFilter<"ChatSession"> | string
    userId?: StringFilter<"ChatSession"> | string
    vendorId?: StringFilter<"ChatSession"> | string
    lastMessageAt?: DateTimeFilter<"ChatSession"> | Date | string
    isActive?: BoolFilter<"ChatSession"> | boolean
    createdAt?: DateTimeFilter<"ChatSession"> | Date | string
    updatedAt?: DateTimeFilter<"ChatSession"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    vendor?: XOR<VendorRelationFilter, VendorWhereInput>
  }

  export type ChatSessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    vendorId?: SortOrder
    lastMessageAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    vendor?: VendorOrderByWithRelationInput
  }

  export type ChatSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_vendorId?: ChatSessionUserIdVendorIdCompoundUniqueInput
    AND?: ChatSessionWhereInput | ChatSessionWhereInput[]
    OR?: ChatSessionWhereInput[]
    NOT?: ChatSessionWhereInput | ChatSessionWhereInput[]
    userId?: StringFilter<"ChatSession"> | string
    vendorId?: StringFilter<"ChatSession"> | string
    lastMessageAt?: DateTimeFilter<"ChatSession"> | Date | string
    isActive?: BoolFilter<"ChatSession"> | boolean
    createdAt?: DateTimeFilter<"ChatSession"> | Date | string
    updatedAt?: DateTimeFilter<"ChatSession"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    vendor?: XOR<VendorRelationFilter, VendorWhereInput>
  }, "id" | "userId_vendorId">

  export type ChatSessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    vendorId?: SortOrder
    lastMessageAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ChatSessionCountOrderByAggregateInput
    _max?: ChatSessionMaxOrderByAggregateInput
    _min?: ChatSessionMinOrderByAggregateInput
  }

  export type ChatSessionScalarWhereWithAggregatesInput = {
    AND?: ChatSessionScalarWhereWithAggregatesInput | ChatSessionScalarWhereWithAggregatesInput[]
    OR?: ChatSessionScalarWhereWithAggregatesInput[]
    NOT?: ChatSessionScalarWhereWithAggregatesInput | ChatSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChatSession"> | string
    userId?: StringWithAggregatesFilter<"ChatSession"> | string
    vendorId?: StringWithAggregatesFilter<"ChatSession"> | string
    lastMessageAt?: DateTimeWithAggregatesFilter<"ChatSession"> | Date | string
    isActive?: BoolWithAggregatesFilter<"ChatSession"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ChatSession"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ChatSession"> | Date | string
  }

  export type ReviewWhereInput = {
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    id?: StringFilter<"Review"> | string
    userId?: StringFilter<"Review"> | string
    vendorId?: StringFilter<"Review"> | string
    rating?: IntFilter<"Review"> | number
    comment?: StringNullableFilter<"Review"> | string | null
    createdAt?: DateTimeFilter<"Review"> | Date | string
    updatedAt?: DateTimeFilter<"Review"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    vendor?: XOR<VendorRelationFilter, VendorWhereInput>
  }

  export type ReviewOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    vendorId?: SortOrder
    rating?: SortOrder
    comment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    vendor?: VendorOrderByWithRelationInput
  }

  export type ReviewWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_vendorId?: ReviewUserIdVendorIdCompoundUniqueInput
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    userId?: StringFilter<"Review"> | string
    vendorId?: StringFilter<"Review"> | string
    rating?: IntFilter<"Review"> | number
    comment?: StringNullableFilter<"Review"> | string | null
    createdAt?: DateTimeFilter<"Review"> | Date | string
    updatedAt?: DateTimeFilter<"Review"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    vendor?: XOR<VendorRelationFilter, VendorWhereInput>
  }, "id" | "userId_vendorId">

  export type ReviewOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    vendorId?: SortOrder
    rating?: SortOrder
    comment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ReviewCountOrderByAggregateInput
    _avg?: ReviewAvgOrderByAggregateInput
    _max?: ReviewMaxOrderByAggregateInput
    _min?: ReviewMinOrderByAggregateInput
    _sum?: ReviewSumOrderByAggregateInput
  }

  export type ReviewScalarWhereWithAggregatesInput = {
    AND?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    OR?: ReviewScalarWhereWithAggregatesInput[]
    NOT?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Review"> | string
    userId?: StringWithAggregatesFilter<"Review"> | string
    vendorId?: StringWithAggregatesFilter<"Review"> | string
    rating?: IntWithAggregatesFilter<"Review"> | number
    comment?: StringNullableWithAggregatesFilter<"Review"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Review"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Review"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    userId?: StringWithAggregatesFilter<"Notification"> | string
    title?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    type?: StringWithAggregatesFilter<"Notification"> | string
    isRead?: BoolWithAggregatesFilter<"Notification"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type WeddingChecklistWhereInput = {
    AND?: WeddingChecklistWhereInput | WeddingChecklistWhereInput[]
    OR?: WeddingChecklistWhereInput[]
    NOT?: WeddingChecklistWhereInput | WeddingChecklistWhereInput[]
    id?: StringFilter<"WeddingChecklist"> | string
    userId?: StringFilter<"WeddingChecklist"> | string
    title?: StringFilter<"WeddingChecklist"> | string
    description?: StringNullableFilter<"WeddingChecklist"> | string | null
    category?: StringFilter<"WeddingChecklist"> | string
    isCompleted?: BoolFilter<"WeddingChecklist"> | boolean
    dueDate?: DateTimeNullableFilter<"WeddingChecklist"> | Date | string | null
    priority?: StringFilter<"WeddingChecklist"> | string
    createdAt?: DateTimeFilter<"WeddingChecklist"> | Date | string
    updatedAt?: DateTimeFilter<"WeddingChecklist"> | Date | string
  }

  export type WeddingChecklistOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    isCompleted?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WeddingChecklistWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WeddingChecklistWhereInput | WeddingChecklistWhereInput[]
    OR?: WeddingChecklistWhereInput[]
    NOT?: WeddingChecklistWhereInput | WeddingChecklistWhereInput[]
    userId?: StringFilter<"WeddingChecklist"> | string
    title?: StringFilter<"WeddingChecklist"> | string
    description?: StringNullableFilter<"WeddingChecklist"> | string | null
    category?: StringFilter<"WeddingChecklist"> | string
    isCompleted?: BoolFilter<"WeddingChecklist"> | boolean
    dueDate?: DateTimeNullableFilter<"WeddingChecklist"> | Date | string | null
    priority?: StringFilter<"WeddingChecklist"> | string
    createdAt?: DateTimeFilter<"WeddingChecklist"> | Date | string
    updatedAt?: DateTimeFilter<"WeddingChecklist"> | Date | string
  }, "id">

  export type WeddingChecklistOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    isCompleted?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WeddingChecklistCountOrderByAggregateInput
    _max?: WeddingChecklistMaxOrderByAggregateInput
    _min?: WeddingChecklistMinOrderByAggregateInput
  }

  export type WeddingChecklistScalarWhereWithAggregatesInput = {
    AND?: WeddingChecklistScalarWhereWithAggregatesInput | WeddingChecklistScalarWhereWithAggregatesInput[]
    OR?: WeddingChecklistScalarWhereWithAggregatesInput[]
    NOT?: WeddingChecklistScalarWhereWithAggregatesInput | WeddingChecklistScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WeddingChecklist"> | string
    userId?: StringWithAggregatesFilter<"WeddingChecklist"> | string
    title?: StringWithAggregatesFilter<"WeddingChecklist"> | string
    description?: StringNullableWithAggregatesFilter<"WeddingChecklist"> | string | null
    category?: StringWithAggregatesFilter<"WeddingChecklist"> | string
    isCompleted?: BoolWithAggregatesFilter<"WeddingChecklist"> | boolean
    dueDate?: DateTimeNullableWithAggregatesFilter<"WeddingChecklist"> | Date | string | null
    priority?: StringWithAggregatesFilter<"WeddingChecklist"> | string
    createdAt?: DateTimeWithAggregatesFilter<"WeddingChecklist"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WeddingChecklist"> | Date | string
  }

  export type AIConversationWhereInput = {
    AND?: AIConversationWhereInput | AIConversationWhereInput[]
    OR?: AIConversationWhereInput[]
    NOT?: AIConversationWhereInput | AIConversationWhereInput[]
    id?: StringFilter<"AIConversation"> | string
    userId?: StringFilter<"AIConversation"> | string
    messages?: JsonFilter<"AIConversation">
    context?: JsonNullableFilter<"AIConversation">
    createdAt?: DateTimeFilter<"AIConversation"> | Date | string
    updatedAt?: DateTimeFilter<"AIConversation"> | Date | string
  }

  export type AIConversationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    messages?: SortOrder
    context?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AIConversationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AIConversationWhereInput | AIConversationWhereInput[]
    OR?: AIConversationWhereInput[]
    NOT?: AIConversationWhereInput | AIConversationWhereInput[]
    userId?: StringFilter<"AIConversation"> | string
    messages?: JsonFilter<"AIConversation">
    context?: JsonNullableFilter<"AIConversation">
    createdAt?: DateTimeFilter<"AIConversation"> | Date | string
    updatedAt?: DateTimeFilter<"AIConversation"> | Date | string
  }, "id">

  export type AIConversationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    messages?: SortOrder
    context?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AIConversationCountOrderByAggregateInput
    _max?: AIConversationMaxOrderByAggregateInput
    _min?: AIConversationMinOrderByAggregateInput
  }

  export type AIConversationScalarWhereWithAggregatesInput = {
    AND?: AIConversationScalarWhereWithAggregatesInput | AIConversationScalarWhereWithAggregatesInput[]
    OR?: AIConversationScalarWhereWithAggregatesInput[]
    NOT?: AIConversationScalarWhereWithAggregatesInput | AIConversationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AIConversation"> | string
    userId?: StringWithAggregatesFilter<"AIConversation"> | string
    messages?: JsonWithAggregatesFilter<"AIConversation">
    context?: JsonNullableWithAggregatesFilter<"AIConversation">
    createdAt?: DateTimeWithAggregatesFilter<"AIConversation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AIConversation"> | Date | string
  }

  export type MatrimonialProfileWhereInput = {
    AND?: MatrimonialProfileWhereInput | MatrimonialProfileWhereInput[]
    OR?: MatrimonialProfileWhereInput[]
    NOT?: MatrimonialProfileWhereInput | MatrimonialProfileWhereInput[]
    id?: StringFilter<"MatrimonialProfile"> | string
    name?: StringFilter<"MatrimonialProfile"> | string
    email?: StringFilter<"MatrimonialProfile"> | string
    phone?: StringNullableFilter<"MatrimonialProfile"> | string | null
    gender?: EnumGenderFilter<"MatrimonialProfile"> | $Enums.Gender
    dateOfBirth?: DateTimeNullableFilter<"MatrimonialProfile"> | Date | string | null
    age?: IntNullableFilter<"MatrimonialProfile"> | number | null
    city?: StringFilter<"MatrimonialProfile"> | string
    profession?: StringFilter<"MatrimonialProfile"> | string
    education?: StringFilter<"MatrimonialProfile"> | string
    religion?: StringFilter<"MatrimonialProfile"> | string
    height?: StringNullableFilter<"MatrimonialProfile"> | string | null
    bio?: StringNullableFilter<"MatrimonialProfile"> | string | null
    interests?: StringNullableListFilter<"MatrimonialProfile">
    photos?: StringNullableListFilter<"MatrimonialProfile">
    familyBackground?: StringNullableFilter<"MatrimonialProfile"> | string | null
    partnerPreferences?: StringNullableFilter<"MatrimonialProfile"> | string | null
    isVerified?: BoolFilter<"MatrimonialProfile"> | boolean
    isOnline?: BoolFilter<"MatrimonialProfile"> | boolean
    lastSeen?: DateTimeNullableFilter<"MatrimonialProfile"> | Date | string | null
    compatibilityScore?: IntFilter<"MatrimonialProfile"> | number
    isInterested?: BoolFilter<"MatrimonialProfile"> | boolean
    isMatched?: BoolFilter<"MatrimonialProfile"> | boolean
    isBlocked?: BoolFilter<"MatrimonialProfile"> | boolean
    createdAt?: DateTimeFilter<"MatrimonialProfile"> | Date | string
    updatedAt?: DateTimeFilter<"MatrimonialProfile"> | Date | string
    sentMessages?: MatrimonialMessageListRelationFilter
    receivedMessages?: MatrimonialMessageListRelationFilter
  }

  export type MatrimonialProfileOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    gender?: SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    age?: SortOrderInput | SortOrder
    city?: SortOrder
    profession?: SortOrder
    education?: SortOrder
    religion?: SortOrder
    height?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    interests?: SortOrder
    photos?: SortOrder
    familyBackground?: SortOrderInput | SortOrder
    partnerPreferences?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    isOnline?: SortOrder
    lastSeen?: SortOrderInput | SortOrder
    compatibilityScore?: SortOrder
    isInterested?: SortOrder
    isMatched?: SortOrder
    isBlocked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sentMessages?: MatrimonialMessageOrderByRelationAggregateInput
    receivedMessages?: MatrimonialMessageOrderByRelationAggregateInput
  }

  export type MatrimonialProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: MatrimonialProfileWhereInput | MatrimonialProfileWhereInput[]
    OR?: MatrimonialProfileWhereInput[]
    NOT?: MatrimonialProfileWhereInput | MatrimonialProfileWhereInput[]
    name?: StringFilter<"MatrimonialProfile"> | string
    phone?: StringNullableFilter<"MatrimonialProfile"> | string | null
    gender?: EnumGenderFilter<"MatrimonialProfile"> | $Enums.Gender
    dateOfBirth?: DateTimeNullableFilter<"MatrimonialProfile"> | Date | string | null
    age?: IntNullableFilter<"MatrimonialProfile"> | number | null
    city?: StringFilter<"MatrimonialProfile"> | string
    profession?: StringFilter<"MatrimonialProfile"> | string
    education?: StringFilter<"MatrimonialProfile"> | string
    religion?: StringFilter<"MatrimonialProfile"> | string
    height?: StringNullableFilter<"MatrimonialProfile"> | string | null
    bio?: StringNullableFilter<"MatrimonialProfile"> | string | null
    interests?: StringNullableListFilter<"MatrimonialProfile">
    photos?: StringNullableListFilter<"MatrimonialProfile">
    familyBackground?: StringNullableFilter<"MatrimonialProfile"> | string | null
    partnerPreferences?: StringNullableFilter<"MatrimonialProfile"> | string | null
    isVerified?: BoolFilter<"MatrimonialProfile"> | boolean
    isOnline?: BoolFilter<"MatrimonialProfile"> | boolean
    lastSeen?: DateTimeNullableFilter<"MatrimonialProfile"> | Date | string | null
    compatibilityScore?: IntFilter<"MatrimonialProfile"> | number
    isInterested?: BoolFilter<"MatrimonialProfile"> | boolean
    isMatched?: BoolFilter<"MatrimonialProfile"> | boolean
    isBlocked?: BoolFilter<"MatrimonialProfile"> | boolean
    createdAt?: DateTimeFilter<"MatrimonialProfile"> | Date | string
    updatedAt?: DateTimeFilter<"MatrimonialProfile"> | Date | string
    sentMessages?: MatrimonialMessageListRelationFilter
    receivedMessages?: MatrimonialMessageListRelationFilter
  }, "id" | "email">

  export type MatrimonialProfileOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    gender?: SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    age?: SortOrderInput | SortOrder
    city?: SortOrder
    profession?: SortOrder
    education?: SortOrder
    religion?: SortOrder
    height?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    interests?: SortOrder
    photos?: SortOrder
    familyBackground?: SortOrderInput | SortOrder
    partnerPreferences?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    isOnline?: SortOrder
    lastSeen?: SortOrderInput | SortOrder
    compatibilityScore?: SortOrder
    isInterested?: SortOrder
    isMatched?: SortOrder
    isBlocked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MatrimonialProfileCountOrderByAggregateInput
    _avg?: MatrimonialProfileAvgOrderByAggregateInput
    _max?: MatrimonialProfileMaxOrderByAggregateInput
    _min?: MatrimonialProfileMinOrderByAggregateInput
    _sum?: MatrimonialProfileSumOrderByAggregateInput
  }

  export type MatrimonialProfileScalarWhereWithAggregatesInput = {
    AND?: MatrimonialProfileScalarWhereWithAggregatesInput | MatrimonialProfileScalarWhereWithAggregatesInput[]
    OR?: MatrimonialProfileScalarWhereWithAggregatesInput[]
    NOT?: MatrimonialProfileScalarWhereWithAggregatesInput | MatrimonialProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MatrimonialProfile"> | string
    name?: StringWithAggregatesFilter<"MatrimonialProfile"> | string
    email?: StringWithAggregatesFilter<"MatrimonialProfile"> | string
    phone?: StringNullableWithAggregatesFilter<"MatrimonialProfile"> | string | null
    gender?: EnumGenderWithAggregatesFilter<"MatrimonialProfile"> | $Enums.Gender
    dateOfBirth?: DateTimeNullableWithAggregatesFilter<"MatrimonialProfile"> | Date | string | null
    age?: IntNullableWithAggregatesFilter<"MatrimonialProfile"> | number | null
    city?: StringWithAggregatesFilter<"MatrimonialProfile"> | string
    profession?: StringWithAggregatesFilter<"MatrimonialProfile"> | string
    education?: StringWithAggregatesFilter<"MatrimonialProfile"> | string
    religion?: StringWithAggregatesFilter<"MatrimonialProfile"> | string
    height?: StringNullableWithAggregatesFilter<"MatrimonialProfile"> | string | null
    bio?: StringNullableWithAggregatesFilter<"MatrimonialProfile"> | string | null
    interests?: StringNullableListFilter<"MatrimonialProfile">
    photos?: StringNullableListFilter<"MatrimonialProfile">
    familyBackground?: StringNullableWithAggregatesFilter<"MatrimonialProfile"> | string | null
    partnerPreferences?: StringNullableWithAggregatesFilter<"MatrimonialProfile"> | string | null
    isVerified?: BoolWithAggregatesFilter<"MatrimonialProfile"> | boolean
    isOnline?: BoolWithAggregatesFilter<"MatrimonialProfile"> | boolean
    lastSeen?: DateTimeNullableWithAggregatesFilter<"MatrimonialProfile"> | Date | string | null
    compatibilityScore?: IntWithAggregatesFilter<"MatrimonialProfile"> | number
    isInterested?: BoolWithAggregatesFilter<"MatrimonialProfile"> | boolean
    isMatched?: BoolWithAggregatesFilter<"MatrimonialProfile"> | boolean
    isBlocked?: BoolWithAggregatesFilter<"MatrimonialProfile"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"MatrimonialProfile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MatrimonialProfile"> | Date | string
  }

  export type MatrimonialMessageWhereInput = {
    AND?: MatrimonialMessageWhereInput | MatrimonialMessageWhereInput[]
    OR?: MatrimonialMessageWhereInput[]
    NOT?: MatrimonialMessageWhereInput | MatrimonialMessageWhereInput[]
    id?: StringFilter<"MatrimonialMessage"> | string
    fromProfileId?: StringFilter<"MatrimonialMessage"> | string
    toProfileId?: StringFilter<"MatrimonialMessage"> | string
    content?: StringFilter<"MatrimonialMessage"> | string
    createdAt?: DateTimeFilter<"MatrimonialMessage"> | Date | string
    fromProfile?: XOR<MatrimonialProfileRelationFilter, MatrimonialProfileWhereInput>
    toProfile?: XOR<MatrimonialProfileRelationFilter, MatrimonialProfileWhereInput>
  }

  export type MatrimonialMessageOrderByWithRelationInput = {
    id?: SortOrder
    fromProfileId?: SortOrder
    toProfileId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    fromProfile?: MatrimonialProfileOrderByWithRelationInput
    toProfile?: MatrimonialProfileOrderByWithRelationInput
  }

  export type MatrimonialMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MatrimonialMessageWhereInput | MatrimonialMessageWhereInput[]
    OR?: MatrimonialMessageWhereInput[]
    NOT?: MatrimonialMessageWhereInput | MatrimonialMessageWhereInput[]
    fromProfileId?: StringFilter<"MatrimonialMessage"> | string
    toProfileId?: StringFilter<"MatrimonialMessage"> | string
    content?: StringFilter<"MatrimonialMessage"> | string
    createdAt?: DateTimeFilter<"MatrimonialMessage"> | Date | string
    fromProfile?: XOR<MatrimonialProfileRelationFilter, MatrimonialProfileWhereInput>
    toProfile?: XOR<MatrimonialProfileRelationFilter, MatrimonialProfileWhereInput>
  }, "id">

  export type MatrimonialMessageOrderByWithAggregationInput = {
    id?: SortOrder
    fromProfileId?: SortOrder
    toProfileId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    _count?: MatrimonialMessageCountOrderByAggregateInput
    _max?: MatrimonialMessageMaxOrderByAggregateInput
    _min?: MatrimonialMessageMinOrderByAggregateInput
  }

  export type MatrimonialMessageScalarWhereWithAggregatesInput = {
    AND?: MatrimonialMessageScalarWhereWithAggregatesInput | MatrimonialMessageScalarWhereWithAggregatesInput[]
    OR?: MatrimonialMessageScalarWhereWithAggregatesInput[]
    NOT?: MatrimonialMessageScalarWhereWithAggregatesInput | MatrimonialMessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MatrimonialMessage"> | string
    fromProfileId?: StringWithAggregatesFilter<"MatrimonialMessage"> | string
    toProfileId?: StringWithAggregatesFilter<"MatrimonialMessage"> | string
    content?: StringWithAggregatesFilter<"MatrimonialMessage"> | string
    createdAt?: DateTimeWithAggregatesFilter<"MatrimonialMessage"> | Date | string
  }

  export type VendorVerificationDocumentWhereInput = {
    AND?: VendorVerificationDocumentWhereInput | VendorVerificationDocumentWhereInput[]
    OR?: VendorVerificationDocumentWhereInput[]
    NOT?: VendorVerificationDocumentWhereInput | VendorVerificationDocumentWhereInput[]
    id?: StringFilter<"VendorVerificationDocument"> | string
    vendorId?: StringFilter<"VendorVerificationDocument"> | string
    documentType?: StringFilter<"VendorVerificationDocument"> | string
    documentTitle?: StringFilter<"VendorVerificationDocument"> | string
    documentContent?: StringFilter<"VendorVerificationDocument"> | string
    documentHash?: StringFilter<"VendorVerificationDocument"> | string
    signingToken?: StringFilter<"VendorVerificationDocument"> | string
    tokenExpiresAt?: DateTimeFilter<"VendorVerificationDocument"> | Date | string
    signedAt?: DateTimeNullableFilter<"VendorVerificationDocument"> | Date | string | null
    signatureData?: JsonNullableFilter<"VendorVerificationDocument">
    status?: StringFilter<"VendorVerificationDocument"> | string
    ipAddress?: StringNullableFilter<"VendorVerificationDocument"> | string | null
    userAgent?: StringNullableFilter<"VendorVerificationDocument"> | string | null
    reviewedBy?: StringNullableFilter<"VendorVerificationDocument"> | string | null
    reviewedAt?: DateTimeNullableFilter<"VendorVerificationDocument"> | Date | string | null
    reviewNotes?: StringNullableFilter<"VendorVerificationDocument"> | string | null
    createdAt?: DateTimeFilter<"VendorVerificationDocument"> | Date | string
    updatedAt?: DateTimeFilter<"VendorVerificationDocument"> | Date | string
    vendor?: XOR<VendorRelationFilter, VendorWhereInput>
  }

  export type VendorVerificationDocumentOrderByWithRelationInput = {
    id?: SortOrder
    vendorId?: SortOrder
    documentType?: SortOrder
    documentTitle?: SortOrder
    documentContent?: SortOrder
    documentHash?: SortOrder
    signingToken?: SortOrder
    tokenExpiresAt?: SortOrder
    signedAt?: SortOrderInput | SortOrder
    signatureData?: SortOrderInput | SortOrder
    status?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    reviewedBy?: SortOrderInput | SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    reviewNotes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    vendor?: VendorOrderByWithRelationInput
  }

  export type VendorVerificationDocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    signingToken?: string
    AND?: VendorVerificationDocumentWhereInput | VendorVerificationDocumentWhereInput[]
    OR?: VendorVerificationDocumentWhereInput[]
    NOT?: VendorVerificationDocumentWhereInput | VendorVerificationDocumentWhereInput[]
    vendorId?: StringFilter<"VendorVerificationDocument"> | string
    documentType?: StringFilter<"VendorVerificationDocument"> | string
    documentTitle?: StringFilter<"VendorVerificationDocument"> | string
    documentContent?: StringFilter<"VendorVerificationDocument"> | string
    documentHash?: StringFilter<"VendorVerificationDocument"> | string
    tokenExpiresAt?: DateTimeFilter<"VendorVerificationDocument"> | Date | string
    signedAt?: DateTimeNullableFilter<"VendorVerificationDocument"> | Date | string | null
    signatureData?: JsonNullableFilter<"VendorVerificationDocument">
    status?: StringFilter<"VendorVerificationDocument"> | string
    ipAddress?: StringNullableFilter<"VendorVerificationDocument"> | string | null
    userAgent?: StringNullableFilter<"VendorVerificationDocument"> | string | null
    reviewedBy?: StringNullableFilter<"VendorVerificationDocument"> | string | null
    reviewedAt?: DateTimeNullableFilter<"VendorVerificationDocument"> | Date | string | null
    reviewNotes?: StringNullableFilter<"VendorVerificationDocument"> | string | null
    createdAt?: DateTimeFilter<"VendorVerificationDocument"> | Date | string
    updatedAt?: DateTimeFilter<"VendorVerificationDocument"> | Date | string
    vendor?: XOR<VendorRelationFilter, VendorWhereInput>
  }, "id" | "signingToken">

  export type VendorVerificationDocumentOrderByWithAggregationInput = {
    id?: SortOrder
    vendorId?: SortOrder
    documentType?: SortOrder
    documentTitle?: SortOrder
    documentContent?: SortOrder
    documentHash?: SortOrder
    signingToken?: SortOrder
    tokenExpiresAt?: SortOrder
    signedAt?: SortOrderInput | SortOrder
    signatureData?: SortOrderInput | SortOrder
    status?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    reviewedBy?: SortOrderInput | SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    reviewNotes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VendorVerificationDocumentCountOrderByAggregateInput
    _max?: VendorVerificationDocumentMaxOrderByAggregateInput
    _min?: VendorVerificationDocumentMinOrderByAggregateInput
  }

  export type VendorVerificationDocumentScalarWhereWithAggregatesInput = {
    AND?: VendorVerificationDocumentScalarWhereWithAggregatesInput | VendorVerificationDocumentScalarWhereWithAggregatesInput[]
    OR?: VendorVerificationDocumentScalarWhereWithAggregatesInput[]
    NOT?: VendorVerificationDocumentScalarWhereWithAggregatesInput | VendorVerificationDocumentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VendorVerificationDocument"> | string
    vendorId?: StringWithAggregatesFilter<"VendorVerificationDocument"> | string
    documentType?: StringWithAggregatesFilter<"VendorVerificationDocument"> | string
    documentTitle?: StringWithAggregatesFilter<"VendorVerificationDocument"> | string
    documentContent?: StringWithAggregatesFilter<"VendorVerificationDocument"> | string
    documentHash?: StringWithAggregatesFilter<"VendorVerificationDocument"> | string
    signingToken?: StringWithAggregatesFilter<"VendorVerificationDocument"> | string
    tokenExpiresAt?: DateTimeWithAggregatesFilter<"VendorVerificationDocument"> | Date | string
    signedAt?: DateTimeNullableWithAggregatesFilter<"VendorVerificationDocument"> | Date | string | null
    signatureData?: JsonNullableWithAggregatesFilter<"VendorVerificationDocument">
    status?: StringWithAggregatesFilter<"VendorVerificationDocument"> | string
    ipAddress?: StringNullableWithAggregatesFilter<"VendorVerificationDocument"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"VendorVerificationDocument"> | string | null
    reviewedBy?: StringNullableWithAggregatesFilter<"VendorVerificationDocument"> | string | null
    reviewedAt?: DateTimeNullableWithAggregatesFilter<"VendorVerificationDocument"> | Date | string | null
    reviewNotes?: StringNullableWithAggregatesFilter<"VendorVerificationDocument"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"VendorVerificationDocument"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"VendorVerificationDocument"> | Date | string
  }

  export type VendorDynamicFieldWhereInput = {
    AND?: VendorDynamicFieldWhereInput | VendorDynamicFieldWhereInput[]
    OR?: VendorDynamicFieldWhereInput[]
    NOT?: VendorDynamicFieldWhereInput | VendorDynamicFieldWhereInput[]
    id?: StringFilter<"VendorDynamicField"> | string
    vendorId?: StringFilter<"VendorDynamicField"> | string
    fieldName?: StringFilter<"VendorDynamicField"> | string
    fieldLabel?: StringFilter<"VendorDynamicField"> | string
    fieldType?: StringFilter<"VendorDynamicField"> | string
    fieldOptions?: StringNullableListFilter<"VendorDynamicField">
    fieldValue?: StringNullableFilter<"VendorDynamicField"> | string | null
    isRequired?: BoolFilter<"VendorDynamicField"> | boolean
    displayOrder?: IntFilter<"VendorDynamicField"> | number
    createdAt?: DateTimeFilter<"VendorDynamicField"> | Date | string
    updatedAt?: DateTimeFilter<"VendorDynamicField"> | Date | string
    vendor?: XOR<VendorRelationFilter, VendorWhereInput>
  }

  export type VendorDynamicFieldOrderByWithRelationInput = {
    id?: SortOrder
    vendorId?: SortOrder
    fieldName?: SortOrder
    fieldLabel?: SortOrder
    fieldType?: SortOrder
    fieldOptions?: SortOrder
    fieldValue?: SortOrderInput | SortOrder
    isRequired?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    vendor?: VendorOrderByWithRelationInput
  }

  export type VendorDynamicFieldWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VendorDynamicFieldWhereInput | VendorDynamicFieldWhereInput[]
    OR?: VendorDynamicFieldWhereInput[]
    NOT?: VendorDynamicFieldWhereInput | VendorDynamicFieldWhereInput[]
    vendorId?: StringFilter<"VendorDynamicField"> | string
    fieldName?: StringFilter<"VendorDynamicField"> | string
    fieldLabel?: StringFilter<"VendorDynamicField"> | string
    fieldType?: StringFilter<"VendorDynamicField"> | string
    fieldOptions?: StringNullableListFilter<"VendorDynamicField">
    fieldValue?: StringNullableFilter<"VendorDynamicField"> | string | null
    isRequired?: BoolFilter<"VendorDynamicField"> | boolean
    displayOrder?: IntFilter<"VendorDynamicField"> | number
    createdAt?: DateTimeFilter<"VendorDynamicField"> | Date | string
    updatedAt?: DateTimeFilter<"VendorDynamicField"> | Date | string
    vendor?: XOR<VendorRelationFilter, VendorWhereInput>
  }, "id">

  export type VendorDynamicFieldOrderByWithAggregationInput = {
    id?: SortOrder
    vendorId?: SortOrder
    fieldName?: SortOrder
    fieldLabel?: SortOrder
    fieldType?: SortOrder
    fieldOptions?: SortOrder
    fieldValue?: SortOrderInput | SortOrder
    isRequired?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VendorDynamicFieldCountOrderByAggregateInput
    _avg?: VendorDynamicFieldAvgOrderByAggregateInput
    _max?: VendorDynamicFieldMaxOrderByAggregateInput
    _min?: VendorDynamicFieldMinOrderByAggregateInput
    _sum?: VendorDynamicFieldSumOrderByAggregateInput
  }

  export type VendorDynamicFieldScalarWhereWithAggregatesInput = {
    AND?: VendorDynamicFieldScalarWhereWithAggregatesInput | VendorDynamicFieldScalarWhereWithAggregatesInput[]
    OR?: VendorDynamicFieldScalarWhereWithAggregatesInput[]
    NOT?: VendorDynamicFieldScalarWhereWithAggregatesInput | VendorDynamicFieldScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VendorDynamicField"> | string
    vendorId?: StringWithAggregatesFilter<"VendorDynamicField"> | string
    fieldName?: StringWithAggregatesFilter<"VendorDynamicField"> | string
    fieldLabel?: StringWithAggregatesFilter<"VendorDynamicField"> | string
    fieldType?: StringWithAggregatesFilter<"VendorDynamicField"> | string
    fieldOptions?: StringNullableListFilter<"VendorDynamicField">
    fieldValue?: StringNullableWithAggregatesFilter<"VendorDynamicField"> | string | null
    isRequired?: BoolWithAggregatesFilter<"VendorDynamicField"> | boolean
    displayOrder?: IntWithAggregatesFilter<"VendorDynamicField"> | number
    createdAt?: DateTimeWithAggregatesFilter<"VendorDynamicField"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"VendorDynamicField"> | Date | string
  }

  export type PackageDynamicFieldWhereInput = {
    AND?: PackageDynamicFieldWhereInput | PackageDynamicFieldWhereInput[]
    OR?: PackageDynamicFieldWhereInput[]
    NOT?: PackageDynamicFieldWhereInput | PackageDynamicFieldWhereInput[]
    id?: StringFilter<"PackageDynamicField"> | string
    packageId?: StringFilter<"PackageDynamicField"> | string
    fieldName?: StringFilter<"PackageDynamicField"> | string
    fieldLabel?: StringFilter<"PackageDynamicField"> | string
    fieldType?: StringFilter<"PackageDynamicField"> | string
    fieldOptions?: StringNullableListFilter<"PackageDynamicField">
    fieldValue?: StringNullableFilter<"PackageDynamicField"> | string | null
    isRequired?: BoolFilter<"PackageDynamicField"> | boolean
    displayOrder?: IntFilter<"PackageDynamicField"> | number
    createdAt?: DateTimeFilter<"PackageDynamicField"> | Date | string
    updatedAt?: DateTimeFilter<"PackageDynamicField"> | Date | string
  }

  export type PackageDynamicFieldOrderByWithRelationInput = {
    id?: SortOrder
    packageId?: SortOrder
    fieldName?: SortOrder
    fieldLabel?: SortOrder
    fieldType?: SortOrder
    fieldOptions?: SortOrder
    fieldValue?: SortOrderInput | SortOrder
    isRequired?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PackageDynamicFieldWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PackageDynamicFieldWhereInput | PackageDynamicFieldWhereInput[]
    OR?: PackageDynamicFieldWhereInput[]
    NOT?: PackageDynamicFieldWhereInput | PackageDynamicFieldWhereInput[]
    packageId?: StringFilter<"PackageDynamicField"> | string
    fieldName?: StringFilter<"PackageDynamicField"> | string
    fieldLabel?: StringFilter<"PackageDynamicField"> | string
    fieldType?: StringFilter<"PackageDynamicField"> | string
    fieldOptions?: StringNullableListFilter<"PackageDynamicField">
    fieldValue?: StringNullableFilter<"PackageDynamicField"> | string | null
    isRequired?: BoolFilter<"PackageDynamicField"> | boolean
    displayOrder?: IntFilter<"PackageDynamicField"> | number
    createdAt?: DateTimeFilter<"PackageDynamicField"> | Date | string
    updatedAt?: DateTimeFilter<"PackageDynamicField"> | Date | string
  }, "id">

  export type PackageDynamicFieldOrderByWithAggregationInput = {
    id?: SortOrder
    packageId?: SortOrder
    fieldName?: SortOrder
    fieldLabel?: SortOrder
    fieldType?: SortOrder
    fieldOptions?: SortOrder
    fieldValue?: SortOrderInput | SortOrder
    isRequired?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PackageDynamicFieldCountOrderByAggregateInput
    _avg?: PackageDynamicFieldAvgOrderByAggregateInput
    _max?: PackageDynamicFieldMaxOrderByAggregateInput
    _min?: PackageDynamicFieldMinOrderByAggregateInput
    _sum?: PackageDynamicFieldSumOrderByAggregateInput
  }

  export type PackageDynamicFieldScalarWhereWithAggregatesInput = {
    AND?: PackageDynamicFieldScalarWhereWithAggregatesInput | PackageDynamicFieldScalarWhereWithAggregatesInput[]
    OR?: PackageDynamicFieldScalarWhereWithAggregatesInput[]
    NOT?: PackageDynamicFieldScalarWhereWithAggregatesInput | PackageDynamicFieldScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PackageDynamicField"> | string
    packageId?: StringWithAggregatesFilter<"PackageDynamicField"> | string
    fieldName?: StringWithAggregatesFilter<"PackageDynamicField"> | string
    fieldLabel?: StringWithAggregatesFilter<"PackageDynamicField"> | string
    fieldType?: StringWithAggregatesFilter<"PackageDynamicField"> | string
    fieldOptions?: StringNullableListFilter<"PackageDynamicField">
    fieldValue?: StringNullableWithAggregatesFilter<"PackageDynamicField"> | string | null
    isRequired?: BoolWithAggregatesFilter<"PackageDynamicField"> | boolean
    displayOrder?: IntWithAggregatesFilter<"PackageDynamicField"> | number
    createdAt?: DateTimeWithAggregatesFilter<"PackageDynamicField"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PackageDynamicField"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isVerified?: boolean
    profileImage?: string | null
    weddingDate?: Date | string | null
    budget?: number | null
    location?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    chatSessions?: ChatSessionCreateNestedManyWithoutUserInput
    vendor?: VendorCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isVerified?: boolean
    profileImage?: string | null
    weddingDate?: Date | string | null
    budget?: number | null
    location?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    chatSessions?: ChatSessionUncheckedCreateNestedManyWithoutUserInput
    vendor?: VendorUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    weddingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    chatSessions?: ChatSessionUpdateManyWithoutUserNestedInput
    vendor?: VendorUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    weddingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    chatSessions?: ChatSessionUncheckedUpdateManyWithoutUserNestedInput
    vendor?: VendorUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isVerified?: boolean
    profileImage?: string | null
    weddingDate?: Date | string | null
    budget?: number | null
    location?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    weddingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    weddingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorCreateInput = {
    id?: string
    businessName: string
    category: $Enums.VendorCategory
    description: string
    location: string
    phone: string
    email: string
    website?: string | null
    experience?: number
    rating?: number
    totalReviews?: number
    isVerified?: boolean
    isActive?: boolean
    verificationStatus?: $Enums.VerificationStatus
    documentSignedAt?: Date | string | null
    verificationNotes?: string | null
    basePrice?: number | null
    priceRange?: string | null
    profileImage?: string | null
    gallery?: VendorCreategalleryInput | string[]
    availability?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutVendorInput
    bookings?: BookingCreateNestedManyWithoutVendorInput
    services?: ServiceCreateNestedManyWithoutVendorInput
    reviews?: ReviewCreateNestedManyWithoutVendorInput
    chatSessions?: ChatSessionCreateNestedManyWithoutVendorInput
    verificationDocuments?: VendorVerificationDocumentCreateNestedManyWithoutVendorInput
    dynamicFields?: VendorDynamicFieldCreateNestedManyWithoutVendorInput
  }

  export type VendorUncheckedCreateInput = {
    id?: string
    userId: string
    businessName: string
    category: $Enums.VendorCategory
    description: string
    location: string
    phone: string
    email: string
    website?: string | null
    experience?: number
    rating?: number
    totalReviews?: number
    isVerified?: boolean
    isActive?: boolean
    verificationStatus?: $Enums.VerificationStatus
    documentSignedAt?: Date | string | null
    verificationNotes?: string | null
    basePrice?: number | null
    priceRange?: string | null
    profileImage?: string | null
    gallery?: VendorCreategalleryInput | string[]
    availability?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutVendorInput
    services?: ServiceUncheckedCreateNestedManyWithoutVendorInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutVendorInput
    chatSessions?: ChatSessionUncheckedCreateNestedManyWithoutVendorInput
    verificationDocuments?: VendorVerificationDocumentUncheckedCreateNestedManyWithoutVendorInput
    dynamicFields?: VendorDynamicFieldUncheckedCreateNestedManyWithoutVendorInput
  }

  export type VendorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessName?: StringFieldUpdateOperationsInput | string
    category?: EnumVendorCategoryFieldUpdateOperationsInput | $Enums.VendorCategory
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: IntFieldUpdateOperationsInput | number
    rating?: FloatFieldUpdateOperationsInput | number
    totalReviews?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    documentSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    priceRange?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    gallery?: VendorUpdategalleryInput | string[]
    availability?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutVendorNestedInput
    bookings?: BookingUpdateManyWithoutVendorNestedInput
    services?: ServiceUpdateManyWithoutVendorNestedInput
    reviews?: ReviewUpdateManyWithoutVendorNestedInput
    chatSessions?: ChatSessionUpdateManyWithoutVendorNestedInput
    verificationDocuments?: VendorVerificationDocumentUpdateManyWithoutVendorNestedInput
    dynamicFields?: VendorDynamicFieldUpdateManyWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    businessName?: StringFieldUpdateOperationsInput | string
    category?: EnumVendorCategoryFieldUpdateOperationsInput | $Enums.VendorCategory
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: IntFieldUpdateOperationsInput | number
    rating?: FloatFieldUpdateOperationsInput | number
    totalReviews?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    documentSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    priceRange?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    gallery?: VendorUpdategalleryInput | string[]
    availability?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutVendorNestedInput
    services?: ServiceUncheckedUpdateManyWithoutVendorNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutVendorNestedInput
    chatSessions?: ChatSessionUncheckedUpdateManyWithoutVendorNestedInput
    verificationDocuments?: VendorVerificationDocumentUncheckedUpdateManyWithoutVendorNestedInput
    dynamicFields?: VendorDynamicFieldUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type VendorCreateManyInput = {
    id?: string
    userId: string
    businessName: string
    category: $Enums.VendorCategory
    description: string
    location: string
    phone: string
    email: string
    website?: string | null
    experience?: number
    rating?: number
    totalReviews?: number
    isVerified?: boolean
    isActive?: boolean
    verificationStatus?: $Enums.VerificationStatus
    documentSignedAt?: Date | string | null
    verificationNotes?: string | null
    basePrice?: number | null
    priceRange?: string | null
    profileImage?: string | null
    gallery?: VendorCreategalleryInput | string[]
    availability?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VendorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessName?: StringFieldUpdateOperationsInput | string
    category?: EnumVendorCategoryFieldUpdateOperationsInput | $Enums.VendorCategory
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: IntFieldUpdateOperationsInput | number
    rating?: FloatFieldUpdateOperationsInput | number
    totalReviews?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    documentSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    priceRange?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    gallery?: VendorUpdategalleryInput | string[]
    availability?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    businessName?: StringFieldUpdateOperationsInput | string
    category?: EnumVendorCategoryFieldUpdateOperationsInput | $Enums.VendorCategory
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: IntFieldUpdateOperationsInput | number
    rating?: FloatFieldUpdateOperationsInput | number
    totalReviews?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    documentSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    priceRange?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    gallery?: VendorUpdategalleryInput | string[]
    availability?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceCreateInput = {
    id?: string
    name: string
    description: string
    price: number
    duration?: number | null
    maxCapacity?: number | null
    includes?: ServiceCreateincludesInput | string[]
    addOns?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    vendor: VendorCreateNestedOneWithoutServicesInput
    bookings?: BookingCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateInput = {
    id?: string
    vendorId: string
    name: string
    description: string
    price: number
    duration?: number | null
    maxCapacity?: number | null
    includes?: ServiceCreateincludesInput | string[]
    addOns?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    maxCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    includes?: ServiceUpdateincludesInput | string[]
    addOns?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneRequiredWithoutServicesNestedInput
    bookings?: BookingUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    maxCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    includes?: ServiceUpdateincludesInput | string[]
    addOns?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceCreateManyInput = {
    id?: string
    vendorId: string
    name: string
    description: string
    price: number
    duration?: number | null
    maxCapacity?: number | null
    includes?: ServiceCreateincludesInput | string[]
    addOns?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    maxCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    includes?: ServiceUpdateincludesInput | string[]
    addOns?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    maxCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    includes?: ServiceUpdateincludesInput | string[]
    addOns?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingCreateInput = {
    id?: string
    eventDate: Date | string
    eventTime: string
    eventDuration: number
    guestCount?: number | null
    location?: string | null
    specialRequests?: string | null
    basePrice: number
    additionalCosts?: number
    totalAmount: number
    status?: $Enums.BookingStatus
    paymentStatus?: $Enums.PaymentStatus
    requestedAt?: Date | string
    approvedAt?: Date | string | null
    confirmedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutBookingsInput
    vendor: VendorCreateNestedOneWithoutBookingsInput
    service: ServiceCreateNestedOneWithoutBookingsInput
    payments?: PaymentCreateNestedManyWithoutBookingInput
    messages?: MessageCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateInput = {
    id?: string
    userId: string
    vendorId: string
    serviceId: string
    eventDate: Date | string
    eventTime: string
    eventDuration: number
    guestCount?: number | null
    location?: string | null
    specialRequests?: string | null
    basePrice: number
    additionalCosts?: number
    totalAmount: number
    status?: $Enums.BookingStatus
    paymentStatus?: $Enums.PaymentStatus
    requestedAt?: Date | string
    approvedAt?: Date | string | null
    confirmedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutBookingInput
    messages?: MessageUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    eventTime?: StringFieldUpdateOperationsInput | string
    eventDuration?: IntFieldUpdateOperationsInput | number
    guestCount?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    additionalCosts?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBookingsNestedInput
    vendor?: VendorUpdateOneRequiredWithoutBookingsNestedInput
    service?: ServiceUpdateOneRequiredWithoutBookingsNestedInput
    payments?: PaymentUpdateManyWithoutBookingNestedInput
    messages?: MessageUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    eventTime?: StringFieldUpdateOperationsInput | string
    eventDuration?: IntFieldUpdateOperationsInput | number
    guestCount?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    additionalCosts?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutBookingNestedInput
    messages?: MessageUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type BookingCreateManyInput = {
    id?: string
    userId: string
    vendorId: string
    serviceId: string
    eventDate: Date | string
    eventTime: string
    eventDuration: number
    guestCount?: number | null
    location?: string | null
    specialRequests?: string | null
    basePrice: number
    additionalCosts?: number
    totalAmount: number
    status?: $Enums.BookingStatus
    paymentStatus?: $Enums.PaymentStatus
    requestedAt?: Date | string
    approvedAt?: Date | string | null
    confirmedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    eventTime?: StringFieldUpdateOperationsInput | string
    eventDuration?: IntFieldUpdateOperationsInput | number
    guestCount?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    additionalCosts?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    eventTime?: StringFieldUpdateOperationsInput | string
    eventDuration?: IntFieldUpdateOperationsInput | number
    guestCount?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    additionalCosts?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateInput = {
    id?: string
    amount: number
    currency?: string
    paymentMethod: string
    transactionId?: string | null
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.PaymentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    booking: BookingCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: string
    bookingId: string
    amount: number
    currency?: string
    paymentMethod: string
    transactionId?: string | null
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.PaymentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateManyInput = {
    id?: string
    bookingId: string
    amount: number
    currency?: string
    paymentMethod: string
    transactionId?: string | null
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.PaymentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateInput = {
    id?: string
    content: string
    messageType?: string
    attachments?: MessageCreateattachmentsInput | string[]
    isRead?: boolean
    createdAt?: Date | string
    sender: UserCreateNestedOneWithoutSentMessagesInput
    receiver: UserCreateNestedOneWithoutReceivedMessagesInput
    booking?: BookingCreateNestedOneWithoutMessagesInput
  }

  export type MessageUncheckedCreateInput = {
    id?: string
    senderId: string
    receiverId: string
    bookingId?: string | null
    content: string
    messageType?: string
    attachments?: MessageCreateattachmentsInput | string[]
    isRead?: boolean
    createdAt?: Date | string
  }

  export type MessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    messageType?: StringFieldUpdateOperationsInput | string
    attachments?: MessageUpdateattachmentsInput | string[]
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutSentMessagesNestedInput
    receiver?: UserUpdateOneRequiredWithoutReceivedMessagesNestedInput
    booking?: BookingUpdateOneWithoutMessagesNestedInput
  }

  export type MessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    messageType?: StringFieldUpdateOperationsInput | string
    attachments?: MessageUpdateattachmentsInput | string[]
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateManyInput = {
    id?: string
    senderId: string
    receiverId: string
    bookingId?: string | null
    content: string
    messageType?: string
    attachments?: MessageCreateattachmentsInput | string[]
    isRead?: boolean
    createdAt?: Date | string
  }

  export type MessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    messageType?: StringFieldUpdateOperationsInput | string
    attachments?: MessageUpdateattachmentsInput | string[]
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    messageType?: StringFieldUpdateOperationsInput | string
    attachments?: MessageUpdateattachmentsInput | string[]
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatSessionCreateInput = {
    id?: string
    lastMessageAt?: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutChatSessionsInput
    vendor: VendorCreateNestedOneWithoutChatSessionsInput
  }

  export type ChatSessionUncheckedCreateInput = {
    id?: string
    userId: string
    vendorId: string
    lastMessageAt?: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChatSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    lastMessageAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutChatSessionsNestedInput
    vendor?: VendorUpdateOneRequiredWithoutChatSessionsNestedInput
  }

  export type ChatSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    lastMessageAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatSessionCreateManyInput = {
    id?: string
    userId: string
    vendorId: string
    lastMessageAt?: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChatSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    lastMessageAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    lastMessageAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewCreateInput = {
    id?: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutReviewsInput
    vendor: VendorCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateInput = {
    id?: string
    userId: string
    vendorId: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutReviewsNestedInput
    vendor?: VendorUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type ReviewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewCreateManyInput = {
    id?: string
    userId: string
    vendorId: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    title: string
    message: string
    type: string
    isRead?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    userId: string
    title: string
    message: string
    type: string
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    userId: string
    title: string
    message: string
    type: string
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeddingChecklistCreateInput = {
    id?: string
    userId: string
    title: string
    description?: string | null
    category: string
    isCompleted?: boolean
    dueDate?: Date | string | null
    priority?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WeddingChecklistUncheckedCreateInput = {
    id?: string
    userId: string
    title: string
    description?: string | null
    category: string
    isCompleted?: boolean
    dueDate?: Date | string | null
    priority?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WeddingChecklistUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priority?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeddingChecklistUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priority?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeddingChecklistCreateManyInput = {
    id?: string
    userId: string
    title: string
    description?: string | null
    category: string
    isCompleted?: boolean
    dueDate?: Date | string | null
    priority?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WeddingChecklistUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priority?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeddingChecklistUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priority?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIConversationCreateInput = {
    id?: string
    userId: string
    messages: JsonNullValueInput | InputJsonValue
    context?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AIConversationUncheckedCreateInput = {
    id?: string
    userId: string
    messages: JsonNullValueInput | InputJsonValue
    context?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AIConversationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    messages?: JsonNullValueInput | InputJsonValue
    context?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIConversationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    messages?: JsonNullValueInput | InputJsonValue
    context?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIConversationCreateManyInput = {
    id?: string
    userId: string
    messages: JsonNullValueInput | InputJsonValue
    context?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AIConversationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    messages?: JsonNullValueInput | InputJsonValue
    context?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIConversationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    messages?: JsonNullValueInput | InputJsonValue
    context?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatrimonialProfileCreateInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    gender: $Enums.Gender
    dateOfBirth?: Date | string | null
    age?: number | null
    city: string
    profession: string
    education: string
    religion: string
    height?: string | null
    bio?: string | null
    interests?: MatrimonialProfileCreateinterestsInput | string[]
    photos?: MatrimonialProfileCreatephotosInput | string[]
    familyBackground?: string | null
    partnerPreferences?: string | null
    isVerified?: boolean
    isOnline?: boolean
    lastSeen?: Date | string | null
    compatibilityScore?: number
    isInterested?: boolean
    isMatched?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sentMessages?: MatrimonialMessageCreateNestedManyWithoutFromProfileInput
    receivedMessages?: MatrimonialMessageCreateNestedManyWithoutToProfileInput
  }

  export type MatrimonialProfileUncheckedCreateInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    gender: $Enums.Gender
    dateOfBirth?: Date | string | null
    age?: number | null
    city: string
    profession: string
    education: string
    religion: string
    height?: string | null
    bio?: string | null
    interests?: MatrimonialProfileCreateinterestsInput | string[]
    photos?: MatrimonialProfileCreatephotosInput | string[]
    familyBackground?: string | null
    partnerPreferences?: string | null
    isVerified?: boolean
    isOnline?: boolean
    lastSeen?: Date | string | null
    compatibilityScore?: number
    isInterested?: boolean
    isMatched?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sentMessages?: MatrimonialMessageUncheckedCreateNestedManyWithoutFromProfileInput
    receivedMessages?: MatrimonialMessageUncheckedCreateNestedManyWithoutToProfileInput
  }

  export type MatrimonialProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    city?: StringFieldUpdateOperationsInput | string
    profession?: StringFieldUpdateOperationsInput | string
    education?: StringFieldUpdateOperationsInput | string
    religion?: StringFieldUpdateOperationsInput | string
    height?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: MatrimonialProfileUpdateinterestsInput | string[]
    photos?: MatrimonialProfileUpdatephotosInput | string[]
    familyBackground?: NullableStringFieldUpdateOperationsInput | string | null
    partnerPreferences?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    compatibilityScore?: IntFieldUpdateOperationsInput | number
    isInterested?: BoolFieldUpdateOperationsInput | boolean
    isMatched?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentMessages?: MatrimonialMessageUpdateManyWithoutFromProfileNestedInput
    receivedMessages?: MatrimonialMessageUpdateManyWithoutToProfileNestedInput
  }

  export type MatrimonialProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    city?: StringFieldUpdateOperationsInput | string
    profession?: StringFieldUpdateOperationsInput | string
    education?: StringFieldUpdateOperationsInput | string
    religion?: StringFieldUpdateOperationsInput | string
    height?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: MatrimonialProfileUpdateinterestsInput | string[]
    photos?: MatrimonialProfileUpdatephotosInput | string[]
    familyBackground?: NullableStringFieldUpdateOperationsInput | string | null
    partnerPreferences?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    compatibilityScore?: IntFieldUpdateOperationsInput | number
    isInterested?: BoolFieldUpdateOperationsInput | boolean
    isMatched?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentMessages?: MatrimonialMessageUncheckedUpdateManyWithoutFromProfileNestedInput
    receivedMessages?: MatrimonialMessageUncheckedUpdateManyWithoutToProfileNestedInput
  }

  export type MatrimonialProfileCreateManyInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    gender: $Enums.Gender
    dateOfBirth?: Date | string | null
    age?: number | null
    city: string
    profession: string
    education: string
    religion: string
    height?: string | null
    bio?: string | null
    interests?: MatrimonialProfileCreateinterestsInput | string[]
    photos?: MatrimonialProfileCreatephotosInput | string[]
    familyBackground?: string | null
    partnerPreferences?: string | null
    isVerified?: boolean
    isOnline?: boolean
    lastSeen?: Date | string | null
    compatibilityScore?: number
    isInterested?: boolean
    isMatched?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MatrimonialProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    city?: StringFieldUpdateOperationsInput | string
    profession?: StringFieldUpdateOperationsInput | string
    education?: StringFieldUpdateOperationsInput | string
    religion?: StringFieldUpdateOperationsInput | string
    height?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: MatrimonialProfileUpdateinterestsInput | string[]
    photos?: MatrimonialProfileUpdatephotosInput | string[]
    familyBackground?: NullableStringFieldUpdateOperationsInput | string | null
    partnerPreferences?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    compatibilityScore?: IntFieldUpdateOperationsInput | number
    isInterested?: BoolFieldUpdateOperationsInput | boolean
    isMatched?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatrimonialProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    city?: StringFieldUpdateOperationsInput | string
    profession?: StringFieldUpdateOperationsInput | string
    education?: StringFieldUpdateOperationsInput | string
    religion?: StringFieldUpdateOperationsInput | string
    height?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: MatrimonialProfileUpdateinterestsInput | string[]
    photos?: MatrimonialProfileUpdatephotosInput | string[]
    familyBackground?: NullableStringFieldUpdateOperationsInput | string | null
    partnerPreferences?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    compatibilityScore?: IntFieldUpdateOperationsInput | number
    isInterested?: BoolFieldUpdateOperationsInput | boolean
    isMatched?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatrimonialMessageCreateInput = {
    id?: string
    content: string
    createdAt?: Date | string
    fromProfile: MatrimonialProfileCreateNestedOneWithoutSentMessagesInput
    toProfile: MatrimonialProfileCreateNestedOneWithoutReceivedMessagesInput
  }

  export type MatrimonialMessageUncheckedCreateInput = {
    id?: string
    fromProfileId: string
    toProfileId: string
    content: string
    createdAt?: Date | string
  }

  export type MatrimonialMessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fromProfile?: MatrimonialProfileUpdateOneRequiredWithoutSentMessagesNestedInput
    toProfile?: MatrimonialProfileUpdateOneRequiredWithoutReceivedMessagesNestedInput
  }

  export type MatrimonialMessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromProfileId?: StringFieldUpdateOperationsInput | string
    toProfileId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatrimonialMessageCreateManyInput = {
    id?: string
    fromProfileId: string
    toProfileId: string
    content: string
    createdAt?: Date | string
  }

  export type MatrimonialMessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatrimonialMessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromProfileId?: StringFieldUpdateOperationsInput | string
    toProfileId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorVerificationDocumentCreateInput = {
    id?: string
    documentType: string
    documentTitle: string
    documentContent: string
    documentHash: string
    signingToken: string
    tokenExpiresAt: Date | string
    signedAt?: Date | string | null
    signatureData?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    ipAddress?: string | null
    userAgent?: string | null
    reviewedBy?: string | null
    reviewedAt?: Date | string | null
    reviewNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    vendor: VendorCreateNestedOneWithoutVerificationDocumentsInput
  }

  export type VendorVerificationDocumentUncheckedCreateInput = {
    id?: string
    vendorId: string
    documentType: string
    documentTitle: string
    documentContent: string
    documentHash: string
    signingToken: string
    tokenExpiresAt: Date | string
    signedAt?: Date | string | null
    signatureData?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    ipAddress?: string | null
    userAgent?: string | null
    reviewedBy?: string | null
    reviewedAt?: Date | string | null
    reviewNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VendorVerificationDocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: StringFieldUpdateOperationsInput | string
    documentTitle?: StringFieldUpdateOperationsInput | string
    documentContent?: StringFieldUpdateOperationsInput | string
    documentHash?: StringFieldUpdateOperationsInput | string
    signingToken?: StringFieldUpdateOperationsInput | string
    tokenExpiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureData?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneRequiredWithoutVerificationDocumentsNestedInput
  }

  export type VendorVerificationDocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    documentType?: StringFieldUpdateOperationsInput | string
    documentTitle?: StringFieldUpdateOperationsInput | string
    documentContent?: StringFieldUpdateOperationsInput | string
    documentHash?: StringFieldUpdateOperationsInput | string
    signingToken?: StringFieldUpdateOperationsInput | string
    tokenExpiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureData?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorVerificationDocumentCreateManyInput = {
    id?: string
    vendorId: string
    documentType: string
    documentTitle: string
    documentContent: string
    documentHash: string
    signingToken: string
    tokenExpiresAt: Date | string
    signedAt?: Date | string | null
    signatureData?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    ipAddress?: string | null
    userAgent?: string | null
    reviewedBy?: string | null
    reviewedAt?: Date | string | null
    reviewNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VendorVerificationDocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: StringFieldUpdateOperationsInput | string
    documentTitle?: StringFieldUpdateOperationsInput | string
    documentContent?: StringFieldUpdateOperationsInput | string
    documentHash?: StringFieldUpdateOperationsInput | string
    signingToken?: StringFieldUpdateOperationsInput | string
    tokenExpiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureData?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorVerificationDocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    documentType?: StringFieldUpdateOperationsInput | string
    documentTitle?: StringFieldUpdateOperationsInput | string
    documentContent?: StringFieldUpdateOperationsInput | string
    documentHash?: StringFieldUpdateOperationsInput | string
    signingToken?: StringFieldUpdateOperationsInput | string
    tokenExpiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureData?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorDynamicFieldCreateInput = {
    id?: string
    fieldName: string
    fieldLabel: string
    fieldType: string
    fieldOptions?: VendorDynamicFieldCreatefieldOptionsInput | string[]
    fieldValue?: string | null
    isRequired?: boolean
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    vendor: VendorCreateNestedOneWithoutDynamicFieldsInput
  }

  export type VendorDynamicFieldUncheckedCreateInput = {
    id?: string
    vendorId: string
    fieldName: string
    fieldLabel: string
    fieldType: string
    fieldOptions?: VendorDynamicFieldCreatefieldOptionsInput | string[]
    fieldValue?: string | null
    isRequired?: boolean
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VendorDynamicFieldUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fieldName?: StringFieldUpdateOperationsInput | string
    fieldLabel?: StringFieldUpdateOperationsInput | string
    fieldType?: StringFieldUpdateOperationsInput | string
    fieldOptions?: VendorDynamicFieldUpdatefieldOptionsInput | string[]
    fieldValue?: NullableStringFieldUpdateOperationsInput | string | null
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneRequiredWithoutDynamicFieldsNestedInput
  }

  export type VendorDynamicFieldUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    fieldName?: StringFieldUpdateOperationsInput | string
    fieldLabel?: StringFieldUpdateOperationsInput | string
    fieldType?: StringFieldUpdateOperationsInput | string
    fieldOptions?: VendorDynamicFieldUpdatefieldOptionsInput | string[]
    fieldValue?: NullableStringFieldUpdateOperationsInput | string | null
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorDynamicFieldCreateManyInput = {
    id?: string
    vendorId: string
    fieldName: string
    fieldLabel: string
    fieldType: string
    fieldOptions?: VendorDynamicFieldCreatefieldOptionsInput | string[]
    fieldValue?: string | null
    isRequired?: boolean
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VendorDynamicFieldUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fieldName?: StringFieldUpdateOperationsInput | string
    fieldLabel?: StringFieldUpdateOperationsInput | string
    fieldType?: StringFieldUpdateOperationsInput | string
    fieldOptions?: VendorDynamicFieldUpdatefieldOptionsInput | string[]
    fieldValue?: NullableStringFieldUpdateOperationsInput | string | null
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorDynamicFieldUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    fieldName?: StringFieldUpdateOperationsInput | string
    fieldLabel?: StringFieldUpdateOperationsInput | string
    fieldType?: StringFieldUpdateOperationsInput | string
    fieldOptions?: VendorDynamicFieldUpdatefieldOptionsInput | string[]
    fieldValue?: NullableStringFieldUpdateOperationsInput | string | null
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PackageDynamicFieldCreateInput = {
    id?: string
    packageId: string
    fieldName: string
    fieldLabel: string
    fieldType: string
    fieldOptions?: PackageDynamicFieldCreatefieldOptionsInput | string[]
    fieldValue?: string | null
    isRequired?: boolean
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PackageDynamicFieldUncheckedCreateInput = {
    id?: string
    packageId: string
    fieldName: string
    fieldLabel: string
    fieldType: string
    fieldOptions?: PackageDynamicFieldCreatefieldOptionsInput | string[]
    fieldValue?: string | null
    isRequired?: boolean
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PackageDynamicFieldUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    packageId?: StringFieldUpdateOperationsInput | string
    fieldName?: StringFieldUpdateOperationsInput | string
    fieldLabel?: StringFieldUpdateOperationsInput | string
    fieldType?: StringFieldUpdateOperationsInput | string
    fieldOptions?: PackageDynamicFieldUpdatefieldOptionsInput | string[]
    fieldValue?: NullableStringFieldUpdateOperationsInput | string | null
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PackageDynamicFieldUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    packageId?: StringFieldUpdateOperationsInput | string
    fieldName?: StringFieldUpdateOperationsInput | string
    fieldLabel?: StringFieldUpdateOperationsInput | string
    fieldType?: StringFieldUpdateOperationsInput | string
    fieldOptions?: PackageDynamicFieldUpdatefieldOptionsInput | string[]
    fieldValue?: NullableStringFieldUpdateOperationsInput | string | null
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PackageDynamicFieldCreateManyInput = {
    id?: string
    packageId: string
    fieldName: string
    fieldLabel: string
    fieldType: string
    fieldOptions?: PackageDynamicFieldCreatefieldOptionsInput | string[]
    fieldValue?: string | null
    isRequired?: boolean
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PackageDynamicFieldUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    packageId?: StringFieldUpdateOperationsInput | string
    fieldName?: StringFieldUpdateOperationsInput | string
    fieldLabel?: StringFieldUpdateOperationsInput | string
    fieldType?: StringFieldUpdateOperationsInput | string
    fieldOptions?: PackageDynamicFieldUpdatefieldOptionsInput | string[]
    fieldValue?: NullableStringFieldUpdateOperationsInput | string | null
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PackageDynamicFieldUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    packageId?: StringFieldUpdateOperationsInput | string
    fieldName?: StringFieldUpdateOperationsInput | string
    fieldLabel?: StringFieldUpdateOperationsInput | string
    fieldType?: StringFieldUpdateOperationsInput | string
    fieldOptions?: PackageDynamicFieldUpdatefieldOptionsInput | string[]
    fieldValue?: NullableStringFieldUpdateOperationsInput | string | null
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type BookingListRelationFilter = {
    every?: BookingWhereInput
    some?: BookingWhereInput
    none?: BookingWhereInput
  }

  export type MessageListRelationFilter = {
    every?: MessageWhereInput
    some?: MessageWhereInput
    none?: MessageWhereInput
  }

  export type ReviewListRelationFilter = {
    every?: ReviewWhereInput
    some?: ReviewWhereInput
    none?: ReviewWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type ChatSessionListRelationFilter = {
    every?: ChatSessionWhereInput
    some?: ChatSessionWhereInput
    none?: ChatSessionWhereInput
  }

  export type VendorNullableRelationFilter = {
    is?: VendorWhereInput | null
    isNot?: VendorWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type BookingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChatSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    role?: SortOrder
    isVerified?: SortOrder
    profileImage?: SortOrder
    weddingDate?: SortOrder
    budget?: SortOrder
    location?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    budget?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    role?: SortOrder
    isVerified?: SortOrder
    profileImage?: SortOrder
    weddingDate?: SortOrder
    budget?: SortOrder
    location?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    role?: SortOrder
    isVerified?: SortOrder
    profileImage?: SortOrder
    weddingDate?: SortOrder
    budget?: SortOrder
    location?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    budget?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumVendorCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.VendorCategory | EnumVendorCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.VendorCategory[] | ListEnumVendorCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.VendorCategory[] | ListEnumVendorCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumVendorCategoryFilter<$PrismaModel> | $Enums.VendorCategory
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type EnumVerificationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.VerificationStatus | EnumVerificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VerificationStatus[] | ListEnumVerificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VerificationStatus[] | ListEnumVerificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVerificationStatusFilter<$PrismaModel> | $Enums.VerificationStatus
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type ServiceListRelationFilter = {
    every?: ServiceWhereInput
    some?: ServiceWhereInput
    none?: ServiceWhereInput
  }

  export type VendorVerificationDocumentListRelationFilter = {
    every?: VendorVerificationDocumentWhereInput
    some?: VendorVerificationDocumentWhereInput
    none?: VendorVerificationDocumentWhereInput
  }

  export type VendorDynamicFieldListRelationFilter = {
    every?: VendorDynamicFieldWhereInput
    some?: VendorDynamicFieldWhereInput
    none?: VendorDynamicFieldWhereInput
  }

  export type ServiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VendorVerificationDocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VendorDynamicFieldOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VendorCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    businessName?: SortOrder
    category?: SortOrder
    description?: SortOrder
    location?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    website?: SortOrder
    experience?: SortOrder
    rating?: SortOrder
    totalReviews?: SortOrder
    isVerified?: SortOrder
    isActive?: SortOrder
    verificationStatus?: SortOrder
    documentSignedAt?: SortOrder
    verificationNotes?: SortOrder
    basePrice?: SortOrder
    priceRange?: SortOrder
    profileImage?: SortOrder
    gallery?: SortOrder
    availability?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VendorAvgOrderByAggregateInput = {
    experience?: SortOrder
    rating?: SortOrder
    totalReviews?: SortOrder
    basePrice?: SortOrder
  }

  export type VendorMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    businessName?: SortOrder
    category?: SortOrder
    description?: SortOrder
    location?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    website?: SortOrder
    experience?: SortOrder
    rating?: SortOrder
    totalReviews?: SortOrder
    isVerified?: SortOrder
    isActive?: SortOrder
    verificationStatus?: SortOrder
    documentSignedAt?: SortOrder
    verificationNotes?: SortOrder
    basePrice?: SortOrder
    priceRange?: SortOrder
    profileImage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VendorMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    businessName?: SortOrder
    category?: SortOrder
    description?: SortOrder
    location?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    website?: SortOrder
    experience?: SortOrder
    rating?: SortOrder
    totalReviews?: SortOrder
    isVerified?: SortOrder
    isActive?: SortOrder
    verificationStatus?: SortOrder
    documentSignedAt?: SortOrder
    verificationNotes?: SortOrder
    basePrice?: SortOrder
    priceRange?: SortOrder
    profileImage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VendorSumOrderByAggregateInput = {
    experience?: SortOrder
    rating?: SortOrder
    totalReviews?: SortOrder
    basePrice?: SortOrder
  }

  export type EnumVendorCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VendorCategory | EnumVendorCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.VendorCategory[] | ListEnumVendorCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.VendorCategory[] | ListEnumVendorCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumVendorCategoryWithAggregatesFilter<$PrismaModel> | $Enums.VendorCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVendorCategoryFilter<$PrismaModel>
    _max?: NestedEnumVendorCategoryFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumVerificationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VerificationStatus | EnumVerificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VerificationStatus[] | ListEnumVerificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VerificationStatus[] | ListEnumVerificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVerificationStatusWithAggregatesFilter<$PrismaModel> | $Enums.VerificationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVerificationStatusFilter<$PrismaModel>
    _max?: NestedEnumVerificationStatusFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type VendorRelationFilter = {
    is?: VendorWhereInput
    isNot?: VendorWhereInput
  }

  export type ServiceCountOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    duration?: SortOrder
    maxCapacity?: SortOrder
    includes?: SortOrder
    addOns?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceAvgOrderByAggregateInput = {
    price?: SortOrder
    duration?: SortOrder
    maxCapacity?: SortOrder
  }

  export type ServiceMaxOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    duration?: SortOrder
    maxCapacity?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceMinOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    duration?: SortOrder
    maxCapacity?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceSumOrderByAggregateInput = {
    price?: SortOrder
    duration?: SortOrder
    maxCapacity?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumBookingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusFilter<$PrismaModel> | $Enums.BookingStatus
  }

  export type EnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type ServiceRelationFilter = {
    is?: ServiceWhereInput
    isNot?: ServiceWhereInput
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BookingCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    vendorId?: SortOrder
    serviceId?: SortOrder
    eventDate?: SortOrder
    eventTime?: SortOrder
    eventDuration?: SortOrder
    guestCount?: SortOrder
    location?: SortOrder
    specialRequests?: SortOrder
    basePrice?: SortOrder
    additionalCosts?: SortOrder
    totalAmount?: SortOrder
    status?: SortOrder
    paymentStatus?: SortOrder
    requestedAt?: SortOrder
    approvedAt?: SortOrder
    confirmedAt?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookingAvgOrderByAggregateInput = {
    eventDuration?: SortOrder
    guestCount?: SortOrder
    basePrice?: SortOrder
    additionalCosts?: SortOrder
    totalAmount?: SortOrder
  }

  export type BookingMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    vendorId?: SortOrder
    serviceId?: SortOrder
    eventDate?: SortOrder
    eventTime?: SortOrder
    eventDuration?: SortOrder
    guestCount?: SortOrder
    location?: SortOrder
    specialRequests?: SortOrder
    basePrice?: SortOrder
    additionalCosts?: SortOrder
    totalAmount?: SortOrder
    status?: SortOrder
    paymentStatus?: SortOrder
    requestedAt?: SortOrder
    approvedAt?: SortOrder
    confirmedAt?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookingMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    vendorId?: SortOrder
    serviceId?: SortOrder
    eventDate?: SortOrder
    eventTime?: SortOrder
    eventDuration?: SortOrder
    guestCount?: SortOrder
    location?: SortOrder
    specialRequests?: SortOrder
    basePrice?: SortOrder
    additionalCosts?: SortOrder
    totalAmount?: SortOrder
    status?: SortOrder
    paymentStatus?: SortOrder
    requestedAt?: SortOrder
    approvedAt?: SortOrder
    confirmedAt?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookingSumOrderByAggregateInput = {
    eventDuration?: SortOrder
    guestCount?: SortOrder
    basePrice?: SortOrder
    additionalCosts?: SortOrder
    totalAmount?: SortOrder
  }

  export type EnumBookingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusWithAggregatesFilter<$PrismaModel> | $Enums.BookingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBookingStatusFilter<$PrismaModel>
    _max?: NestedEnumBookingStatusFilter<$PrismaModel>
  }

  export type EnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type BookingRelationFilter = {
    is?: BookingWhereInput
    isNot?: BookingWhereInput
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    paymentMethod?: SortOrder
    transactionId?: SortOrder
    gatewayResponse?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    paymentMethod?: SortOrder
    transactionId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    paymentMethod?: SortOrder
    transactionId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type BookingNullableRelationFilter = {
    is?: BookingWhereInput | null
    isNot?: BookingWhereInput | null
  }

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    bookingId?: SortOrder
    content?: SortOrder
    messageType?: SortOrder
    attachments?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    bookingId?: SortOrder
    content?: SortOrder
    messageType?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    bookingId?: SortOrder
    content?: SortOrder
    messageType?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type ChatSessionUserIdVendorIdCompoundUniqueInput = {
    userId: string
    vendorId: string
  }

  export type ChatSessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    vendorId?: SortOrder
    lastMessageAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChatSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    vendorId?: SortOrder
    lastMessageAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChatSessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    vendorId?: SortOrder
    lastMessageAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReviewUserIdVendorIdCompoundUniqueInput = {
    userId: string
    vendorId: string
  }

  export type ReviewCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    vendorId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReviewAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type ReviewMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    vendorId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReviewMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    vendorId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReviewSumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type WeddingChecklistCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    isCompleted?: SortOrder
    dueDate?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WeddingChecklistMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    isCompleted?: SortOrder
    dueDate?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WeddingChecklistMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    isCompleted?: SortOrder
    dueDate?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type AIConversationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    messages?: SortOrder
    context?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AIConversationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AIConversationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EnumGenderFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderFilter<$PrismaModel> | $Enums.Gender
  }

  export type MatrimonialMessageListRelationFilter = {
    every?: MatrimonialMessageWhereInput
    some?: MatrimonialMessageWhereInput
    none?: MatrimonialMessageWhereInput
  }

  export type MatrimonialMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MatrimonialProfileCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    gender?: SortOrder
    dateOfBirth?: SortOrder
    age?: SortOrder
    city?: SortOrder
    profession?: SortOrder
    education?: SortOrder
    religion?: SortOrder
    height?: SortOrder
    bio?: SortOrder
    interests?: SortOrder
    photos?: SortOrder
    familyBackground?: SortOrder
    partnerPreferences?: SortOrder
    isVerified?: SortOrder
    isOnline?: SortOrder
    lastSeen?: SortOrder
    compatibilityScore?: SortOrder
    isInterested?: SortOrder
    isMatched?: SortOrder
    isBlocked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MatrimonialProfileAvgOrderByAggregateInput = {
    age?: SortOrder
    compatibilityScore?: SortOrder
  }

  export type MatrimonialProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    gender?: SortOrder
    dateOfBirth?: SortOrder
    age?: SortOrder
    city?: SortOrder
    profession?: SortOrder
    education?: SortOrder
    religion?: SortOrder
    height?: SortOrder
    bio?: SortOrder
    familyBackground?: SortOrder
    partnerPreferences?: SortOrder
    isVerified?: SortOrder
    isOnline?: SortOrder
    lastSeen?: SortOrder
    compatibilityScore?: SortOrder
    isInterested?: SortOrder
    isMatched?: SortOrder
    isBlocked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MatrimonialProfileMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    gender?: SortOrder
    dateOfBirth?: SortOrder
    age?: SortOrder
    city?: SortOrder
    profession?: SortOrder
    education?: SortOrder
    religion?: SortOrder
    height?: SortOrder
    bio?: SortOrder
    familyBackground?: SortOrder
    partnerPreferences?: SortOrder
    isVerified?: SortOrder
    isOnline?: SortOrder
    lastSeen?: SortOrder
    compatibilityScore?: SortOrder
    isInterested?: SortOrder
    isMatched?: SortOrder
    isBlocked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MatrimonialProfileSumOrderByAggregateInput = {
    age?: SortOrder
    compatibilityScore?: SortOrder
  }

  export type EnumGenderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderWithAggregatesFilter<$PrismaModel> | $Enums.Gender
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGenderFilter<$PrismaModel>
    _max?: NestedEnumGenderFilter<$PrismaModel>
  }

  export type MatrimonialProfileRelationFilter = {
    is?: MatrimonialProfileWhereInput
    isNot?: MatrimonialProfileWhereInput
  }

  export type MatrimonialMessageCountOrderByAggregateInput = {
    id?: SortOrder
    fromProfileId?: SortOrder
    toProfileId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type MatrimonialMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    fromProfileId?: SortOrder
    toProfileId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type MatrimonialMessageMinOrderByAggregateInput = {
    id?: SortOrder
    fromProfileId?: SortOrder
    toProfileId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type VendorVerificationDocumentCountOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    documentType?: SortOrder
    documentTitle?: SortOrder
    documentContent?: SortOrder
    documentHash?: SortOrder
    signingToken?: SortOrder
    tokenExpiresAt?: SortOrder
    signedAt?: SortOrder
    signatureData?: SortOrder
    status?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    reviewedBy?: SortOrder
    reviewedAt?: SortOrder
    reviewNotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VendorVerificationDocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    documentType?: SortOrder
    documentTitle?: SortOrder
    documentContent?: SortOrder
    documentHash?: SortOrder
    signingToken?: SortOrder
    tokenExpiresAt?: SortOrder
    signedAt?: SortOrder
    status?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    reviewedBy?: SortOrder
    reviewedAt?: SortOrder
    reviewNotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VendorVerificationDocumentMinOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    documentType?: SortOrder
    documentTitle?: SortOrder
    documentContent?: SortOrder
    documentHash?: SortOrder
    signingToken?: SortOrder
    tokenExpiresAt?: SortOrder
    signedAt?: SortOrder
    status?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    reviewedBy?: SortOrder
    reviewedAt?: SortOrder
    reviewNotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VendorDynamicFieldCountOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    fieldName?: SortOrder
    fieldLabel?: SortOrder
    fieldType?: SortOrder
    fieldOptions?: SortOrder
    fieldValue?: SortOrder
    isRequired?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VendorDynamicFieldAvgOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type VendorDynamicFieldMaxOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    fieldName?: SortOrder
    fieldLabel?: SortOrder
    fieldType?: SortOrder
    fieldValue?: SortOrder
    isRequired?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VendorDynamicFieldMinOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    fieldName?: SortOrder
    fieldLabel?: SortOrder
    fieldType?: SortOrder
    fieldValue?: SortOrder
    isRequired?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VendorDynamicFieldSumOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type PackageDynamicFieldCountOrderByAggregateInput = {
    id?: SortOrder
    packageId?: SortOrder
    fieldName?: SortOrder
    fieldLabel?: SortOrder
    fieldType?: SortOrder
    fieldOptions?: SortOrder
    fieldValue?: SortOrder
    isRequired?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PackageDynamicFieldAvgOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type PackageDynamicFieldMaxOrderByAggregateInput = {
    id?: SortOrder
    packageId?: SortOrder
    fieldName?: SortOrder
    fieldLabel?: SortOrder
    fieldType?: SortOrder
    fieldValue?: SortOrder
    isRequired?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PackageDynamicFieldMinOrderByAggregateInput = {
    id?: SortOrder
    packageId?: SortOrder
    fieldName?: SortOrder
    fieldLabel?: SortOrder
    fieldType?: SortOrder
    fieldValue?: SortOrder
    isRequired?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PackageDynamicFieldSumOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type BookingCreateNestedManyWithoutUserInput = {
    create?: XOR<BookingCreateWithoutUserInput, BookingUncheckedCreateWithoutUserInput> | BookingCreateWithoutUserInput[] | BookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutUserInput | BookingCreateOrConnectWithoutUserInput[]
    createMany?: BookingCreateManyUserInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutSenderInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutReceiverInput = {
    create?: XOR<MessageCreateWithoutReceiverInput, MessageUncheckedCreateWithoutReceiverInput> | MessageCreateWithoutReceiverInput[] | MessageUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutReceiverInput | MessageCreateOrConnectWithoutReceiverInput[]
    createMany?: MessageCreateManyReceiverInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type ReviewCreateNestedManyWithoutUserInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type ChatSessionCreateNestedManyWithoutUserInput = {
    create?: XOR<ChatSessionCreateWithoutUserInput, ChatSessionUncheckedCreateWithoutUserInput> | ChatSessionCreateWithoutUserInput[] | ChatSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChatSessionCreateOrConnectWithoutUserInput | ChatSessionCreateOrConnectWithoutUserInput[]
    createMany?: ChatSessionCreateManyUserInputEnvelope
    connect?: ChatSessionWhereUniqueInput | ChatSessionWhereUniqueInput[]
  }

  export type VendorCreateNestedOneWithoutUserInput = {
    create?: XOR<VendorCreateWithoutUserInput, VendorUncheckedCreateWithoutUserInput>
    connectOrCreate?: VendorCreateOrConnectWithoutUserInput
    connect?: VendorWhereUniqueInput
  }

  export type BookingUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BookingCreateWithoutUserInput, BookingUncheckedCreateWithoutUserInput> | BookingCreateWithoutUserInput[] | BookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutUserInput | BookingCreateOrConnectWithoutUserInput[]
    createMany?: BookingCreateManyUserInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutReceiverInput = {
    create?: XOR<MessageCreateWithoutReceiverInput, MessageUncheckedCreateWithoutReceiverInput> | MessageCreateWithoutReceiverInput[] | MessageUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutReceiverInput | MessageCreateOrConnectWithoutReceiverInput[]
    createMany?: MessageCreateManyReceiverInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type ReviewUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type ChatSessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ChatSessionCreateWithoutUserInput, ChatSessionUncheckedCreateWithoutUserInput> | ChatSessionCreateWithoutUserInput[] | ChatSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChatSessionCreateOrConnectWithoutUserInput | ChatSessionCreateOrConnectWithoutUserInput[]
    createMany?: ChatSessionCreateManyUserInputEnvelope
    connect?: ChatSessionWhereUniqueInput | ChatSessionWhereUniqueInput[]
  }

  export type VendorUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<VendorCreateWithoutUserInput, VendorUncheckedCreateWithoutUserInput>
    connectOrCreate?: VendorCreateOrConnectWithoutUserInput
    connect?: VendorWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type BookingUpdateManyWithoutUserNestedInput = {
    create?: XOR<BookingCreateWithoutUserInput, BookingUncheckedCreateWithoutUserInput> | BookingCreateWithoutUserInput[] | BookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutUserInput | BookingCreateOrConnectWithoutUserInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutUserInput | BookingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BookingCreateManyUserInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutUserInput | BookingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutUserInput | BookingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutSenderNestedInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSenderInput | MessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSenderInput | MessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSenderInput | MessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutReceiverNestedInput = {
    create?: XOR<MessageCreateWithoutReceiverInput, MessageUncheckedCreateWithoutReceiverInput> | MessageCreateWithoutReceiverInput[] | MessageUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutReceiverInput | MessageCreateOrConnectWithoutReceiverInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutReceiverInput | MessageUpsertWithWhereUniqueWithoutReceiverInput[]
    createMany?: MessageCreateManyReceiverInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutReceiverInput | MessageUpdateWithWhereUniqueWithoutReceiverInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutReceiverInput | MessageUpdateManyWithWhereWithoutReceiverInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ReviewUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutUserInput | ReviewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutUserInput | ReviewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutUserInput | ReviewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type ChatSessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<ChatSessionCreateWithoutUserInput, ChatSessionUncheckedCreateWithoutUserInput> | ChatSessionCreateWithoutUserInput[] | ChatSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChatSessionCreateOrConnectWithoutUserInput | ChatSessionCreateOrConnectWithoutUserInput[]
    upsert?: ChatSessionUpsertWithWhereUniqueWithoutUserInput | ChatSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ChatSessionCreateManyUserInputEnvelope
    set?: ChatSessionWhereUniqueInput | ChatSessionWhereUniqueInput[]
    disconnect?: ChatSessionWhereUniqueInput | ChatSessionWhereUniqueInput[]
    delete?: ChatSessionWhereUniqueInput | ChatSessionWhereUniqueInput[]
    connect?: ChatSessionWhereUniqueInput | ChatSessionWhereUniqueInput[]
    update?: ChatSessionUpdateWithWhereUniqueWithoutUserInput | ChatSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ChatSessionUpdateManyWithWhereWithoutUserInput | ChatSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ChatSessionScalarWhereInput | ChatSessionScalarWhereInput[]
  }

  export type VendorUpdateOneWithoutUserNestedInput = {
    create?: XOR<VendorCreateWithoutUserInput, VendorUncheckedCreateWithoutUserInput>
    connectOrCreate?: VendorCreateOrConnectWithoutUserInput
    upsert?: VendorUpsertWithoutUserInput
    disconnect?: VendorWhereInput | boolean
    delete?: VendorWhereInput | boolean
    connect?: VendorWhereUniqueInput
    update?: XOR<XOR<VendorUpdateToOneWithWhereWithoutUserInput, VendorUpdateWithoutUserInput>, VendorUncheckedUpdateWithoutUserInput>
  }

  export type BookingUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BookingCreateWithoutUserInput, BookingUncheckedCreateWithoutUserInput> | BookingCreateWithoutUserInput[] | BookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutUserInput | BookingCreateOrConnectWithoutUserInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutUserInput | BookingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BookingCreateManyUserInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutUserInput | BookingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutUserInput | BookingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSenderInput | MessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSenderInput | MessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSenderInput | MessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutReceiverNestedInput = {
    create?: XOR<MessageCreateWithoutReceiverInput, MessageUncheckedCreateWithoutReceiverInput> | MessageCreateWithoutReceiverInput[] | MessageUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutReceiverInput | MessageCreateOrConnectWithoutReceiverInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutReceiverInput | MessageUpsertWithWhereUniqueWithoutReceiverInput[]
    createMany?: MessageCreateManyReceiverInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutReceiverInput | MessageUpdateWithWhereUniqueWithoutReceiverInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutReceiverInput | MessageUpdateManyWithWhereWithoutReceiverInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ReviewUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutUserInput | ReviewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutUserInput | ReviewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutUserInput | ReviewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type ChatSessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ChatSessionCreateWithoutUserInput, ChatSessionUncheckedCreateWithoutUserInput> | ChatSessionCreateWithoutUserInput[] | ChatSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChatSessionCreateOrConnectWithoutUserInput | ChatSessionCreateOrConnectWithoutUserInput[]
    upsert?: ChatSessionUpsertWithWhereUniqueWithoutUserInput | ChatSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ChatSessionCreateManyUserInputEnvelope
    set?: ChatSessionWhereUniqueInput | ChatSessionWhereUniqueInput[]
    disconnect?: ChatSessionWhereUniqueInput | ChatSessionWhereUniqueInput[]
    delete?: ChatSessionWhereUniqueInput | ChatSessionWhereUniqueInput[]
    connect?: ChatSessionWhereUniqueInput | ChatSessionWhereUniqueInput[]
    update?: ChatSessionUpdateWithWhereUniqueWithoutUserInput | ChatSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ChatSessionUpdateManyWithWhereWithoutUserInput | ChatSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ChatSessionScalarWhereInput | ChatSessionScalarWhereInput[]
  }

  export type VendorUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<VendorCreateWithoutUserInput, VendorUncheckedCreateWithoutUserInput>
    connectOrCreate?: VendorCreateOrConnectWithoutUserInput
    upsert?: VendorUpsertWithoutUserInput
    disconnect?: VendorWhereInput | boolean
    delete?: VendorWhereInput | boolean
    connect?: VendorWhereUniqueInput
    update?: XOR<XOR<VendorUpdateToOneWithWhereWithoutUserInput, VendorUpdateWithoutUserInput>, VendorUncheckedUpdateWithoutUserInput>
  }

  export type VendorCreategalleryInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutVendorInput = {
    create?: XOR<UserCreateWithoutVendorInput, UserUncheckedCreateWithoutVendorInput>
    connectOrCreate?: UserCreateOrConnectWithoutVendorInput
    connect?: UserWhereUniqueInput
  }

  export type BookingCreateNestedManyWithoutVendorInput = {
    create?: XOR<BookingCreateWithoutVendorInput, BookingUncheckedCreateWithoutVendorInput> | BookingCreateWithoutVendorInput[] | BookingUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutVendorInput | BookingCreateOrConnectWithoutVendorInput[]
    createMany?: BookingCreateManyVendorInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type ServiceCreateNestedManyWithoutVendorInput = {
    create?: XOR<ServiceCreateWithoutVendorInput, ServiceUncheckedCreateWithoutVendorInput> | ServiceCreateWithoutVendorInput[] | ServiceUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutVendorInput | ServiceCreateOrConnectWithoutVendorInput[]
    createMany?: ServiceCreateManyVendorInputEnvelope
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
  }

  export type ReviewCreateNestedManyWithoutVendorInput = {
    create?: XOR<ReviewCreateWithoutVendorInput, ReviewUncheckedCreateWithoutVendorInput> | ReviewCreateWithoutVendorInput[] | ReviewUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutVendorInput | ReviewCreateOrConnectWithoutVendorInput[]
    createMany?: ReviewCreateManyVendorInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type ChatSessionCreateNestedManyWithoutVendorInput = {
    create?: XOR<ChatSessionCreateWithoutVendorInput, ChatSessionUncheckedCreateWithoutVendorInput> | ChatSessionCreateWithoutVendorInput[] | ChatSessionUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: ChatSessionCreateOrConnectWithoutVendorInput | ChatSessionCreateOrConnectWithoutVendorInput[]
    createMany?: ChatSessionCreateManyVendorInputEnvelope
    connect?: ChatSessionWhereUniqueInput | ChatSessionWhereUniqueInput[]
  }

  export type VendorVerificationDocumentCreateNestedManyWithoutVendorInput = {
    create?: XOR<VendorVerificationDocumentCreateWithoutVendorInput, VendorVerificationDocumentUncheckedCreateWithoutVendorInput> | VendorVerificationDocumentCreateWithoutVendorInput[] | VendorVerificationDocumentUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: VendorVerificationDocumentCreateOrConnectWithoutVendorInput | VendorVerificationDocumentCreateOrConnectWithoutVendorInput[]
    createMany?: VendorVerificationDocumentCreateManyVendorInputEnvelope
    connect?: VendorVerificationDocumentWhereUniqueInput | VendorVerificationDocumentWhereUniqueInput[]
  }

  export type VendorDynamicFieldCreateNestedManyWithoutVendorInput = {
    create?: XOR<VendorDynamicFieldCreateWithoutVendorInput, VendorDynamicFieldUncheckedCreateWithoutVendorInput> | VendorDynamicFieldCreateWithoutVendorInput[] | VendorDynamicFieldUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: VendorDynamicFieldCreateOrConnectWithoutVendorInput | VendorDynamicFieldCreateOrConnectWithoutVendorInput[]
    createMany?: VendorDynamicFieldCreateManyVendorInputEnvelope
    connect?: VendorDynamicFieldWhereUniqueInput | VendorDynamicFieldWhereUniqueInput[]
  }

  export type BookingUncheckedCreateNestedManyWithoutVendorInput = {
    create?: XOR<BookingCreateWithoutVendorInput, BookingUncheckedCreateWithoutVendorInput> | BookingCreateWithoutVendorInput[] | BookingUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutVendorInput | BookingCreateOrConnectWithoutVendorInput[]
    createMany?: BookingCreateManyVendorInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type ServiceUncheckedCreateNestedManyWithoutVendorInput = {
    create?: XOR<ServiceCreateWithoutVendorInput, ServiceUncheckedCreateWithoutVendorInput> | ServiceCreateWithoutVendorInput[] | ServiceUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutVendorInput | ServiceCreateOrConnectWithoutVendorInput[]
    createMany?: ServiceCreateManyVendorInputEnvelope
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
  }

  export type ReviewUncheckedCreateNestedManyWithoutVendorInput = {
    create?: XOR<ReviewCreateWithoutVendorInput, ReviewUncheckedCreateWithoutVendorInput> | ReviewCreateWithoutVendorInput[] | ReviewUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutVendorInput | ReviewCreateOrConnectWithoutVendorInput[]
    createMany?: ReviewCreateManyVendorInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type ChatSessionUncheckedCreateNestedManyWithoutVendorInput = {
    create?: XOR<ChatSessionCreateWithoutVendorInput, ChatSessionUncheckedCreateWithoutVendorInput> | ChatSessionCreateWithoutVendorInput[] | ChatSessionUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: ChatSessionCreateOrConnectWithoutVendorInput | ChatSessionCreateOrConnectWithoutVendorInput[]
    createMany?: ChatSessionCreateManyVendorInputEnvelope
    connect?: ChatSessionWhereUniqueInput | ChatSessionWhereUniqueInput[]
  }

  export type VendorVerificationDocumentUncheckedCreateNestedManyWithoutVendorInput = {
    create?: XOR<VendorVerificationDocumentCreateWithoutVendorInput, VendorVerificationDocumentUncheckedCreateWithoutVendorInput> | VendorVerificationDocumentCreateWithoutVendorInput[] | VendorVerificationDocumentUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: VendorVerificationDocumentCreateOrConnectWithoutVendorInput | VendorVerificationDocumentCreateOrConnectWithoutVendorInput[]
    createMany?: VendorVerificationDocumentCreateManyVendorInputEnvelope
    connect?: VendorVerificationDocumentWhereUniqueInput | VendorVerificationDocumentWhereUniqueInput[]
  }

  export type VendorDynamicFieldUncheckedCreateNestedManyWithoutVendorInput = {
    create?: XOR<VendorDynamicFieldCreateWithoutVendorInput, VendorDynamicFieldUncheckedCreateWithoutVendorInput> | VendorDynamicFieldCreateWithoutVendorInput[] | VendorDynamicFieldUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: VendorDynamicFieldCreateOrConnectWithoutVendorInput | VendorDynamicFieldCreateOrConnectWithoutVendorInput[]
    createMany?: VendorDynamicFieldCreateManyVendorInputEnvelope
    connect?: VendorDynamicFieldWhereUniqueInput | VendorDynamicFieldWhereUniqueInput[]
  }

  export type EnumVendorCategoryFieldUpdateOperationsInput = {
    set?: $Enums.VendorCategory
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumVerificationStatusFieldUpdateOperationsInput = {
    set?: $Enums.VerificationStatus
  }

  export type VendorUpdategalleryInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutVendorNestedInput = {
    create?: XOR<UserCreateWithoutVendorInput, UserUncheckedCreateWithoutVendorInput>
    connectOrCreate?: UserCreateOrConnectWithoutVendorInput
    upsert?: UserUpsertWithoutVendorInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutVendorInput, UserUpdateWithoutVendorInput>, UserUncheckedUpdateWithoutVendorInput>
  }

  export type BookingUpdateManyWithoutVendorNestedInput = {
    create?: XOR<BookingCreateWithoutVendorInput, BookingUncheckedCreateWithoutVendorInput> | BookingCreateWithoutVendorInput[] | BookingUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutVendorInput | BookingCreateOrConnectWithoutVendorInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutVendorInput | BookingUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: BookingCreateManyVendorInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutVendorInput | BookingUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutVendorInput | BookingUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type ServiceUpdateManyWithoutVendorNestedInput = {
    create?: XOR<ServiceCreateWithoutVendorInput, ServiceUncheckedCreateWithoutVendorInput> | ServiceCreateWithoutVendorInput[] | ServiceUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutVendorInput | ServiceCreateOrConnectWithoutVendorInput[]
    upsert?: ServiceUpsertWithWhereUniqueWithoutVendorInput | ServiceUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: ServiceCreateManyVendorInputEnvelope
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    update?: ServiceUpdateWithWhereUniqueWithoutVendorInput | ServiceUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: ServiceUpdateManyWithWhereWithoutVendorInput | ServiceUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
  }

  export type ReviewUpdateManyWithoutVendorNestedInput = {
    create?: XOR<ReviewCreateWithoutVendorInput, ReviewUncheckedCreateWithoutVendorInput> | ReviewCreateWithoutVendorInput[] | ReviewUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutVendorInput | ReviewCreateOrConnectWithoutVendorInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutVendorInput | ReviewUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: ReviewCreateManyVendorInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutVendorInput | ReviewUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutVendorInput | ReviewUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type ChatSessionUpdateManyWithoutVendorNestedInput = {
    create?: XOR<ChatSessionCreateWithoutVendorInput, ChatSessionUncheckedCreateWithoutVendorInput> | ChatSessionCreateWithoutVendorInput[] | ChatSessionUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: ChatSessionCreateOrConnectWithoutVendorInput | ChatSessionCreateOrConnectWithoutVendorInput[]
    upsert?: ChatSessionUpsertWithWhereUniqueWithoutVendorInput | ChatSessionUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: ChatSessionCreateManyVendorInputEnvelope
    set?: ChatSessionWhereUniqueInput | ChatSessionWhereUniqueInput[]
    disconnect?: ChatSessionWhereUniqueInput | ChatSessionWhereUniqueInput[]
    delete?: ChatSessionWhereUniqueInput | ChatSessionWhereUniqueInput[]
    connect?: ChatSessionWhereUniqueInput | ChatSessionWhereUniqueInput[]
    update?: ChatSessionUpdateWithWhereUniqueWithoutVendorInput | ChatSessionUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: ChatSessionUpdateManyWithWhereWithoutVendorInput | ChatSessionUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: ChatSessionScalarWhereInput | ChatSessionScalarWhereInput[]
  }

  export type VendorVerificationDocumentUpdateManyWithoutVendorNestedInput = {
    create?: XOR<VendorVerificationDocumentCreateWithoutVendorInput, VendorVerificationDocumentUncheckedCreateWithoutVendorInput> | VendorVerificationDocumentCreateWithoutVendorInput[] | VendorVerificationDocumentUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: VendorVerificationDocumentCreateOrConnectWithoutVendorInput | VendorVerificationDocumentCreateOrConnectWithoutVendorInput[]
    upsert?: VendorVerificationDocumentUpsertWithWhereUniqueWithoutVendorInput | VendorVerificationDocumentUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: VendorVerificationDocumentCreateManyVendorInputEnvelope
    set?: VendorVerificationDocumentWhereUniqueInput | VendorVerificationDocumentWhereUniqueInput[]
    disconnect?: VendorVerificationDocumentWhereUniqueInput | VendorVerificationDocumentWhereUniqueInput[]
    delete?: VendorVerificationDocumentWhereUniqueInput | VendorVerificationDocumentWhereUniqueInput[]
    connect?: VendorVerificationDocumentWhereUniqueInput | VendorVerificationDocumentWhereUniqueInput[]
    update?: VendorVerificationDocumentUpdateWithWhereUniqueWithoutVendorInput | VendorVerificationDocumentUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: VendorVerificationDocumentUpdateManyWithWhereWithoutVendorInput | VendorVerificationDocumentUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: VendorVerificationDocumentScalarWhereInput | VendorVerificationDocumentScalarWhereInput[]
  }

  export type VendorDynamicFieldUpdateManyWithoutVendorNestedInput = {
    create?: XOR<VendorDynamicFieldCreateWithoutVendorInput, VendorDynamicFieldUncheckedCreateWithoutVendorInput> | VendorDynamicFieldCreateWithoutVendorInput[] | VendorDynamicFieldUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: VendorDynamicFieldCreateOrConnectWithoutVendorInput | VendorDynamicFieldCreateOrConnectWithoutVendorInput[]
    upsert?: VendorDynamicFieldUpsertWithWhereUniqueWithoutVendorInput | VendorDynamicFieldUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: VendorDynamicFieldCreateManyVendorInputEnvelope
    set?: VendorDynamicFieldWhereUniqueInput | VendorDynamicFieldWhereUniqueInput[]
    disconnect?: VendorDynamicFieldWhereUniqueInput | VendorDynamicFieldWhereUniqueInput[]
    delete?: VendorDynamicFieldWhereUniqueInput | VendorDynamicFieldWhereUniqueInput[]
    connect?: VendorDynamicFieldWhereUniqueInput | VendorDynamicFieldWhereUniqueInput[]
    update?: VendorDynamicFieldUpdateWithWhereUniqueWithoutVendorInput | VendorDynamicFieldUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: VendorDynamicFieldUpdateManyWithWhereWithoutVendorInput | VendorDynamicFieldUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: VendorDynamicFieldScalarWhereInput | VendorDynamicFieldScalarWhereInput[]
  }

  export type BookingUncheckedUpdateManyWithoutVendorNestedInput = {
    create?: XOR<BookingCreateWithoutVendorInput, BookingUncheckedCreateWithoutVendorInput> | BookingCreateWithoutVendorInput[] | BookingUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutVendorInput | BookingCreateOrConnectWithoutVendorInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutVendorInput | BookingUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: BookingCreateManyVendorInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutVendorInput | BookingUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutVendorInput | BookingUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type ServiceUncheckedUpdateManyWithoutVendorNestedInput = {
    create?: XOR<ServiceCreateWithoutVendorInput, ServiceUncheckedCreateWithoutVendorInput> | ServiceCreateWithoutVendorInput[] | ServiceUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutVendorInput | ServiceCreateOrConnectWithoutVendorInput[]
    upsert?: ServiceUpsertWithWhereUniqueWithoutVendorInput | ServiceUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: ServiceCreateManyVendorInputEnvelope
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    update?: ServiceUpdateWithWhereUniqueWithoutVendorInput | ServiceUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: ServiceUpdateManyWithWhereWithoutVendorInput | ServiceUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
  }

  export type ReviewUncheckedUpdateManyWithoutVendorNestedInput = {
    create?: XOR<ReviewCreateWithoutVendorInput, ReviewUncheckedCreateWithoutVendorInput> | ReviewCreateWithoutVendorInput[] | ReviewUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutVendorInput | ReviewCreateOrConnectWithoutVendorInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutVendorInput | ReviewUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: ReviewCreateManyVendorInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutVendorInput | ReviewUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutVendorInput | ReviewUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type ChatSessionUncheckedUpdateManyWithoutVendorNestedInput = {
    create?: XOR<ChatSessionCreateWithoutVendorInput, ChatSessionUncheckedCreateWithoutVendorInput> | ChatSessionCreateWithoutVendorInput[] | ChatSessionUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: ChatSessionCreateOrConnectWithoutVendorInput | ChatSessionCreateOrConnectWithoutVendorInput[]
    upsert?: ChatSessionUpsertWithWhereUniqueWithoutVendorInput | ChatSessionUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: ChatSessionCreateManyVendorInputEnvelope
    set?: ChatSessionWhereUniqueInput | ChatSessionWhereUniqueInput[]
    disconnect?: ChatSessionWhereUniqueInput | ChatSessionWhereUniqueInput[]
    delete?: ChatSessionWhereUniqueInput | ChatSessionWhereUniqueInput[]
    connect?: ChatSessionWhereUniqueInput | ChatSessionWhereUniqueInput[]
    update?: ChatSessionUpdateWithWhereUniqueWithoutVendorInput | ChatSessionUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: ChatSessionUpdateManyWithWhereWithoutVendorInput | ChatSessionUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: ChatSessionScalarWhereInput | ChatSessionScalarWhereInput[]
  }

  export type VendorVerificationDocumentUncheckedUpdateManyWithoutVendorNestedInput = {
    create?: XOR<VendorVerificationDocumentCreateWithoutVendorInput, VendorVerificationDocumentUncheckedCreateWithoutVendorInput> | VendorVerificationDocumentCreateWithoutVendorInput[] | VendorVerificationDocumentUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: VendorVerificationDocumentCreateOrConnectWithoutVendorInput | VendorVerificationDocumentCreateOrConnectWithoutVendorInput[]
    upsert?: VendorVerificationDocumentUpsertWithWhereUniqueWithoutVendorInput | VendorVerificationDocumentUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: VendorVerificationDocumentCreateManyVendorInputEnvelope
    set?: VendorVerificationDocumentWhereUniqueInput | VendorVerificationDocumentWhereUniqueInput[]
    disconnect?: VendorVerificationDocumentWhereUniqueInput | VendorVerificationDocumentWhereUniqueInput[]
    delete?: VendorVerificationDocumentWhereUniqueInput | VendorVerificationDocumentWhereUniqueInput[]
    connect?: VendorVerificationDocumentWhereUniqueInput | VendorVerificationDocumentWhereUniqueInput[]
    update?: VendorVerificationDocumentUpdateWithWhereUniqueWithoutVendorInput | VendorVerificationDocumentUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: VendorVerificationDocumentUpdateManyWithWhereWithoutVendorInput | VendorVerificationDocumentUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: VendorVerificationDocumentScalarWhereInput | VendorVerificationDocumentScalarWhereInput[]
  }

  export type VendorDynamicFieldUncheckedUpdateManyWithoutVendorNestedInput = {
    create?: XOR<VendorDynamicFieldCreateWithoutVendorInput, VendorDynamicFieldUncheckedCreateWithoutVendorInput> | VendorDynamicFieldCreateWithoutVendorInput[] | VendorDynamicFieldUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: VendorDynamicFieldCreateOrConnectWithoutVendorInput | VendorDynamicFieldCreateOrConnectWithoutVendorInput[]
    upsert?: VendorDynamicFieldUpsertWithWhereUniqueWithoutVendorInput | VendorDynamicFieldUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: VendorDynamicFieldCreateManyVendorInputEnvelope
    set?: VendorDynamicFieldWhereUniqueInput | VendorDynamicFieldWhereUniqueInput[]
    disconnect?: VendorDynamicFieldWhereUniqueInput | VendorDynamicFieldWhereUniqueInput[]
    delete?: VendorDynamicFieldWhereUniqueInput | VendorDynamicFieldWhereUniqueInput[]
    connect?: VendorDynamicFieldWhereUniqueInput | VendorDynamicFieldWhereUniqueInput[]
    update?: VendorDynamicFieldUpdateWithWhereUniqueWithoutVendorInput | VendorDynamicFieldUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: VendorDynamicFieldUpdateManyWithWhereWithoutVendorInput | VendorDynamicFieldUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: VendorDynamicFieldScalarWhereInput | VendorDynamicFieldScalarWhereInput[]
  }

  export type ServiceCreateincludesInput = {
    set: string[]
  }

  export type VendorCreateNestedOneWithoutServicesInput = {
    create?: XOR<VendorCreateWithoutServicesInput, VendorUncheckedCreateWithoutServicesInput>
    connectOrCreate?: VendorCreateOrConnectWithoutServicesInput
    connect?: VendorWhereUniqueInput
  }

  export type BookingCreateNestedManyWithoutServiceInput = {
    create?: XOR<BookingCreateWithoutServiceInput, BookingUncheckedCreateWithoutServiceInput> | BookingCreateWithoutServiceInput[] | BookingUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutServiceInput | BookingCreateOrConnectWithoutServiceInput[]
    createMany?: BookingCreateManyServiceInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type BookingUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<BookingCreateWithoutServiceInput, BookingUncheckedCreateWithoutServiceInput> | BookingCreateWithoutServiceInput[] | BookingUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutServiceInput | BookingCreateOrConnectWithoutServiceInput[]
    createMany?: BookingCreateManyServiceInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ServiceUpdateincludesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type VendorUpdateOneRequiredWithoutServicesNestedInput = {
    create?: XOR<VendorCreateWithoutServicesInput, VendorUncheckedCreateWithoutServicesInput>
    connectOrCreate?: VendorCreateOrConnectWithoutServicesInput
    upsert?: VendorUpsertWithoutServicesInput
    connect?: VendorWhereUniqueInput
    update?: XOR<XOR<VendorUpdateToOneWithWhereWithoutServicesInput, VendorUpdateWithoutServicesInput>, VendorUncheckedUpdateWithoutServicesInput>
  }

  export type BookingUpdateManyWithoutServiceNestedInput = {
    create?: XOR<BookingCreateWithoutServiceInput, BookingUncheckedCreateWithoutServiceInput> | BookingCreateWithoutServiceInput[] | BookingUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutServiceInput | BookingCreateOrConnectWithoutServiceInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutServiceInput | BookingUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: BookingCreateManyServiceInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutServiceInput | BookingUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutServiceInput | BookingUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type BookingUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<BookingCreateWithoutServiceInput, BookingUncheckedCreateWithoutServiceInput> | BookingCreateWithoutServiceInput[] | BookingUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutServiceInput | BookingCreateOrConnectWithoutServiceInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutServiceInput | BookingUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: BookingCreateManyServiceInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutServiceInput | BookingUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutServiceInput | BookingUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutBookingsInput = {
    create?: XOR<UserCreateWithoutBookingsInput, UserUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBookingsInput
    connect?: UserWhereUniqueInput
  }

  export type VendorCreateNestedOneWithoutBookingsInput = {
    create?: XOR<VendorCreateWithoutBookingsInput, VendorUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: VendorCreateOrConnectWithoutBookingsInput
    connect?: VendorWhereUniqueInput
  }

  export type ServiceCreateNestedOneWithoutBookingsInput = {
    create?: XOR<ServiceCreateWithoutBookingsInput, ServiceUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutBookingsInput
    connect?: ServiceWhereUniqueInput
  }

  export type PaymentCreateNestedManyWithoutBookingInput = {
    create?: XOR<PaymentCreateWithoutBookingInput, PaymentUncheckedCreateWithoutBookingInput> | PaymentCreateWithoutBookingInput[] | PaymentUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutBookingInput | PaymentCreateOrConnectWithoutBookingInput[]
    createMany?: PaymentCreateManyBookingInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutBookingInput = {
    create?: XOR<MessageCreateWithoutBookingInput, MessageUncheckedCreateWithoutBookingInput> | MessageCreateWithoutBookingInput[] | MessageUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutBookingInput | MessageCreateOrConnectWithoutBookingInput[]
    createMany?: MessageCreateManyBookingInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutBookingInput = {
    create?: XOR<PaymentCreateWithoutBookingInput, PaymentUncheckedCreateWithoutBookingInput> | PaymentCreateWithoutBookingInput[] | PaymentUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutBookingInput | PaymentCreateOrConnectWithoutBookingInput[]
    createMany?: PaymentCreateManyBookingInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutBookingInput = {
    create?: XOR<MessageCreateWithoutBookingInput, MessageUncheckedCreateWithoutBookingInput> | MessageCreateWithoutBookingInput[] | MessageUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutBookingInput | MessageCreateOrConnectWithoutBookingInput[]
    createMany?: MessageCreateManyBookingInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type EnumBookingStatusFieldUpdateOperationsInput = {
    set?: $Enums.BookingStatus
  }

  export type EnumPaymentStatusFieldUpdateOperationsInput = {
    set?: $Enums.PaymentStatus
  }

  export type UserUpdateOneRequiredWithoutBookingsNestedInput = {
    create?: XOR<UserCreateWithoutBookingsInput, UserUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBookingsInput
    upsert?: UserUpsertWithoutBookingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBookingsInput, UserUpdateWithoutBookingsInput>, UserUncheckedUpdateWithoutBookingsInput>
  }

  export type VendorUpdateOneRequiredWithoutBookingsNestedInput = {
    create?: XOR<VendorCreateWithoutBookingsInput, VendorUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: VendorCreateOrConnectWithoutBookingsInput
    upsert?: VendorUpsertWithoutBookingsInput
    connect?: VendorWhereUniqueInput
    update?: XOR<XOR<VendorUpdateToOneWithWhereWithoutBookingsInput, VendorUpdateWithoutBookingsInput>, VendorUncheckedUpdateWithoutBookingsInput>
  }

  export type ServiceUpdateOneRequiredWithoutBookingsNestedInput = {
    create?: XOR<ServiceCreateWithoutBookingsInput, ServiceUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutBookingsInput
    upsert?: ServiceUpsertWithoutBookingsInput
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutBookingsInput, ServiceUpdateWithoutBookingsInput>, ServiceUncheckedUpdateWithoutBookingsInput>
  }

  export type PaymentUpdateManyWithoutBookingNestedInput = {
    create?: XOR<PaymentCreateWithoutBookingInput, PaymentUncheckedCreateWithoutBookingInput> | PaymentCreateWithoutBookingInput[] | PaymentUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutBookingInput | PaymentCreateOrConnectWithoutBookingInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutBookingInput | PaymentUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: PaymentCreateManyBookingInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutBookingInput | PaymentUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutBookingInput | PaymentUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutBookingNestedInput = {
    create?: XOR<MessageCreateWithoutBookingInput, MessageUncheckedCreateWithoutBookingInput> | MessageCreateWithoutBookingInput[] | MessageUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutBookingInput | MessageCreateOrConnectWithoutBookingInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutBookingInput | MessageUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: MessageCreateManyBookingInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutBookingInput | MessageUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutBookingInput | MessageUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutBookingNestedInput = {
    create?: XOR<PaymentCreateWithoutBookingInput, PaymentUncheckedCreateWithoutBookingInput> | PaymentCreateWithoutBookingInput[] | PaymentUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutBookingInput | PaymentCreateOrConnectWithoutBookingInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutBookingInput | PaymentUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: PaymentCreateManyBookingInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutBookingInput | PaymentUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutBookingInput | PaymentUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutBookingNestedInput = {
    create?: XOR<MessageCreateWithoutBookingInput, MessageUncheckedCreateWithoutBookingInput> | MessageCreateWithoutBookingInput[] | MessageUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutBookingInput | MessageCreateOrConnectWithoutBookingInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutBookingInput | MessageUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: MessageCreateManyBookingInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutBookingInput | MessageUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutBookingInput | MessageUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type BookingCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<BookingCreateWithoutPaymentsInput, BookingUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: BookingCreateOrConnectWithoutPaymentsInput
    connect?: BookingWhereUniqueInput
  }

  export type BookingUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<BookingCreateWithoutPaymentsInput, BookingUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: BookingCreateOrConnectWithoutPaymentsInput
    upsert?: BookingUpsertWithoutPaymentsInput
    connect?: BookingWhereUniqueInput
    update?: XOR<XOR<BookingUpdateToOneWithWhereWithoutPaymentsInput, BookingUpdateWithoutPaymentsInput>, BookingUncheckedUpdateWithoutPaymentsInput>
  }

  export type MessageCreateattachmentsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutSentMessagesInput = {
    create?: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReceivedMessagesInput = {
    create?: XOR<UserCreateWithoutReceivedMessagesInput, UserUncheckedCreateWithoutReceivedMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type BookingCreateNestedOneWithoutMessagesInput = {
    create?: XOR<BookingCreateWithoutMessagesInput, BookingUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: BookingCreateOrConnectWithoutMessagesInput
    connect?: BookingWhereUniqueInput
  }

  export type MessageUpdateattachmentsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutSentMessagesNestedInput = {
    create?: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentMessagesInput
    upsert?: UserUpsertWithoutSentMessagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSentMessagesInput, UserUpdateWithoutSentMessagesInput>, UserUncheckedUpdateWithoutSentMessagesInput>
  }

  export type UserUpdateOneRequiredWithoutReceivedMessagesNestedInput = {
    create?: XOR<UserCreateWithoutReceivedMessagesInput, UserUncheckedCreateWithoutReceivedMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedMessagesInput
    upsert?: UserUpsertWithoutReceivedMessagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReceivedMessagesInput, UserUpdateWithoutReceivedMessagesInput>, UserUncheckedUpdateWithoutReceivedMessagesInput>
  }

  export type BookingUpdateOneWithoutMessagesNestedInput = {
    create?: XOR<BookingCreateWithoutMessagesInput, BookingUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: BookingCreateOrConnectWithoutMessagesInput
    upsert?: BookingUpsertWithoutMessagesInput
    disconnect?: BookingWhereInput | boolean
    delete?: BookingWhereInput | boolean
    connect?: BookingWhereUniqueInput
    update?: XOR<XOR<BookingUpdateToOneWithWhereWithoutMessagesInput, BookingUpdateWithoutMessagesInput>, BookingUncheckedUpdateWithoutMessagesInput>
  }

  export type UserCreateNestedOneWithoutChatSessionsInput = {
    create?: XOR<UserCreateWithoutChatSessionsInput, UserUncheckedCreateWithoutChatSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutChatSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type VendorCreateNestedOneWithoutChatSessionsInput = {
    create?: XOR<VendorCreateWithoutChatSessionsInput, VendorUncheckedCreateWithoutChatSessionsInput>
    connectOrCreate?: VendorCreateOrConnectWithoutChatSessionsInput
    connect?: VendorWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutChatSessionsNestedInput = {
    create?: XOR<UserCreateWithoutChatSessionsInput, UserUncheckedCreateWithoutChatSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutChatSessionsInput
    upsert?: UserUpsertWithoutChatSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutChatSessionsInput, UserUpdateWithoutChatSessionsInput>, UserUncheckedUpdateWithoutChatSessionsInput>
  }

  export type VendorUpdateOneRequiredWithoutChatSessionsNestedInput = {
    create?: XOR<VendorCreateWithoutChatSessionsInput, VendorUncheckedCreateWithoutChatSessionsInput>
    connectOrCreate?: VendorCreateOrConnectWithoutChatSessionsInput
    upsert?: VendorUpsertWithoutChatSessionsInput
    connect?: VendorWhereUniqueInput
    update?: XOR<XOR<VendorUpdateToOneWithWhereWithoutChatSessionsInput, VendorUpdateWithoutChatSessionsInput>, VendorUncheckedUpdateWithoutChatSessionsInput>
  }

  export type UserCreateNestedOneWithoutReviewsInput = {
    create?: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewsInput
    connect?: UserWhereUniqueInput
  }

  export type VendorCreateNestedOneWithoutReviewsInput = {
    create?: XOR<VendorCreateWithoutReviewsInput, VendorUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: VendorCreateOrConnectWithoutReviewsInput
    connect?: VendorWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewsInput
    upsert?: UserUpsertWithoutReviewsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReviewsInput, UserUpdateWithoutReviewsInput>, UserUncheckedUpdateWithoutReviewsInput>
  }

  export type VendorUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<VendorCreateWithoutReviewsInput, VendorUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: VendorCreateOrConnectWithoutReviewsInput
    upsert?: VendorUpsertWithoutReviewsInput
    connect?: VendorWhereUniqueInput
    update?: XOR<XOR<VendorUpdateToOneWithWhereWithoutReviewsInput, VendorUpdateWithoutReviewsInput>, VendorUncheckedUpdateWithoutReviewsInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type MatrimonialProfileCreateinterestsInput = {
    set: string[]
  }

  export type MatrimonialProfileCreatephotosInput = {
    set: string[]
  }

  export type MatrimonialMessageCreateNestedManyWithoutFromProfileInput = {
    create?: XOR<MatrimonialMessageCreateWithoutFromProfileInput, MatrimonialMessageUncheckedCreateWithoutFromProfileInput> | MatrimonialMessageCreateWithoutFromProfileInput[] | MatrimonialMessageUncheckedCreateWithoutFromProfileInput[]
    connectOrCreate?: MatrimonialMessageCreateOrConnectWithoutFromProfileInput | MatrimonialMessageCreateOrConnectWithoutFromProfileInput[]
    createMany?: MatrimonialMessageCreateManyFromProfileInputEnvelope
    connect?: MatrimonialMessageWhereUniqueInput | MatrimonialMessageWhereUniqueInput[]
  }

  export type MatrimonialMessageCreateNestedManyWithoutToProfileInput = {
    create?: XOR<MatrimonialMessageCreateWithoutToProfileInput, MatrimonialMessageUncheckedCreateWithoutToProfileInput> | MatrimonialMessageCreateWithoutToProfileInput[] | MatrimonialMessageUncheckedCreateWithoutToProfileInput[]
    connectOrCreate?: MatrimonialMessageCreateOrConnectWithoutToProfileInput | MatrimonialMessageCreateOrConnectWithoutToProfileInput[]
    createMany?: MatrimonialMessageCreateManyToProfileInputEnvelope
    connect?: MatrimonialMessageWhereUniqueInput | MatrimonialMessageWhereUniqueInput[]
  }

  export type MatrimonialMessageUncheckedCreateNestedManyWithoutFromProfileInput = {
    create?: XOR<MatrimonialMessageCreateWithoutFromProfileInput, MatrimonialMessageUncheckedCreateWithoutFromProfileInput> | MatrimonialMessageCreateWithoutFromProfileInput[] | MatrimonialMessageUncheckedCreateWithoutFromProfileInput[]
    connectOrCreate?: MatrimonialMessageCreateOrConnectWithoutFromProfileInput | MatrimonialMessageCreateOrConnectWithoutFromProfileInput[]
    createMany?: MatrimonialMessageCreateManyFromProfileInputEnvelope
    connect?: MatrimonialMessageWhereUniqueInput | MatrimonialMessageWhereUniqueInput[]
  }

  export type MatrimonialMessageUncheckedCreateNestedManyWithoutToProfileInput = {
    create?: XOR<MatrimonialMessageCreateWithoutToProfileInput, MatrimonialMessageUncheckedCreateWithoutToProfileInput> | MatrimonialMessageCreateWithoutToProfileInput[] | MatrimonialMessageUncheckedCreateWithoutToProfileInput[]
    connectOrCreate?: MatrimonialMessageCreateOrConnectWithoutToProfileInput | MatrimonialMessageCreateOrConnectWithoutToProfileInput[]
    createMany?: MatrimonialMessageCreateManyToProfileInputEnvelope
    connect?: MatrimonialMessageWhereUniqueInput | MatrimonialMessageWhereUniqueInput[]
  }

  export type EnumGenderFieldUpdateOperationsInput = {
    set?: $Enums.Gender
  }

  export type MatrimonialProfileUpdateinterestsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type MatrimonialProfileUpdatephotosInput = {
    set?: string[]
    push?: string | string[]
  }

  export type MatrimonialMessageUpdateManyWithoutFromProfileNestedInput = {
    create?: XOR<MatrimonialMessageCreateWithoutFromProfileInput, MatrimonialMessageUncheckedCreateWithoutFromProfileInput> | MatrimonialMessageCreateWithoutFromProfileInput[] | MatrimonialMessageUncheckedCreateWithoutFromProfileInput[]
    connectOrCreate?: MatrimonialMessageCreateOrConnectWithoutFromProfileInput | MatrimonialMessageCreateOrConnectWithoutFromProfileInput[]
    upsert?: MatrimonialMessageUpsertWithWhereUniqueWithoutFromProfileInput | MatrimonialMessageUpsertWithWhereUniqueWithoutFromProfileInput[]
    createMany?: MatrimonialMessageCreateManyFromProfileInputEnvelope
    set?: MatrimonialMessageWhereUniqueInput | MatrimonialMessageWhereUniqueInput[]
    disconnect?: MatrimonialMessageWhereUniqueInput | MatrimonialMessageWhereUniqueInput[]
    delete?: MatrimonialMessageWhereUniqueInput | MatrimonialMessageWhereUniqueInput[]
    connect?: MatrimonialMessageWhereUniqueInput | MatrimonialMessageWhereUniqueInput[]
    update?: MatrimonialMessageUpdateWithWhereUniqueWithoutFromProfileInput | MatrimonialMessageUpdateWithWhereUniqueWithoutFromProfileInput[]
    updateMany?: MatrimonialMessageUpdateManyWithWhereWithoutFromProfileInput | MatrimonialMessageUpdateManyWithWhereWithoutFromProfileInput[]
    deleteMany?: MatrimonialMessageScalarWhereInput | MatrimonialMessageScalarWhereInput[]
  }

  export type MatrimonialMessageUpdateManyWithoutToProfileNestedInput = {
    create?: XOR<MatrimonialMessageCreateWithoutToProfileInput, MatrimonialMessageUncheckedCreateWithoutToProfileInput> | MatrimonialMessageCreateWithoutToProfileInput[] | MatrimonialMessageUncheckedCreateWithoutToProfileInput[]
    connectOrCreate?: MatrimonialMessageCreateOrConnectWithoutToProfileInput | MatrimonialMessageCreateOrConnectWithoutToProfileInput[]
    upsert?: MatrimonialMessageUpsertWithWhereUniqueWithoutToProfileInput | MatrimonialMessageUpsertWithWhereUniqueWithoutToProfileInput[]
    createMany?: MatrimonialMessageCreateManyToProfileInputEnvelope
    set?: MatrimonialMessageWhereUniqueInput | MatrimonialMessageWhereUniqueInput[]
    disconnect?: MatrimonialMessageWhereUniqueInput | MatrimonialMessageWhereUniqueInput[]
    delete?: MatrimonialMessageWhereUniqueInput | MatrimonialMessageWhereUniqueInput[]
    connect?: MatrimonialMessageWhereUniqueInput | MatrimonialMessageWhereUniqueInput[]
    update?: MatrimonialMessageUpdateWithWhereUniqueWithoutToProfileInput | MatrimonialMessageUpdateWithWhereUniqueWithoutToProfileInput[]
    updateMany?: MatrimonialMessageUpdateManyWithWhereWithoutToProfileInput | MatrimonialMessageUpdateManyWithWhereWithoutToProfileInput[]
    deleteMany?: MatrimonialMessageScalarWhereInput | MatrimonialMessageScalarWhereInput[]
  }

  export type MatrimonialMessageUncheckedUpdateManyWithoutFromProfileNestedInput = {
    create?: XOR<MatrimonialMessageCreateWithoutFromProfileInput, MatrimonialMessageUncheckedCreateWithoutFromProfileInput> | MatrimonialMessageCreateWithoutFromProfileInput[] | MatrimonialMessageUncheckedCreateWithoutFromProfileInput[]
    connectOrCreate?: MatrimonialMessageCreateOrConnectWithoutFromProfileInput | MatrimonialMessageCreateOrConnectWithoutFromProfileInput[]
    upsert?: MatrimonialMessageUpsertWithWhereUniqueWithoutFromProfileInput | MatrimonialMessageUpsertWithWhereUniqueWithoutFromProfileInput[]
    createMany?: MatrimonialMessageCreateManyFromProfileInputEnvelope
    set?: MatrimonialMessageWhereUniqueInput | MatrimonialMessageWhereUniqueInput[]
    disconnect?: MatrimonialMessageWhereUniqueInput | MatrimonialMessageWhereUniqueInput[]
    delete?: MatrimonialMessageWhereUniqueInput | MatrimonialMessageWhereUniqueInput[]
    connect?: MatrimonialMessageWhereUniqueInput | MatrimonialMessageWhereUniqueInput[]
    update?: MatrimonialMessageUpdateWithWhereUniqueWithoutFromProfileInput | MatrimonialMessageUpdateWithWhereUniqueWithoutFromProfileInput[]
    updateMany?: MatrimonialMessageUpdateManyWithWhereWithoutFromProfileInput | MatrimonialMessageUpdateManyWithWhereWithoutFromProfileInput[]
    deleteMany?: MatrimonialMessageScalarWhereInput | MatrimonialMessageScalarWhereInput[]
  }

  export type MatrimonialMessageUncheckedUpdateManyWithoutToProfileNestedInput = {
    create?: XOR<MatrimonialMessageCreateWithoutToProfileInput, MatrimonialMessageUncheckedCreateWithoutToProfileInput> | MatrimonialMessageCreateWithoutToProfileInput[] | MatrimonialMessageUncheckedCreateWithoutToProfileInput[]
    connectOrCreate?: MatrimonialMessageCreateOrConnectWithoutToProfileInput | MatrimonialMessageCreateOrConnectWithoutToProfileInput[]
    upsert?: MatrimonialMessageUpsertWithWhereUniqueWithoutToProfileInput | MatrimonialMessageUpsertWithWhereUniqueWithoutToProfileInput[]
    createMany?: MatrimonialMessageCreateManyToProfileInputEnvelope
    set?: MatrimonialMessageWhereUniqueInput | MatrimonialMessageWhereUniqueInput[]
    disconnect?: MatrimonialMessageWhereUniqueInput | MatrimonialMessageWhereUniqueInput[]
    delete?: MatrimonialMessageWhereUniqueInput | MatrimonialMessageWhereUniqueInput[]
    connect?: MatrimonialMessageWhereUniqueInput | MatrimonialMessageWhereUniqueInput[]
    update?: MatrimonialMessageUpdateWithWhereUniqueWithoutToProfileInput | MatrimonialMessageUpdateWithWhereUniqueWithoutToProfileInput[]
    updateMany?: MatrimonialMessageUpdateManyWithWhereWithoutToProfileInput | MatrimonialMessageUpdateManyWithWhereWithoutToProfileInput[]
    deleteMany?: MatrimonialMessageScalarWhereInput | MatrimonialMessageScalarWhereInput[]
  }

  export type MatrimonialProfileCreateNestedOneWithoutSentMessagesInput = {
    create?: XOR<MatrimonialProfileCreateWithoutSentMessagesInput, MatrimonialProfileUncheckedCreateWithoutSentMessagesInput>
    connectOrCreate?: MatrimonialProfileCreateOrConnectWithoutSentMessagesInput
    connect?: MatrimonialProfileWhereUniqueInput
  }

  export type MatrimonialProfileCreateNestedOneWithoutReceivedMessagesInput = {
    create?: XOR<MatrimonialProfileCreateWithoutReceivedMessagesInput, MatrimonialProfileUncheckedCreateWithoutReceivedMessagesInput>
    connectOrCreate?: MatrimonialProfileCreateOrConnectWithoutReceivedMessagesInput
    connect?: MatrimonialProfileWhereUniqueInput
  }

  export type MatrimonialProfileUpdateOneRequiredWithoutSentMessagesNestedInput = {
    create?: XOR<MatrimonialProfileCreateWithoutSentMessagesInput, MatrimonialProfileUncheckedCreateWithoutSentMessagesInput>
    connectOrCreate?: MatrimonialProfileCreateOrConnectWithoutSentMessagesInput
    upsert?: MatrimonialProfileUpsertWithoutSentMessagesInput
    connect?: MatrimonialProfileWhereUniqueInput
    update?: XOR<XOR<MatrimonialProfileUpdateToOneWithWhereWithoutSentMessagesInput, MatrimonialProfileUpdateWithoutSentMessagesInput>, MatrimonialProfileUncheckedUpdateWithoutSentMessagesInput>
  }

  export type MatrimonialProfileUpdateOneRequiredWithoutReceivedMessagesNestedInput = {
    create?: XOR<MatrimonialProfileCreateWithoutReceivedMessagesInput, MatrimonialProfileUncheckedCreateWithoutReceivedMessagesInput>
    connectOrCreate?: MatrimonialProfileCreateOrConnectWithoutReceivedMessagesInput
    upsert?: MatrimonialProfileUpsertWithoutReceivedMessagesInput
    connect?: MatrimonialProfileWhereUniqueInput
    update?: XOR<XOR<MatrimonialProfileUpdateToOneWithWhereWithoutReceivedMessagesInput, MatrimonialProfileUpdateWithoutReceivedMessagesInput>, MatrimonialProfileUncheckedUpdateWithoutReceivedMessagesInput>
  }

  export type VendorCreateNestedOneWithoutVerificationDocumentsInput = {
    create?: XOR<VendorCreateWithoutVerificationDocumentsInput, VendorUncheckedCreateWithoutVerificationDocumentsInput>
    connectOrCreate?: VendorCreateOrConnectWithoutVerificationDocumentsInput
    connect?: VendorWhereUniqueInput
  }

  export type VendorUpdateOneRequiredWithoutVerificationDocumentsNestedInput = {
    create?: XOR<VendorCreateWithoutVerificationDocumentsInput, VendorUncheckedCreateWithoutVerificationDocumentsInput>
    connectOrCreate?: VendorCreateOrConnectWithoutVerificationDocumentsInput
    upsert?: VendorUpsertWithoutVerificationDocumentsInput
    connect?: VendorWhereUniqueInput
    update?: XOR<XOR<VendorUpdateToOneWithWhereWithoutVerificationDocumentsInput, VendorUpdateWithoutVerificationDocumentsInput>, VendorUncheckedUpdateWithoutVerificationDocumentsInput>
  }

  export type VendorDynamicFieldCreatefieldOptionsInput = {
    set: string[]
  }

  export type VendorCreateNestedOneWithoutDynamicFieldsInput = {
    create?: XOR<VendorCreateWithoutDynamicFieldsInput, VendorUncheckedCreateWithoutDynamicFieldsInput>
    connectOrCreate?: VendorCreateOrConnectWithoutDynamicFieldsInput
    connect?: VendorWhereUniqueInput
  }

  export type VendorDynamicFieldUpdatefieldOptionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type VendorUpdateOneRequiredWithoutDynamicFieldsNestedInput = {
    create?: XOR<VendorCreateWithoutDynamicFieldsInput, VendorUncheckedCreateWithoutDynamicFieldsInput>
    connectOrCreate?: VendorCreateOrConnectWithoutDynamicFieldsInput
    upsert?: VendorUpsertWithoutDynamicFieldsInput
    connect?: VendorWhereUniqueInput
    update?: XOR<XOR<VendorUpdateToOneWithWhereWithoutDynamicFieldsInput, VendorUpdateWithoutDynamicFieldsInput>, VendorUncheckedUpdateWithoutDynamicFieldsInput>
  }

  export type PackageDynamicFieldCreatefieldOptionsInput = {
    set: string[]
  }

  export type PackageDynamicFieldUpdatefieldOptionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumVendorCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.VendorCategory | EnumVendorCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.VendorCategory[] | ListEnumVendorCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.VendorCategory[] | ListEnumVendorCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumVendorCategoryFilter<$PrismaModel> | $Enums.VendorCategory
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumVerificationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.VerificationStatus | EnumVerificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VerificationStatus[] | ListEnumVerificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VerificationStatus[] | ListEnumVerificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVerificationStatusFilter<$PrismaModel> | $Enums.VerificationStatus
  }

  export type NestedEnumVendorCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VendorCategory | EnumVendorCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.VendorCategory[] | ListEnumVendorCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.VendorCategory[] | ListEnumVendorCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumVendorCategoryWithAggregatesFilter<$PrismaModel> | $Enums.VendorCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVendorCategoryFilter<$PrismaModel>
    _max?: NestedEnumVendorCategoryFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumVerificationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VerificationStatus | EnumVerificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VerificationStatus[] | ListEnumVerificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VerificationStatus[] | ListEnumVerificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVerificationStatusWithAggregatesFilter<$PrismaModel> | $Enums.VerificationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVerificationStatusFilter<$PrismaModel>
    _max?: NestedEnumVerificationStatusFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedEnumBookingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusFilter<$PrismaModel> | $Enums.BookingStatus
  }

  export type NestedEnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type NestedEnumBookingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusWithAggregatesFilter<$PrismaModel> | $Enums.BookingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBookingStatusFilter<$PrismaModel>
    _max?: NestedEnumBookingStatusFilter<$PrismaModel>
  }

  export type NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumGenderFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderFilter<$PrismaModel> | $Enums.Gender
  }

  export type NestedEnumGenderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderWithAggregatesFilter<$PrismaModel> | $Enums.Gender
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGenderFilter<$PrismaModel>
    _max?: NestedEnumGenderFilter<$PrismaModel>
  }

  export type BookingCreateWithoutUserInput = {
    id?: string
    eventDate: Date | string
    eventTime: string
    eventDuration: number
    guestCount?: number | null
    location?: string | null
    specialRequests?: string | null
    basePrice: number
    additionalCosts?: number
    totalAmount: number
    status?: $Enums.BookingStatus
    paymentStatus?: $Enums.PaymentStatus
    requestedAt?: Date | string
    approvedAt?: Date | string | null
    confirmedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    vendor: VendorCreateNestedOneWithoutBookingsInput
    service: ServiceCreateNestedOneWithoutBookingsInput
    payments?: PaymentCreateNestedManyWithoutBookingInput
    messages?: MessageCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutUserInput = {
    id?: string
    vendorId: string
    serviceId: string
    eventDate: Date | string
    eventTime: string
    eventDuration: number
    guestCount?: number | null
    location?: string | null
    specialRequests?: string | null
    basePrice: number
    additionalCosts?: number
    totalAmount: number
    status?: $Enums.BookingStatus
    paymentStatus?: $Enums.PaymentStatus
    requestedAt?: Date | string
    approvedAt?: Date | string | null
    confirmedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutBookingInput
    messages?: MessageUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutUserInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutUserInput, BookingUncheckedCreateWithoutUserInput>
  }

  export type BookingCreateManyUserInputEnvelope = {
    data: BookingCreateManyUserInput | BookingCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutSenderInput = {
    id?: string
    content: string
    messageType?: string
    attachments?: MessageCreateattachmentsInput | string[]
    isRead?: boolean
    createdAt?: Date | string
    receiver: UserCreateNestedOneWithoutReceivedMessagesInput
    booking?: BookingCreateNestedOneWithoutMessagesInput
  }

  export type MessageUncheckedCreateWithoutSenderInput = {
    id?: string
    receiverId: string
    bookingId?: string | null
    content: string
    messageType?: string
    attachments?: MessageCreateattachmentsInput | string[]
    isRead?: boolean
    createdAt?: Date | string
  }

  export type MessageCreateOrConnectWithoutSenderInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput>
  }

  export type MessageCreateManySenderInputEnvelope = {
    data: MessageCreateManySenderInput | MessageCreateManySenderInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutReceiverInput = {
    id?: string
    content: string
    messageType?: string
    attachments?: MessageCreateattachmentsInput | string[]
    isRead?: boolean
    createdAt?: Date | string
    sender: UserCreateNestedOneWithoutSentMessagesInput
    booking?: BookingCreateNestedOneWithoutMessagesInput
  }

  export type MessageUncheckedCreateWithoutReceiverInput = {
    id?: string
    senderId: string
    bookingId?: string | null
    content: string
    messageType?: string
    attachments?: MessageCreateattachmentsInput | string[]
    isRead?: boolean
    createdAt?: Date | string
  }

  export type MessageCreateOrConnectWithoutReceiverInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutReceiverInput, MessageUncheckedCreateWithoutReceiverInput>
  }

  export type MessageCreateManyReceiverInputEnvelope = {
    data: MessageCreateManyReceiverInput | MessageCreateManyReceiverInput[]
    skipDuplicates?: boolean
  }

  export type ReviewCreateWithoutUserInput = {
    id?: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    vendor: VendorCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateWithoutUserInput = {
    id?: string
    vendorId: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewCreateOrConnectWithoutUserInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput>
  }

  export type ReviewCreateManyUserInputEnvelope = {
    data: ReviewCreateManyUserInput | ReviewCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    title: string
    message: string
    type: string
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    message: string
    type: string
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ChatSessionCreateWithoutUserInput = {
    id?: string
    lastMessageAt?: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    vendor: VendorCreateNestedOneWithoutChatSessionsInput
  }

  export type ChatSessionUncheckedCreateWithoutUserInput = {
    id?: string
    vendorId: string
    lastMessageAt?: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChatSessionCreateOrConnectWithoutUserInput = {
    where: ChatSessionWhereUniqueInput
    create: XOR<ChatSessionCreateWithoutUserInput, ChatSessionUncheckedCreateWithoutUserInput>
  }

  export type ChatSessionCreateManyUserInputEnvelope = {
    data: ChatSessionCreateManyUserInput | ChatSessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type VendorCreateWithoutUserInput = {
    id?: string
    businessName: string
    category: $Enums.VendorCategory
    description: string
    location: string
    phone: string
    email: string
    website?: string | null
    experience?: number
    rating?: number
    totalReviews?: number
    isVerified?: boolean
    isActive?: boolean
    verificationStatus?: $Enums.VerificationStatus
    documentSignedAt?: Date | string | null
    verificationNotes?: string | null
    basePrice?: number | null
    priceRange?: string | null
    profileImage?: string | null
    gallery?: VendorCreategalleryInput | string[]
    availability?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingCreateNestedManyWithoutVendorInput
    services?: ServiceCreateNestedManyWithoutVendorInput
    reviews?: ReviewCreateNestedManyWithoutVendorInput
    chatSessions?: ChatSessionCreateNestedManyWithoutVendorInput
    verificationDocuments?: VendorVerificationDocumentCreateNestedManyWithoutVendorInput
    dynamicFields?: VendorDynamicFieldCreateNestedManyWithoutVendorInput
  }

  export type VendorUncheckedCreateWithoutUserInput = {
    id?: string
    businessName: string
    category: $Enums.VendorCategory
    description: string
    location: string
    phone: string
    email: string
    website?: string | null
    experience?: number
    rating?: number
    totalReviews?: number
    isVerified?: boolean
    isActive?: boolean
    verificationStatus?: $Enums.VerificationStatus
    documentSignedAt?: Date | string | null
    verificationNotes?: string | null
    basePrice?: number | null
    priceRange?: string | null
    profileImage?: string | null
    gallery?: VendorCreategalleryInput | string[]
    availability?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutVendorInput
    services?: ServiceUncheckedCreateNestedManyWithoutVendorInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutVendorInput
    chatSessions?: ChatSessionUncheckedCreateNestedManyWithoutVendorInput
    verificationDocuments?: VendorVerificationDocumentUncheckedCreateNestedManyWithoutVendorInput
    dynamicFields?: VendorDynamicFieldUncheckedCreateNestedManyWithoutVendorInput
  }

  export type VendorCreateOrConnectWithoutUserInput = {
    where: VendorWhereUniqueInput
    create: XOR<VendorCreateWithoutUserInput, VendorUncheckedCreateWithoutUserInput>
  }

  export type BookingUpsertWithWhereUniqueWithoutUserInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutUserInput, BookingUncheckedUpdateWithoutUserInput>
    create: XOR<BookingCreateWithoutUserInput, BookingUncheckedCreateWithoutUserInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutUserInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutUserInput, BookingUncheckedUpdateWithoutUserInput>
  }

  export type BookingUpdateManyWithWhereWithoutUserInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutUserInput>
  }

  export type BookingScalarWhereInput = {
    AND?: BookingScalarWhereInput | BookingScalarWhereInput[]
    OR?: BookingScalarWhereInput[]
    NOT?: BookingScalarWhereInput | BookingScalarWhereInput[]
    id?: StringFilter<"Booking"> | string
    userId?: StringFilter<"Booking"> | string
    vendorId?: StringFilter<"Booking"> | string
    serviceId?: StringFilter<"Booking"> | string
    eventDate?: DateTimeFilter<"Booking"> | Date | string
    eventTime?: StringFilter<"Booking"> | string
    eventDuration?: IntFilter<"Booking"> | number
    guestCount?: IntNullableFilter<"Booking"> | number | null
    location?: StringNullableFilter<"Booking"> | string | null
    specialRequests?: StringNullableFilter<"Booking"> | string | null
    basePrice?: FloatFilter<"Booking"> | number
    additionalCosts?: FloatFilter<"Booking"> | number
    totalAmount?: FloatFilter<"Booking"> | number
    status?: EnumBookingStatusFilter<"Booking"> | $Enums.BookingStatus
    paymentStatus?: EnumPaymentStatusFilter<"Booking"> | $Enums.PaymentStatus
    requestedAt?: DateTimeFilter<"Booking"> | Date | string
    approvedAt?: DateTimeNullableFilter<"Booking"> | Date | string | null
    confirmedAt?: DateTimeNullableFilter<"Booking"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Booking"> | Date | string | null
    createdAt?: DateTimeFilter<"Booking"> | Date | string
    updatedAt?: DateTimeFilter<"Booking"> | Date | string
  }

  export type MessageUpsertWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutSenderInput, MessageUncheckedUpdateWithoutSenderInput>
    create: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutSenderInput, MessageUncheckedUpdateWithoutSenderInput>
  }

  export type MessageUpdateManyWithWhereWithoutSenderInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutSenderInput>
  }

  export type MessageScalarWhereInput = {
    AND?: MessageScalarWhereInput | MessageScalarWhereInput[]
    OR?: MessageScalarWhereInput[]
    NOT?: MessageScalarWhereInput | MessageScalarWhereInput[]
    id?: StringFilter<"Message"> | string
    senderId?: StringFilter<"Message"> | string
    receiverId?: StringFilter<"Message"> | string
    bookingId?: StringNullableFilter<"Message"> | string | null
    content?: StringFilter<"Message"> | string
    messageType?: StringFilter<"Message"> | string
    attachments?: StringNullableListFilter<"Message">
    isRead?: BoolFilter<"Message"> | boolean
    createdAt?: DateTimeFilter<"Message"> | Date | string
  }

  export type MessageUpsertWithWhereUniqueWithoutReceiverInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutReceiverInput, MessageUncheckedUpdateWithoutReceiverInput>
    create: XOR<MessageCreateWithoutReceiverInput, MessageUncheckedCreateWithoutReceiverInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutReceiverInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutReceiverInput, MessageUncheckedUpdateWithoutReceiverInput>
  }

  export type MessageUpdateManyWithWhereWithoutReceiverInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutReceiverInput>
  }

  export type ReviewUpsertWithWhereUniqueWithoutUserInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutUserInput, ReviewUncheckedUpdateWithoutUserInput>
    create: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutUserInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutUserInput, ReviewUncheckedUpdateWithoutUserInput>
  }

  export type ReviewUpdateManyWithWhereWithoutUserInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutUserInput>
  }

  export type ReviewScalarWhereInput = {
    AND?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
    OR?: ReviewScalarWhereInput[]
    NOT?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
    id?: StringFilter<"Review"> | string
    userId?: StringFilter<"Review"> | string
    vendorId?: StringFilter<"Review"> | string
    rating?: IntFilter<"Review"> | number
    comment?: StringNullableFilter<"Review"> | string | null
    createdAt?: DateTimeFilter<"Review"> | Date | string
    updatedAt?: DateTimeFilter<"Review"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type ChatSessionUpsertWithWhereUniqueWithoutUserInput = {
    where: ChatSessionWhereUniqueInput
    update: XOR<ChatSessionUpdateWithoutUserInput, ChatSessionUncheckedUpdateWithoutUserInput>
    create: XOR<ChatSessionCreateWithoutUserInput, ChatSessionUncheckedCreateWithoutUserInput>
  }

  export type ChatSessionUpdateWithWhereUniqueWithoutUserInput = {
    where: ChatSessionWhereUniqueInput
    data: XOR<ChatSessionUpdateWithoutUserInput, ChatSessionUncheckedUpdateWithoutUserInput>
  }

  export type ChatSessionUpdateManyWithWhereWithoutUserInput = {
    where: ChatSessionScalarWhereInput
    data: XOR<ChatSessionUpdateManyMutationInput, ChatSessionUncheckedUpdateManyWithoutUserInput>
  }

  export type ChatSessionScalarWhereInput = {
    AND?: ChatSessionScalarWhereInput | ChatSessionScalarWhereInput[]
    OR?: ChatSessionScalarWhereInput[]
    NOT?: ChatSessionScalarWhereInput | ChatSessionScalarWhereInput[]
    id?: StringFilter<"ChatSession"> | string
    userId?: StringFilter<"ChatSession"> | string
    vendorId?: StringFilter<"ChatSession"> | string
    lastMessageAt?: DateTimeFilter<"ChatSession"> | Date | string
    isActive?: BoolFilter<"ChatSession"> | boolean
    createdAt?: DateTimeFilter<"ChatSession"> | Date | string
    updatedAt?: DateTimeFilter<"ChatSession"> | Date | string
  }

  export type VendorUpsertWithoutUserInput = {
    update: XOR<VendorUpdateWithoutUserInput, VendorUncheckedUpdateWithoutUserInput>
    create: XOR<VendorCreateWithoutUserInput, VendorUncheckedCreateWithoutUserInput>
    where?: VendorWhereInput
  }

  export type VendorUpdateToOneWithWhereWithoutUserInput = {
    where?: VendorWhereInput
    data: XOR<VendorUpdateWithoutUserInput, VendorUncheckedUpdateWithoutUserInput>
  }

  export type VendorUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessName?: StringFieldUpdateOperationsInput | string
    category?: EnumVendorCategoryFieldUpdateOperationsInput | $Enums.VendorCategory
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: IntFieldUpdateOperationsInput | number
    rating?: FloatFieldUpdateOperationsInput | number
    totalReviews?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    documentSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    priceRange?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    gallery?: VendorUpdategalleryInput | string[]
    availability?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUpdateManyWithoutVendorNestedInput
    services?: ServiceUpdateManyWithoutVendorNestedInput
    reviews?: ReviewUpdateManyWithoutVendorNestedInput
    chatSessions?: ChatSessionUpdateManyWithoutVendorNestedInput
    verificationDocuments?: VendorVerificationDocumentUpdateManyWithoutVendorNestedInput
    dynamicFields?: VendorDynamicFieldUpdateManyWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessName?: StringFieldUpdateOperationsInput | string
    category?: EnumVendorCategoryFieldUpdateOperationsInput | $Enums.VendorCategory
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: IntFieldUpdateOperationsInput | number
    rating?: FloatFieldUpdateOperationsInput | number
    totalReviews?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    documentSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    priceRange?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    gallery?: VendorUpdategalleryInput | string[]
    availability?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutVendorNestedInput
    services?: ServiceUncheckedUpdateManyWithoutVendorNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutVendorNestedInput
    chatSessions?: ChatSessionUncheckedUpdateManyWithoutVendorNestedInput
    verificationDocuments?: VendorVerificationDocumentUncheckedUpdateManyWithoutVendorNestedInput
    dynamicFields?: VendorDynamicFieldUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type UserCreateWithoutVendorInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isVerified?: boolean
    profileImage?: string | null
    weddingDate?: Date | string | null
    budget?: number | null
    location?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    chatSessions?: ChatSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutVendorInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isVerified?: boolean
    profileImage?: string | null
    weddingDate?: Date | string | null
    budget?: number | null
    location?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    chatSessions?: ChatSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutVendorInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutVendorInput, UserUncheckedCreateWithoutVendorInput>
  }

  export type BookingCreateWithoutVendorInput = {
    id?: string
    eventDate: Date | string
    eventTime: string
    eventDuration: number
    guestCount?: number | null
    location?: string | null
    specialRequests?: string | null
    basePrice: number
    additionalCosts?: number
    totalAmount: number
    status?: $Enums.BookingStatus
    paymentStatus?: $Enums.PaymentStatus
    requestedAt?: Date | string
    approvedAt?: Date | string | null
    confirmedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutBookingsInput
    service: ServiceCreateNestedOneWithoutBookingsInput
    payments?: PaymentCreateNestedManyWithoutBookingInput
    messages?: MessageCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutVendorInput = {
    id?: string
    userId: string
    serviceId: string
    eventDate: Date | string
    eventTime: string
    eventDuration: number
    guestCount?: number | null
    location?: string | null
    specialRequests?: string | null
    basePrice: number
    additionalCosts?: number
    totalAmount: number
    status?: $Enums.BookingStatus
    paymentStatus?: $Enums.PaymentStatus
    requestedAt?: Date | string
    approvedAt?: Date | string | null
    confirmedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutBookingInput
    messages?: MessageUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutVendorInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutVendorInput, BookingUncheckedCreateWithoutVendorInput>
  }

  export type BookingCreateManyVendorInputEnvelope = {
    data: BookingCreateManyVendorInput | BookingCreateManyVendorInput[]
    skipDuplicates?: boolean
  }

  export type ServiceCreateWithoutVendorInput = {
    id?: string
    name: string
    description: string
    price: number
    duration?: number | null
    maxCapacity?: number | null
    includes?: ServiceCreateincludesInput | string[]
    addOns?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutVendorInput = {
    id?: string
    name: string
    description: string
    price: number
    duration?: number | null
    maxCapacity?: number | null
    includes?: ServiceCreateincludesInput | string[]
    addOns?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutVendorInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutVendorInput, ServiceUncheckedCreateWithoutVendorInput>
  }

  export type ServiceCreateManyVendorInputEnvelope = {
    data: ServiceCreateManyVendorInput | ServiceCreateManyVendorInput[]
    skipDuplicates?: boolean
  }

  export type ReviewCreateWithoutVendorInput = {
    id?: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateWithoutVendorInput = {
    id?: string
    userId: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewCreateOrConnectWithoutVendorInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutVendorInput, ReviewUncheckedCreateWithoutVendorInput>
  }

  export type ReviewCreateManyVendorInputEnvelope = {
    data: ReviewCreateManyVendorInput | ReviewCreateManyVendorInput[]
    skipDuplicates?: boolean
  }

  export type ChatSessionCreateWithoutVendorInput = {
    id?: string
    lastMessageAt?: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutChatSessionsInput
  }

  export type ChatSessionUncheckedCreateWithoutVendorInput = {
    id?: string
    userId: string
    lastMessageAt?: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChatSessionCreateOrConnectWithoutVendorInput = {
    where: ChatSessionWhereUniqueInput
    create: XOR<ChatSessionCreateWithoutVendorInput, ChatSessionUncheckedCreateWithoutVendorInput>
  }

  export type ChatSessionCreateManyVendorInputEnvelope = {
    data: ChatSessionCreateManyVendorInput | ChatSessionCreateManyVendorInput[]
    skipDuplicates?: boolean
  }

  export type VendorVerificationDocumentCreateWithoutVendorInput = {
    id?: string
    documentType: string
    documentTitle: string
    documentContent: string
    documentHash: string
    signingToken: string
    tokenExpiresAt: Date | string
    signedAt?: Date | string | null
    signatureData?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    ipAddress?: string | null
    userAgent?: string | null
    reviewedBy?: string | null
    reviewedAt?: Date | string | null
    reviewNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VendorVerificationDocumentUncheckedCreateWithoutVendorInput = {
    id?: string
    documentType: string
    documentTitle: string
    documentContent: string
    documentHash: string
    signingToken: string
    tokenExpiresAt: Date | string
    signedAt?: Date | string | null
    signatureData?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    ipAddress?: string | null
    userAgent?: string | null
    reviewedBy?: string | null
    reviewedAt?: Date | string | null
    reviewNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VendorVerificationDocumentCreateOrConnectWithoutVendorInput = {
    where: VendorVerificationDocumentWhereUniqueInput
    create: XOR<VendorVerificationDocumentCreateWithoutVendorInput, VendorVerificationDocumentUncheckedCreateWithoutVendorInput>
  }

  export type VendorVerificationDocumentCreateManyVendorInputEnvelope = {
    data: VendorVerificationDocumentCreateManyVendorInput | VendorVerificationDocumentCreateManyVendorInput[]
    skipDuplicates?: boolean
  }

  export type VendorDynamicFieldCreateWithoutVendorInput = {
    id?: string
    fieldName: string
    fieldLabel: string
    fieldType: string
    fieldOptions?: VendorDynamicFieldCreatefieldOptionsInput | string[]
    fieldValue?: string | null
    isRequired?: boolean
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VendorDynamicFieldUncheckedCreateWithoutVendorInput = {
    id?: string
    fieldName: string
    fieldLabel: string
    fieldType: string
    fieldOptions?: VendorDynamicFieldCreatefieldOptionsInput | string[]
    fieldValue?: string | null
    isRequired?: boolean
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VendorDynamicFieldCreateOrConnectWithoutVendorInput = {
    where: VendorDynamicFieldWhereUniqueInput
    create: XOR<VendorDynamicFieldCreateWithoutVendorInput, VendorDynamicFieldUncheckedCreateWithoutVendorInput>
  }

  export type VendorDynamicFieldCreateManyVendorInputEnvelope = {
    data: VendorDynamicFieldCreateManyVendorInput | VendorDynamicFieldCreateManyVendorInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutVendorInput = {
    update: XOR<UserUpdateWithoutVendorInput, UserUncheckedUpdateWithoutVendorInput>
    create: XOR<UserCreateWithoutVendorInput, UserUncheckedCreateWithoutVendorInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutVendorInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutVendorInput, UserUncheckedUpdateWithoutVendorInput>
  }

  export type UserUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    weddingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    chatSessions?: ChatSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    weddingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    chatSessions?: ChatSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BookingUpsertWithWhereUniqueWithoutVendorInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutVendorInput, BookingUncheckedUpdateWithoutVendorInput>
    create: XOR<BookingCreateWithoutVendorInput, BookingUncheckedCreateWithoutVendorInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutVendorInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutVendorInput, BookingUncheckedUpdateWithoutVendorInput>
  }

  export type BookingUpdateManyWithWhereWithoutVendorInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutVendorInput>
  }

  export type ServiceUpsertWithWhereUniqueWithoutVendorInput = {
    where: ServiceWhereUniqueInput
    update: XOR<ServiceUpdateWithoutVendorInput, ServiceUncheckedUpdateWithoutVendorInput>
    create: XOR<ServiceCreateWithoutVendorInput, ServiceUncheckedCreateWithoutVendorInput>
  }

  export type ServiceUpdateWithWhereUniqueWithoutVendorInput = {
    where: ServiceWhereUniqueInput
    data: XOR<ServiceUpdateWithoutVendorInput, ServiceUncheckedUpdateWithoutVendorInput>
  }

  export type ServiceUpdateManyWithWhereWithoutVendorInput = {
    where: ServiceScalarWhereInput
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyWithoutVendorInput>
  }

  export type ServiceScalarWhereInput = {
    AND?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
    OR?: ServiceScalarWhereInput[]
    NOT?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
    id?: StringFilter<"Service"> | string
    vendorId?: StringFilter<"Service"> | string
    name?: StringFilter<"Service"> | string
    description?: StringFilter<"Service"> | string
    price?: FloatFilter<"Service"> | number
    duration?: IntNullableFilter<"Service"> | number | null
    maxCapacity?: IntNullableFilter<"Service"> | number | null
    includes?: StringNullableListFilter<"Service">
    addOns?: JsonNullableFilter<"Service">
    isActive?: BoolFilter<"Service"> | boolean
    createdAt?: DateTimeFilter<"Service"> | Date | string
    updatedAt?: DateTimeFilter<"Service"> | Date | string
  }

  export type ReviewUpsertWithWhereUniqueWithoutVendorInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutVendorInput, ReviewUncheckedUpdateWithoutVendorInput>
    create: XOR<ReviewCreateWithoutVendorInput, ReviewUncheckedCreateWithoutVendorInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutVendorInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutVendorInput, ReviewUncheckedUpdateWithoutVendorInput>
  }

  export type ReviewUpdateManyWithWhereWithoutVendorInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutVendorInput>
  }

  export type ChatSessionUpsertWithWhereUniqueWithoutVendorInput = {
    where: ChatSessionWhereUniqueInput
    update: XOR<ChatSessionUpdateWithoutVendorInput, ChatSessionUncheckedUpdateWithoutVendorInput>
    create: XOR<ChatSessionCreateWithoutVendorInput, ChatSessionUncheckedCreateWithoutVendorInput>
  }

  export type ChatSessionUpdateWithWhereUniqueWithoutVendorInput = {
    where: ChatSessionWhereUniqueInput
    data: XOR<ChatSessionUpdateWithoutVendorInput, ChatSessionUncheckedUpdateWithoutVendorInput>
  }

  export type ChatSessionUpdateManyWithWhereWithoutVendorInput = {
    where: ChatSessionScalarWhereInput
    data: XOR<ChatSessionUpdateManyMutationInput, ChatSessionUncheckedUpdateManyWithoutVendorInput>
  }

  export type VendorVerificationDocumentUpsertWithWhereUniqueWithoutVendorInput = {
    where: VendorVerificationDocumentWhereUniqueInput
    update: XOR<VendorVerificationDocumentUpdateWithoutVendorInput, VendorVerificationDocumentUncheckedUpdateWithoutVendorInput>
    create: XOR<VendorVerificationDocumentCreateWithoutVendorInput, VendorVerificationDocumentUncheckedCreateWithoutVendorInput>
  }

  export type VendorVerificationDocumentUpdateWithWhereUniqueWithoutVendorInput = {
    where: VendorVerificationDocumentWhereUniqueInput
    data: XOR<VendorVerificationDocumentUpdateWithoutVendorInput, VendorVerificationDocumentUncheckedUpdateWithoutVendorInput>
  }

  export type VendorVerificationDocumentUpdateManyWithWhereWithoutVendorInput = {
    where: VendorVerificationDocumentScalarWhereInput
    data: XOR<VendorVerificationDocumentUpdateManyMutationInput, VendorVerificationDocumentUncheckedUpdateManyWithoutVendorInput>
  }

  export type VendorVerificationDocumentScalarWhereInput = {
    AND?: VendorVerificationDocumentScalarWhereInput | VendorVerificationDocumentScalarWhereInput[]
    OR?: VendorVerificationDocumentScalarWhereInput[]
    NOT?: VendorVerificationDocumentScalarWhereInput | VendorVerificationDocumentScalarWhereInput[]
    id?: StringFilter<"VendorVerificationDocument"> | string
    vendorId?: StringFilter<"VendorVerificationDocument"> | string
    documentType?: StringFilter<"VendorVerificationDocument"> | string
    documentTitle?: StringFilter<"VendorVerificationDocument"> | string
    documentContent?: StringFilter<"VendorVerificationDocument"> | string
    documentHash?: StringFilter<"VendorVerificationDocument"> | string
    signingToken?: StringFilter<"VendorVerificationDocument"> | string
    tokenExpiresAt?: DateTimeFilter<"VendorVerificationDocument"> | Date | string
    signedAt?: DateTimeNullableFilter<"VendorVerificationDocument"> | Date | string | null
    signatureData?: JsonNullableFilter<"VendorVerificationDocument">
    status?: StringFilter<"VendorVerificationDocument"> | string
    ipAddress?: StringNullableFilter<"VendorVerificationDocument"> | string | null
    userAgent?: StringNullableFilter<"VendorVerificationDocument"> | string | null
    reviewedBy?: StringNullableFilter<"VendorVerificationDocument"> | string | null
    reviewedAt?: DateTimeNullableFilter<"VendorVerificationDocument"> | Date | string | null
    reviewNotes?: StringNullableFilter<"VendorVerificationDocument"> | string | null
    createdAt?: DateTimeFilter<"VendorVerificationDocument"> | Date | string
    updatedAt?: DateTimeFilter<"VendorVerificationDocument"> | Date | string
  }

  export type VendorDynamicFieldUpsertWithWhereUniqueWithoutVendorInput = {
    where: VendorDynamicFieldWhereUniqueInput
    update: XOR<VendorDynamicFieldUpdateWithoutVendorInput, VendorDynamicFieldUncheckedUpdateWithoutVendorInput>
    create: XOR<VendorDynamicFieldCreateWithoutVendorInput, VendorDynamicFieldUncheckedCreateWithoutVendorInput>
  }

  export type VendorDynamicFieldUpdateWithWhereUniqueWithoutVendorInput = {
    where: VendorDynamicFieldWhereUniqueInput
    data: XOR<VendorDynamicFieldUpdateWithoutVendorInput, VendorDynamicFieldUncheckedUpdateWithoutVendorInput>
  }

  export type VendorDynamicFieldUpdateManyWithWhereWithoutVendorInput = {
    where: VendorDynamicFieldScalarWhereInput
    data: XOR<VendorDynamicFieldUpdateManyMutationInput, VendorDynamicFieldUncheckedUpdateManyWithoutVendorInput>
  }

  export type VendorDynamicFieldScalarWhereInput = {
    AND?: VendorDynamicFieldScalarWhereInput | VendorDynamicFieldScalarWhereInput[]
    OR?: VendorDynamicFieldScalarWhereInput[]
    NOT?: VendorDynamicFieldScalarWhereInput | VendorDynamicFieldScalarWhereInput[]
    id?: StringFilter<"VendorDynamicField"> | string
    vendorId?: StringFilter<"VendorDynamicField"> | string
    fieldName?: StringFilter<"VendorDynamicField"> | string
    fieldLabel?: StringFilter<"VendorDynamicField"> | string
    fieldType?: StringFilter<"VendorDynamicField"> | string
    fieldOptions?: StringNullableListFilter<"VendorDynamicField">
    fieldValue?: StringNullableFilter<"VendorDynamicField"> | string | null
    isRequired?: BoolFilter<"VendorDynamicField"> | boolean
    displayOrder?: IntFilter<"VendorDynamicField"> | number
    createdAt?: DateTimeFilter<"VendorDynamicField"> | Date | string
    updatedAt?: DateTimeFilter<"VendorDynamicField"> | Date | string
  }

  export type VendorCreateWithoutServicesInput = {
    id?: string
    businessName: string
    category: $Enums.VendorCategory
    description: string
    location: string
    phone: string
    email: string
    website?: string | null
    experience?: number
    rating?: number
    totalReviews?: number
    isVerified?: boolean
    isActive?: boolean
    verificationStatus?: $Enums.VerificationStatus
    documentSignedAt?: Date | string | null
    verificationNotes?: string | null
    basePrice?: number | null
    priceRange?: string | null
    profileImage?: string | null
    gallery?: VendorCreategalleryInput | string[]
    availability?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutVendorInput
    bookings?: BookingCreateNestedManyWithoutVendorInput
    reviews?: ReviewCreateNestedManyWithoutVendorInput
    chatSessions?: ChatSessionCreateNestedManyWithoutVendorInput
    verificationDocuments?: VendorVerificationDocumentCreateNestedManyWithoutVendorInput
    dynamicFields?: VendorDynamicFieldCreateNestedManyWithoutVendorInput
  }

  export type VendorUncheckedCreateWithoutServicesInput = {
    id?: string
    userId: string
    businessName: string
    category: $Enums.VendorCategory
    description: string
    location: string
    phone: string
    email: string
    website?: string | null
    experience?: number
    rating?: number
    totalReviews?: number
    isVerified?: boolean
    isActive?: boolean
    verificationStatus?: $Enums.VerificationStatus
    documentSignedAt?: Date | string | null
    verificationNotes?: string | null
    basePrice?: number | null
    priceRange?: string | null
    profileImage?: string | null
    gallery?: VendorCreategalleryInput | string[]
    availability?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutVendorInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutVendorInput
    chatSessions?: ChatSessionUncheckedCreateNestedManyWithoutVendorInput
    verificationDocuments?: VendorVerificationDocumentUncheckedCreateNestedManyWithoutVendorInput
    dynamicFields?: VendorDynamicFieldUncheckedCreateNestedManyWithoutVendorInput
  }

  export type VendorCreateOrConnectWithoutServicesInput = {
    where: VendorWhereUniqueInput
    create: XOR<VendorCreateWithoutServicesInput, VendorUncheckedCreateWithoutServicesInput>
  }

  export type BookingCreateWithoutServiceInput = {
    id?: string
    eventDate: Date | string
    eventTime: string
    eventDuration: number
    guestCount?: number | null
    location?: string | null
    specialRequests?: string | null
    basePrice: number
    additionalCosts?: number
    totalAmount: number
    status?: $Enums.BookingStatus
    paymentStatus?: $Enums.PaymentStatus
    requestedAt?: Date | string
    approvedAt?: Date | string | null
    confirmedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutBookingsInput
    vendor: VendorCreateNestedOneWithoutBookingsInput
    payments?: PaymentCreateNestedManyWithoutBookingInput
    messages?: MessageCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutServiceInput = {
    id?: string
    userId: string
    vendorId: string
    eventDate: Date | string
    eventTime: string
    eventDuration: number
    guestCount?: number | null
    location?: string | null
    specialRequests?: string | null
    basePrice: number
    additionalCosts?: number
    totalAmount: number
    status?: $Enums.BookingStatus
    paymentStatus?: $Enums.PaymentStatus
    requestedAt?: Date | string
    approvedAt?: Date | string | null
    confirmedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutBookingInput
    messages?: MessageUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutServiceInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutServiceInput, BookingUncheckedCreateWithoutServiceInput>
  }

  export type BookingCreateManyServiceInputEnvelope = {
    data: BookingCreateManyServiceInput | BookingCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type VendorUpsertWithoutServicesInput = {
    update: XOR<VendorUpdateWithoutServicesInput, VendorUncheckedUpdateWithoutServicesInput>
    create: XOR<VendorCreateWithoutServicesInput, VendorUncheckedCreateWithoutServicesInput>
    where?: VendorWhereInput
  }

  export type VendorUpdateToOneWithWhereWithoutServicesInput = {
    where?: VendorWhereInput
    data: XOR<VendorUpdateWithoutServicesInput, VendorUncheckedUpdateWithoutServicesInput>
  }

  export type VendorUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessName?: StringFieldUpdateOperationsInput | string
    category?: EnumVendorCategoryFieldUpdateOperationsInput | $Enums.VendorCategory
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: IntFieldUpdateOperationsInput | number
    rating?: FloatFieldUpdateOperationsInput | number
    totalReviews?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    documentSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    priceRange?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    gallery?: VendorUpdategalleryInput | string[]
    availability?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutVendorNestedInput
    bookings?: BookingUpdateManyWithoutVendorNestedInput
    reviews?: ReviewUpdateManyWithoutVendorNestedInput
    chatSessions?: ChatSessionUpdateManyWithoutVendorNestedInput
    verificationDocuments?: VendorVerificationDocumentUpdateManyWithoutVendorNestedInput
    dynamicFields?: VendorDynamicFieldUpdateManyWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    businessName?: StringFieldUpdateOperationsInput | string
    category?: EnumVendorCategoryFieldUpdateOperationsInput | $Enums.VendorCategory
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: IntFieldUpdateOperationsInput | number
    rating?: FloatFieldUpdateOperationsInput | number
    totalReviews?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    documentSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    priceRange?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    gallery?: VendorUpdategalleryInput | string[]
    availability?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutVendorNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutVendorNestedInput
    chatSessions?: ChatSessionUncheckedUpdateManyWithoutVendorNestedInput
    verificationDocuments?: VendorVerificationDocumentUncheckedUpdateManyWithoutVendorNestedInput
    dynamicFields?: VendorDynamicFieldUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type BookingUpsertWithWhereUniqueWithoutServiceInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutServiceInput, BookingUncheckedUpdateWithoutServiceInput>
    create: XOR<BookingCreateWithoutServiceInput, BookingUncheckedCreateWithoutServiceInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutServiceInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutServiceInput, BookingUncheckedUpdateWithoutServiceInput>
  }

  export type BookingUpdateManyWithWhereWithoutServiceInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutServiceInput>
  }

  export type UserCreateWithoutBookingsInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isVerified?: boolean
    profileImage?: string | null
    weddingDate?: Date | string | null
    budget?: number | null
    location?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    chatSessions?: ChatSessionCreateNestedManyWithoutUserInput
    vendor?: VendorCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBookingsInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isVerified?: boolean
    profileImage?: string | null
    weddingDate?: Date | string | null
    budget?: number | null
    location?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    chatSessions?: ChatSessionUncheckedCreateNestedManyWithoutUserInput
    vendor?: VendorUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBookingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBookingsInput, UserUncheckedCreateWithoutBookingsInput>
  }

  export type VendorCreateWithoutBookingsInput = {
    id?: string
    businessName: string
    category: $Enums.VendorCategory
    description: string
    location: string
    phone: string
    email: string
    website?: string | null
    experience?: number
    rating?: number
    totalReviews?: number
    isVerified?: boolean
    isActive?: boolean
    verificationStatus?: $Enums.VerificationStatus
    documentSignedAt?: Date | string | null
    verificationNotes?: string | null
    basePrice?: number | null
    priceRange?: string | null
    profileImage?: string | null
    gallery?: VendorCreategalleryInput | string[]
    availability?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutVendorInput
    services?: ServiceCreateNestedManyWithoutVendorInput
    reviews?: ReviewCreateNestedManyWithoutVendorInput
    chatSessions?: ChatSessionCreateNestedManyWithoutVendorInput
    verificationDocuments?: VendorVerificationDocumentCreateNestedManyWithoutVendorInput
    dynamicFields?: VendorDynamicFieldCreateNestedManyWithoutVendorInput
  }

  export type VendorUncheckedCreateWithoutBookingsInput = {
    id?: string
    userId: string
    businessName: string
    category: $Enums.VendorCategory
    description: string
    location: string
    phone: string
    email: string
    website?: string | null
    experience?: number
    rating?: number
    totalReviews?: number
    isVerified?: boolean
    isActive?: boolean
    verificationStatus?: $Enums.VerificationStatus
    documentSignedAt?: Date | string | null
    verificationNotes?: string | null
    basePrice?: number | null
    priceRange?: string | null
    profileImage?: string | null
    gallery?: VendorCreategalleryInput | string[]
    availability?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: ServiceUncheckedCreateNestedManyWithoutVendorInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutVendorInput
    chatSessions?: ChatSessionUncheckedCreateNestedManyWithoutVendorInput
    verificationDocuments?: VendorVerificationDocumentUncheckedCreateNestedManyWithoutVendorInput
    dynamicFields?: VendorDynamicFieldUncheckedCreateNestedManyWithoutVendorInput
  }

  export type VendorCreateOrConnectWithoutBookingsInput = {
    where: VendorWhereUniqueInput
    create: XOR<VendorCreateWithoutBookingsInput, VendorUncheckedCreateWithoutBookingsInput>
  }

  export type ServiceCreateWithoutBookingsInput = {
    id?: string
    name: string
    description: string
    price: number
    duration?: number | null
    maxCapacity?: number | null
    includes?: ServiceCreateincludesInput | string[]
    addOns?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    vendor: VendorCreateNestedOneWithoutServicesInput
  }

  export type ServiceUncheckedCreateWithoutBookingsInput = {
    id?: string
    vendorId: string
    name: string
    description: string
    price: number
    duration?: number | null
    maxCapacity?: number | null
    includes?: ServiceCreateincludesInput | string[]
    addOns?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceCreateOrConnectWithoutBookingsInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutBookingsInput, ServiceUncheckedCreateWithoutBookingsInput>
  }

  export type PaymentCreateWithoutBookingInput = {
    id?: string
    amount: number
    currency?: string
    paymentMethod: string
    transactionId?: string | null
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.PaymentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUncheckedCreateWithoutBookingInput = {
    id?: string
    amount: number
    currency?: string
    paymentMethod: string
    transactionId?: string | null
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.PaymentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutBookingInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutBookingInput, PaymentUncheckedCreateWithoutBookingInput>
  }

  export type PaymentCreateManyBookingInputEnvelope = {
    data: PaymentCreateManyBookingInput | PaymentCreateManyBookingInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutBookingInput = {
    id?: string
    content: string
    messageType?: string
    attachments?: MessageCreateattachmentsInput | string[]
    isRead?: boolean
    createdAt?: Date | string
    sender: UserCreateNestedOneWithoutSentMessagesInput
    receiver: UserCreateNestedOneWithoutReceivedMessagesInput
  }

  export type MessageUncheckedCreateWithoutBookingInput = {
    id?: string
    senderId: string
    receiverId: string
    content: string
    messageType?: string
    attachments?: MessageCreateattachmentsInput | string[]
    isRead?: boolean
    createdAt?: Date | string
  }

  export type MessageCreateOrConnectWithoutBookingInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutBookingInput, MessageUncheckedCreateWithoutBookingInput>
  }

  export type MessageCreateManyBookingInputEnvelope = {
    data: MessageCreateManyBookingInput | MessageCreateManyBookingInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutBookingsInput = {
    update: XOR<UserUpdateWithoutBookingsInput, UserUncheckedUpdateWithoutBookingsInput>
    create: XOR<UserCreateWithoutBookingsInput, UserUncheckedCreateWithoutBookingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBookingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBookingsInput, UserUncheckedUpdateWithoutBookingsInput>
  }

  export type UserUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    weddingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    chatSessions?: ChatSessionUpdateManyWithoutUserNestedInput
    vendor?: VendorUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    weddingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    chatSessions?: ChatSessionUncheckedUpdateManyWithoutUserNestedInput
    vendor?: VendorUncheckedUpdateOneWithoutUserNestedInput
  }

  export type VendorUpsertWithoutBookingsInput = {
    update: XOR<VendorUpdateWithoutBookingsInput, VendorUncheckedUpdateWithoutBookingsInput>
    create: XOR<VendorCreateWithoutBookingsInput, VendorUncheckedCreateWithoutBookingsInput>
    where?: VendorWhereInput
  }

  export type VendorUpdateToOneWithWhereWithoutBookingsInput = {
    where?: VendorWhereInput
    data: XOR<VendorUpdateWithoutBookingsInput, VendorUncheckedUpdateWithoutBookingsInput>
  }

  export type VendorUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessName?: StringFieldUpdateOperationsInput | string
    category?: EnumVendorCategoryFieldUpdateOperationsInput | $Enums.VendorCategory
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: IntFieldUpdateOperationsInput | number
    rating?: FloatFieldUpdateOperationsInput | number
    totalReviews?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    documentSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    priceRange?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    gallery?: VendorUpdategalleryInput | string[]
    availability?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutVendorNestedInput
    services?: ServiceUpdateManyWithoutVendorNestedInput
    reviews?: ReviewUpdateManyWithoutVendorNestedInput
    chatSessions?: ChatSessionUpdateManyWithoutVendorNestedInput
    verificationDocuments?: VendorVerificationDocumentUpdateManyWithoutVendorNestedInput
    dynamicFields?: VendorDynamicFieldUpdateManyWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    businessName?: StringFieldUpdateOperationsInput | string
    category?: EnumVendorCategoryFieldUpdateOperationsInput | $Enums.VendorCategory
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: IntFieldUpdateOperationsInput | number
    rating?: FloatFieldUpdateOperationsInput | number
    totalReviews?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    documentSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    priceRange?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    gallery?: VendorUpdategalleryInput | string[]
    availability?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServiceUncheckedUpdateManyWithoutVendorNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutVendorNestedInput
    chatSessions?: ChatSessionUncheckedUpdateManyWithoutVendorNestedInput
    verificationDocuments?: VendorVerificationDocumentUncheckedUpdateManyWithoutVendorNestedInput
    dynamicFields?: VendorDynamicFieldUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type ServiceUpsertWithoutBookingsInput = {
    update: XOR<ServiceUpdateWithoutBookingsInput, ServiceUncheckedUpdateWithoutBookingsInput>
    create: XOR<ServiceCreateWithoutBookingsInput, ServiceUncheckedCreateWithoutBookingsInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutBookingsInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutBookingsInput, ServiceUncheckedUpdateWithoutBookingsInput>
  }

  export type ServiceUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    maxCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    includes?: ServiceUpdateincludesInput | string[]
    addOns?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneRequiredWithoutServicesNestedInput
  }

  export type ServiceUncheckedUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    maxCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    includes?: ServiceUpdateincludesInput | string[]
    addOns?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpsertWithWhereUniqueWithoutBookingInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutBookingInput, PaymentUncheckedUpdateWithoutBookingInput>
    create: XOR<PaymentCreateWithoutBookingInput, PaymentUncheckedCreateWithoutBookingInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutBookingInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutBookingInput, PaymentUncheckedUpdateWithoutBookingInput>
  }

  export type PaymentUpdateManyWithWhereWithoutBookingInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutBookingInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    id?: StringFilter<"Payment"> | string
    bookingId?: StringFilter<"Payment"> | string
    amount?: FloatFilter<"Payment"> | number
    currency?: StringFilter<"Payment"> | string
    paymentMethod?: StringFilter<"Payment"> | string
    transactionId?: StringNullableFilter<"Payment"> | string | null
    gatewayResponse?: JsonNullableFilter<"Payment">
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
  }

  export type MessageUpsertWithWhereUniqueWithoutBookingInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutBookingInput, MessageUncheckedUpdateWithoutBookingInput>
    create: XOR<MessageCreateWithoutBookingInput, MessageUncheckedCreateWithoutBookingInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutBookingInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutBookingInput, MessageUncheckedUpdateWithoutBookingInput>
  }

  export type MessageUpdateManyWithWhereWithoutBookingInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutBookingInput>
  }

  export type BookingCreateWithoutPaymentsInput = {
    id?: string
    eventDate: Date | string
    eventTime: string
    eventDuration: number
    guestCount?: number | null
    location?: string | null
    specialRequests?: string | null
    basePrice: number
    additionalCosts?: number
    totalAmount: number
    status?: $Enums.BookingStatus
    paymentStatus?: $Enums.PaymentStatus
    requestedAt?: Date | string
    approvedAt?: Date | string | null
    confirmedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutBookingsInput
    vendor: VendorCreateNestedOneWithoutBookingsInput
    service: ServiceCreateNestedOneWithoutBookingsInput
    messages?: MessageCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutPaymentsInput = {
    id?: string
    userId: string
    vendorId: string
    serviceId: string
    eventDate: Date | string
    eventTime: string
    eventDuration: number
    guestCount?: number | null
    location?: string | null
    specialRequests?: string | null
    basePrice: number
    additionalCosts?: number
    totalAmount: number
    status?: $Enums.BookingStatus
    paymentStatus?: $Enums.PaymentStatus
    requestedAt?: Date | string
    approvedAt?: Date | string | null
    confirmedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutPaymentsInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutPaymentsInput, BookingUncheckedCreateWithoutPaymentsInput>
  }

  export type BookingUpsertWithoutPaymentsInput = {
    update: XOR<BookingUpdateWithoutPaymentsInput, BookingUncheckedUpdateWithoutPaymentsInput>
    create: XOR<BookingCreateWithoutPaymentsInput, BookingUncheckedCreateWithoutPaymentsInput>
    where?: BookingWhereInput
  }

  export type BookingUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: BookingWhereInput
    data: XOR<BookingUpdateWithoutPaymentsInput, BookingUncheckedUpdateWithoutPaymentsInput>
  }

  export type BookingUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    eventTime?: StringFieldUpdateOperationsInput | string
    eventDuration?: IntFieldUpdateOperationsInput | number
    guestCount?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    additionalCosts?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBookingsNestedInput
    vendor?: VendorUpdateOneRequiredWithoutBookingsNestedInput
    service?: ServiceUpdateOneRequiredWithoutBookingsNestedInput
    messages?: MessageUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    eventTime?: StringFieldUpdateOperationsInput | string
    eventDuration?: IntFieldUpdateOperationsInput | number
    guestCount?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    additionalCosts?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type UserCreateWithoutSentMessagesInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isVerified?: boolean
    profileImage?: string | null
    weddingDate?: Date | string | null
    budget?: number | null
    location?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingCreateNestedManyWithoutUserInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    chatSessions?: ChatSessionCreateNestedManyWithoutUserInput
    vendor?: VendorCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSentMessagesInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isVerified?: boolean
    profileImage?: string | null
    weddingDate?: Date | string | null
    budget?: number | null
    location?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    chatSessions?: ChatSessionUncheckedCreateNestedManyWithoutUserInput
    vendor?: VendorUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSentMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
  }

  export type UserCreateWithoutReceivedMessagesInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isVerified?: boolean
    profileImage?: string | null
    weddingDate?: Date | string | null
    budget?: number | null
    location?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    chatSessions?: ChatSessionCreateNestedManyWithoutUserInput
    vendor?: VendorCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReceivedMessagesInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isVerified?: boolean
    profileImage?: string | null
    weddingDate?: Date | string | null
    budget?: number | null
    location?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    chatSessions?: ChatSessionUncheckedCreateNestedManyWithoutUserInput
    vendor?: VendorUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReceivedMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReceivedMessagesInput, UserUncheckedCreateWithoutReceivedMessagesInput>
  }

  export type BookingCreateWithoutMessagesInput = {
    id?: string
    eventDate: Date | string
    eventTime: string
    eventDuration: number
    guestCount?: number | null
    location?: string | null
    specialRequests?: string | null
    basePrice: number
    additionalCosts?: number
    totalAmount: number
    status?: $Enums.BookingStatus
    paymentStatus?: $Enums.PaymentStatus
    requestedAt?: Date | string
    approvedAt?: Date | string | null
    confirmedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutBookingsInput
    vendor: VendorCreateNestedOneWithoutBookingsInput
    service: ServiceCreateNestedOneWithoutBookingsInput
    payments?: PaymentCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutMessagesInput = {
    id?: string
    userId: string
    vendorId: string
    serviceId: string
    eventDate: Date | string
    eventTime: string
    eventDuration: number
    guestCount?: number | null
    location?: string | null
    specialRequests?: string | null
    basePrice: number
    additionalCosts?: number
    totalAmount: number
    status?: $Enums.BookingStatus
    paymentStatus?: $Enums.PaymentStatus
    requestedAt?: Date | string
    approvedAt?: Date | string | null
    confirmedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutMessagesInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutMessagesInput, BookingUncheckedCreateWithoutMessagesInput>
  }

  export type UserUpsertWithoutSentMessagesInput = {
    update: XOR<UserUpdateWithoutSentMessagesInput, UserUncheckedUpdateWithoutSentMessagesInput>
    create: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSentMessagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSentMessagesInput, UserUncheckedUpdateWithoutSentMessagesInput>
  }

  export type UserUpdateWithoutSentMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    weddingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUpdateManyWithoutUserNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    chatSessions?: ChatSessionUpdateManyWithoutUserNestedInput
    vendor?: VendorUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSentMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    weddingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    chatSessions?: ChatSessionUncheckedUpdateManyWithoutUserNestedInput
    vendor?: VendorUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserUpsertWithoutReceivedMessagesInput = {
    update: XOR<UserUpdateWithoutReceivedMessagesInput, UserUncheckedUpdateWithoutReceivedMessagesInput>
    create: XOR<UserCreateWithoutReceivedMessagesInput, UserUncheckedCreateWithoutReceivedMessagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReceivedMessagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReceivedMessagesInput, UserUncheckedUpdateWithoutReceivedMessagesInput>
  }

  export type UserUpdateWithoutReceivedMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    weddingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    chatSessions?: ChatSessionUpdateManyWithoutUserNestedInput
    vendor?: VendorUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReceivedMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    weddingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    chatSessions?: ChatSessionUncheckedUpdateManyWithoutUserNestedInput
    vendor?: VendorUncheckedUpdateOneWithoutUserNestedInput
  }

  export type BookingUpsertWithoutMessagesInput = {
    update: XOR<BookingUpdateWithoutMessagesInput, BookingUncheckedUpdateWithoutMessagesInput>
    create: XOR<BookingCreateWithoutMessagesInput, BookingUncheckedCreateWithoutMessagesInput>
    where?: BookingWhereInput
  }

  export type BookingUpdateToOneWithWhereWithoutMessagesInput = {
    where?: BookingWhereInput
    data: XOR<BookingUpdateWithoutMessagesInput, BookingUncheckedUpdateWithoutMessagesInput>
  }

  export type BookingUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    eventTime?: StringFieldUpdateOperationsInput | string
    eventDuration?: IntFieldUpdateOperationsInput | number
    guestCount?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    additionalCosts?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBookingsNestedInput
    vendor?: VendorUpdateOneRequiredWithoutBookingsNestedInput
    service?: ServiceUpdateOneRequiredWithoutBookingsNestedInput
    payments?: PaymentUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    eventTime?: StringFieldUpdateOperationsInput | string
    eventDuration?: IntFieldUpdateOperationsInput | number
    guestCount?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    additionalCosts?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type UserCreateWithoutChatSessionsInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isVerified?: boolean
    profileImage?: string | null
    weddingDate?: Date | string | null
    budget?: number | null
    location?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    vendor?: VendorCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutChatSessionsInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isVerified?: boolean
    profileImage?: string | null
    weddingDate?: Date | string | null
    budget?: number | null
    location?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    vendor?: VendorUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutChatSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutChatSessionsInput, UserUncheckedCreateWithoutChatSessionsInput>
  }

  export type VendorCreateWithoutChatSessionsInput = {
    id?: string
    businessName: string
    category: $Enums.VendorCategory
    description: string
    location: string
    phone: string
    email: string
    website?: string | null
    experience?: number
    rating?: number
    totalReviews?: number
    isVerified?: boolean
    isActive?: boolean
    verificationStatus?: $Enums.VerificationStatus
    documentSignedAt?: Date | string | null
    verificationNotes?: string | null
    basePrice?: number | null
    priceRange?: string | null
    profileImage?: string | null
    gallery?: VendorCreategalleryInput | string[]
    availability?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutVendorInput
    bookings?: BookingCreateNestedManyWithoutVendorInput
    services?: ServiceCreateNestedManyWithoutVendorInput
    reviews?: ReviewCreateNestedManyWithoutVendorInput
    verificationDocuments?: VendorVerificationDocumentCreateNestedManyWithoutVendorInput
    dynamicFields?: VendorDynamicFieldCreateNestedManyWithoutVendorInput
  }

  export type VendorUncheckedCreateWithoutChatSessionsInput = {
    id?: string
    userId: string
    businessName: string
    category: $Enums.VendorCategory
    description: string
    location: string
    phone: string
    email: string
    website?: string | null
    experience?: number
    rating?: number
    totalReviews?: number
    isVerified?: boolean
    isActive?: boolean
    verificationStatus?: $Enums.VerificationStatus
    documentSignedAt?: Date | string | null
    verificationNotes?: string | null
    basePrice?: number | null
    priceRange?: string | null
    profileImage?: string | null
    gallery?: VendorCreategalleryInput | string[]
    availability?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutVendorInput
    services?: ServiceUncheckedCreateNestedManyWithoutVendorInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutVendorInput
    verificationDocuments?: VendorVerificationDocumentUncheckedCreateNestedManyWithoutVendorInput
    dynamicFields?: VendorDynamicFieldUncheckedCreateNestedManyWithoutVendorInput
  }

  export type VendorCreateOrConnectWithoutChatSessionsInput = {
    where: VendorWhereUniqueInput
    create: XOR<VendorCreateWithoutChatSessionsInput, VendorUncheckedCreateWithoutChatSessionsInput>
  }

  export type UserUpsertWithoutChatSessionsInput = {
    update: XOR<UserUpdateWithoutChatSessionsInput, UserUncheckedUpdateWithoutChatSessionsInput>
    create: XOR<UserCreateWithoutChatSessionsInput, UserUncheckedCreateWithoutChatSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutChatSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutChatSessionsInput, UserUncheckedUpdateWithoutChatSessionsInput>
  }

  export type UserUpdateWithoutChatSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    weddingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    vendor?: VendorUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutChatSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    weddingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    vendor?: VendorUncheckedUpdateOneWithoutUserNestedInput
  }

  export type VendorUpsertWithoutChatSessionsInput = {
    update: XOR<VendorUpdateWithoutChatSessionsInput, VendorUncheckedUpdateWithoutChatSessionsInput>
    create: XOR<VendorCreateWithoutChatSessionsInput, VendorUncheckedCreateWithoutChatSessionsInput>
    where?: VendorWhereInput
  }

  export type VendorUpdateToOneWithWhereWithoutChatSessionsInput = {
    where?: VendorWhereInput
    data: XOR<VendorUpdateWithoutChatSessionsInput, VendorUncheckedUpdateWithoutChatSessionsInput>
  }

  export type VendorUpdateWithoutChatSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessName?: StringFieldUpdateOperationsInput | string
    category?: EnumVendorCategoryFieldUpdateOperationsInput | $Enums.VendorCategory
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: IntFieldUpdateOperationsInput | number
    rating?: FloatFieldUpdateOperationsInput | number
    totalReviews?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    documentSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    priceRange?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    gallery?: VendorUpdategalleryInput | string[]
    availability?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutVendorNestedInput
    bookings?: BookingUpdateManyWithoutVendorNestedInput
    services?: ServiceUpdateManyWithoutVendorNestedInput
    reviews?: ReviewUpdateManyWithoutVendorNestedInput
    verificationDocuments?: VendorVerificationDocumentUpdateManyWithoutVendorNestedInput
    dynamicFields?: VendorDynamicFieldUpdateManyWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateWithoutChatSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    businessName?: StringFieldUpdateOperationsInput | string
    category?: EnumVendorCategoryFieldUpdateOperationsInput | $Enums.VendorCategory
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: IntFieldUpdateOperationsInput | number
    rating?: FloatFieldUpdateOperationsInput | number
    totalReviews?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    documentSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    priceRange?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    gallery?: VendorUpdategalleryInput | string[]
    availability?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutVendorNestedInput
    services?: ServiceUncheckedUpdateManyWithoutVendorNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutVendorNestedInput
    verificationDocuments?: VendorVerificationDocumentUncheckedUpdateManyWithoutVendorNestedInput
    dynamicFields?: VendorDynamicFieldUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type UserCreateWithoutReviewsInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isVerified?: boolean
    profileImage?: string | null
    weddingDate?: Date | string | null
    budget?: number | null
    location?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    chatSessions?: ChatSessionCreateNestedManyWithoutUserInput
    vendor?: VendorCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReviewsInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isVerified?: boolean
    profileImage?: string | null
    weddingDate?: Date | string | null
    budget?: number | null
    location?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    chatSessions?: ChatSessionUncheckedCreateNestedManyWithoutUserInput
    vendor?: VendorUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReviewsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
  }

  export type VendorCreateWithoutReviewsInput = {
    id?: string
    businessName: string
    category: $Enums.VendorCategory
    description: string
    location: string
    phone: string
    email: string
    website?: string | null
    experience?: number
    rating?: number
    totalReviews?: number
    isVerified?: boolean
    isActive?: boolean
    verificationStatus?: $Enums.VerificationStatus
    documentSignedAt?: Date | string | null
    verificationNotes?: string | null
    basePrice?: number | null
    priceRange?: string | null
    profileImage?: string | null
    gallery?: VendorCreategalleryInput | string[]
    availability?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutVendorInput
    bookings?: BookingCreateNestedManyWithoutVendorInput
    services?: ServiceCreateNestedManyWithoutVendorInput
    chatSessions?: ChatSessionCreateNestedManyWithoutVendorInput
    verificationDocuments?: VendorVerificationDocumentCreateNestedManyWithoutVendorInput
    dynamicFields?: VendorDynamicFieldCreateNestedManyWithoutVendorInput
  }

  export type VendorUncheckedCreateWithoutReviewsInput = {
    id?: string
    userId: string
    businessName: string
    category: $Enums.VendorCategory
    description: string
    location: string
    phone: string
    email: string
    website?: string | null
    experience?: number
    rating?: number
    totalReviews?: number
    isVerified?: boolean
    isActive?: boolean
    verificationStatus?: $Enums.VerificationStatus
    documentSignedAt?: Date | string | null
    verificationNotes?: string | null
    basePrice?: number | null
    priceRange?: string | null
    profileImage?: string | null
    gallery?: VendorCreategalleryInput | string[]
    availability?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutVendorInput
    services?: ServiceUncheckedCreateNestedManyWithoutVendorInput
    chatSessions?: ChatSessionUncheckedCreateNestedManyWithoutVendorInput
    verificationDocuments?: VendorVerificationDocumentUncheckedCreateNestedManyWithoutVendorInput
    dynamicFields?: VendorDynamicFieldUncheckedCreateNestedManyWithoutVendorInput
  }

  export type VendorCreateOrConnectWithoutReviewsInput = {
    where: VendorWhereUniqueInput
    create: XOR<VendorCreateWithoutReviewsInput, VendorUncheckedCreateWithoutReviewsInput>
  }

  export type UserUpsertWithoutReviewsInput = {
    update: XOR<UserUpdateWithoutReviewsInput, UserUncheckedUpdateWithoutReviewsInput>
    create: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReviewsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReviewsInput, UserUncheckedUpdateWithoutReviewsInput>
  }

  export type UserUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    weddingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    chatSessions?: ChatSessionUpdateManyWithoutUserNestedInput
    vendor?: VendorUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    weddingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    chatSessions?: ChatSessionUncheckedUpdateManyWithoutUserNestedInput
    vendor?: VendorUncheckedUpdateOneWithoutUserNestedInput
  }

  export type VendorUpsertWithoutReviewsInput = {
    update: XOR<VendorUpdateWithoutReviewsInput, VendorUncheckedUpdateWithoutReviewsInput>
    create: XOR<VendorCreateWithoutReviewsInput, VendorUncheckedCreateWithoutReviewsInput>
    where?: VendorWhereInput
  }

  export type VendorUpdateToOneWithWhereWithoutReviewsInput = {
    where?: VendorWhereInput
    data: XOR<VendorUpdateWithoutReviewsInput, VendorUncheckedUpdateWithoutReviewsInput>
  }

  export type VendorUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessName?: StringFieldUpdateOperationsInput | string
    category?: EnumVendorCategoryFieldUpdateOperationsInput | $Enums.VendorCategory
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: IntFieldUpdateOperationsInput | number
    rating?: FloatFieldUpdateOperationsInput | number
    totalReviews?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    documentSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    priceRange?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    gallery?: VendorUpdategalleryInput | string[]
    availability?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutVendorNestedInput
    bookings?: BookingUpdateManyWithoutVendorNestedInput
    services?: ServiceUpdateManyWithoutVendorNestedInput
    chatSessions?: ChatSessionUpdateManyWithoutVendorNestedInput
    verificationDocuments?: VendorVerificationDocumentUpdateManyWithoutVendorNestedInput
    dynamicFields?: VendorDynamicFieldUpdateManyWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    businessName?: StringFieldUpdateOperationsInput | string
    category?: EnumVendorCategoryFieldUpdateOperationsInput | $Enums.VendorCategory
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: IntFieldUpdateOperationsInput | number
    rating?: FloatFieldUpdateOperationsInput | number
    totalReviews?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    documentSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    priceRange?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    gallery?: VendorUpdategalleryInput | string[]
    availability?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutVendorNestedInput
    services?: ServiceUncheckedUpdateManyWithoutVendorNestedInput
    chatSessions?: ChatSessionUncheckedUpdateManyWithoutVendorNestedInput
    verificationDocuments?: VendorVerificationDocumentUncheckedUpdateManyWithoutVendorNestedInput
    dynamicFields?: VendorDynamicFieldUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isVerified?: boolean
    profileImage?: string | null
    weddingDate?: Date | string | null
    budget?: number | null
    location?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    chatSessions?: ChatSessionCreateNestedManyWithoutUserInput
    vendor?: VendorCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    phone?: string | null
    role?: $Enums.UserRole
    isVerified?: boolean
    profileImage?: string | null
    weddingDate?: Date | string | null
    budget?: number | null
    location?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    chatSessions?: ChatSessionUncheckedCreateNestedManyWithoutUserInput
    vendor?: VendorUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    weddingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    chatSessions?: ChatSessionUpdateManyWithoutUserNestedInput
    vendor?: VendorUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    weddingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    chatSessions?: ChatSessionUncheckedUpdateManyWithoutUserNestedInput
    vendor?: VendorUncheckedUpdateOneWithoutUserNestedInput
  }

  export type MatrimonialMessageCreateWithoutFromProfileInput = {
    id?: string
    content: string
    createdAt?: Date | string
    toProfile: MatrimonialProfileCreateNestedOneWithoutReceivedMessagesInput
  }

  export type MatrimonialMessageUncheckedCreateWithoutFromProfileInput = {
    id?: string
    toProfileId: string
    content: string
    createdAt?: Date | string
  }

  export type MatrimonialMessageCreateOrConnectWithoutFromProfileInput = {
    where: MatrimonialMessageWhereUniqueInput
    create: XOR<MatrimonialMessageCreateWithoutFromProfileInput, MatrimonialMessageUncheckedCreateWithoutFromProfileInput>
  }

  export type MatrimonialMessageCreateManyFromProfileInputEnvelope = {
    data: MatrimonialMessageCreateManyFromProfileInput | MatrimonialMessageCreateManyFromProfileInput[]
    skipDuplicates?: boolean
  }

  export type MatrimonialMessageCreateWithoutToProfileInput = {
    id?: string
    content: string
    createdAt?: Date | string
    fromProfile: MatrimonialProfileCreateNestedOneWithoutSentMessagesInput
  }

  export type MatrimonialMessageUncheckedCreateWithoutToProfileInput = {
    id?: string
    fromProfileId: string
    content: string
    createdAt?: Date | string
  }

  export type MatrimonialMessageCreateOrConnectWithoutToProfileInput = {
    where: MatrimonialMessageWhereUniqueInput
    create: XOR<MatrimonialMessageCreateWithoutToProfileInput, MatrimonialMessageUncheckedCreateWithoutToProfileInput>
  }

  export type MatrimonialMessageCreateManyToProfileInputEnvelope = {
    data: MatrimonialMessageCreateManyToProfileInput | MatrimonialMessageCreateManyToProfileInput[]
    skipDuplicates?: boolean
  }

  export type MatrimonialMessageUpsertWithWhereUniqueWithoutFromProfileInput = {
    where: MatrimonialMessageWhereUniqueInput
    update: XOR<MatrimonialMessageUpdateWithoutFromProfileInput, MatrimonialMessageUncheckedUpdateWithoutFromProfileInput>
    create: XOR<MatrimonialMessageCreateWithoutFromProfileInput, MatrimonialMessageUncheckedCreateWithoutFromProfileInput>
  }

  export type MatrimonialMessageUpdateWithWhereUniqueWithoutFromProfileInput = {
    where: MatrimonialMessageWhereUniqueInput
    data: XOR<MatrimonialMessageUpdateWithoutFromProfileInput, MatrimonialMessageUncheckedUpdateWithoutFromProfileInput>
  }

  export type MatrimonialMessageUpdateManyWithWhereWithoutFromProfileInput = {
    where: MatrimonialMessageScalarWhereInput
    data: XOR<MatrimonialMessageUpdateManyMutationInput, MatrimonialMessageUncheckedUpdateManyWithoutFromProfileInput>
  }

  export type MatrimonialMessageScalarWhereInput = {
    AND?: MatrimonialMessageScalarWhereInput | MatrimonialMessageScalarWhereInput[]
    OR?: MatrimonialMessageScalarWhereInput[]
    NOT?: MatrimonialMessageScalarWhereInput | MatrimonialMessageScalarWhereInput[]
    id?: StringFilter<"MatrimonialMessage"> | string
    fromProfileId?: StringFilter<"MatrimonialMessage"> | string
    toProfileId?: StringFilter<"MatrimonialMessage"> | string
    content?: StringFilter<"MatrimonialMessage"> | string
    createdAt?: DateTimeFilter<"MatrimonialMessage"> | Date | string
  }

  export type MatrimonialMessageUpsertWithWhereUniqueWithoutToProfileInput = {
    where: MatrimonialMessageWhereUniqueInput
    update: XOR<MatrimonialMessageUpdateWithoutToProfileInput, MatrimonialMessageUncheckedUpdateWithoutToProfileInput>
    create: XOR<MatrimonialMessageCreateWithoutToProfileInput, MatrimonialMessageUncheckedCreateWithoutToProfileInput>
  }

  export type MatrimonialMessageUpdateWithWhereUniqueWithoutToProfileInput = {
    where: MatrimonialMessageWhereUniqueInput
    data: XOR<MatrimonialMessageUpdateWithoutToProfileInput, MatrimonialMessageUncheckedUpdateWithoutToProfileInput>
  }

  export type MatrimonialMessageUpdateManyWithWhereWithoutToProfileInput = {
    where: MatrimonialMessageScalarWhereInput
    data: XOR<MatrimonialMessageUpdateManyMutationInput, MatrimonialMessageUncheckedUpdateManyWithoutToProfileInput>
  }

  export type MatrimonialProfileCreateWithoutSentMessagesInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    gender: $Enums.Gender
    dateOfBirth?: Date | string | null
    age?: number | null
    city: string
    profession: string
    education: string
    religion: string
    height?: string | null
    bio?: string | null
    interests?: MatrimonialProfileCreateinterestsInput | string[]
    photos?: MatrimonialProfileCreatephotosInput | string[]
    familyBackground?: string | null
    partnerPreferences?: string | null
    isVerified?: boolean
    isOnline?: boolean
    lastSeen?: Date | string | null
    compatibilityScore?: number
    isInterested?: boolean
    isMatched?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    receivedMessages?: MatrimonialMessageCreateNestedManyWithoutToProfileInput
  }

  export type MatrimonialProfileUncheckedCreateWithoutSentMessagesInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    gender: $Enums.Gender
    dateOfBirth?: Date | string | null
    age?: number | null
    city: string
    profession: string
    education: string
    religion: string
    height?: string | null
    bio?: string | null
    interests?: MatrimonialProfileCreateinterestsInput | string[]
    photos?: MatrimonialProfileCreatephotosInput | string[]
    familyBackground?: string | null
    partnerPreferences?: string | null
    isVerified?: boolean
    isOnline?: boolean
    lastSeen?: Date | string | null
    compatibilityScore?: number
    isInterested?: boolean
    isMatched?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    receivedMessages?: MatrimonialMessageUncheckedCreateNestedManyWithoutToProfileInput
  }

  export type MatrimonialProfileCreateOrConnectWithoutSentMessagesInput = {
    where: MatrimonialProfileWhereUniqueInput
    create: XOR<MatrimonialProfileCreateWithoutSentMessagesInput, MatrimonialProfileUncheckedCreateWithoutSentMessagesInput>
  }

  export type MatrimonialProfileCreateWithoutReceivedMessagesInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    gender: $Enums.Gender
    dateOfBirth?: Date | string | null
    age?: number | null
    city: string
    profession: string
    education: string
    religion: string
    height?: string | null
    bio?: string | null
    interests?: MatrimonialProfileCreateinterestsInput | string[]
    photos?: MatrimonialProfileCreatephotosInput | string[]
    familyBackground?: string | null
    partnerPreferences?: string | null
    isVerified?: boolean
    isOnline?: boolean
    lastSeen?: Date | string | null
    compatibilityScore?: number
    isInterested?: boolean
    isMatched?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sentMessages?: MatrimonialMessageCreateNestedManyWithoutFromProfileInput
  }

  export type MatrimonialProfileUncheckedCreateWithoutReceivedMessagesInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    gender: $Enums.Gender
    dateOfBirth?: Date | string | null
    age?: number | null
    city: string
    profession: string
    education: string
    religion: string
    height?: string | null
    bio?: string | null
    interests?: MatrimonialProfileCreateinterestsInput | string[]
    photos?: MatrimonialProfileCreatephotosInput | string[]
    familyBackground?: string | null
    partnerPreferences?: string | null
    isVerified?: boolean
    isOnline?: boolean
    lastSeen?: Date | string | null
    compatibilityScore?: number
    isInterested?: boolean
    isMatched?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sentMessages?: MatrimonialMessageUncheckedCreateNestedManyWithoutFromProfileInput
  }

  export type MatrimonialProfileCreateOrConnectWithoutReceivedMessagesInput = {
    where: MatrimonialProfileWhereUniqueInput
    create: XOR<MatrimonialProfileCreateWithoutReceivedMessagesInput, MatrimonialProfileUncheckedCreateWithoutReceivedMessagesInput>
  }

  export type MatrimonialProfileUpsertWithoutSentMessagesInput = {
    update: XOR<MatrimonialProfileUpdateWithoutSentMessagesInput, MatrimonialProfileUncheckedUpdateWithoutSentMessagesInput>
    create: XOR<MatrimonialProfileCreateWithoutSentMessagesInput, MatrimonialProfileUncheckedCreateWithoutSentMessagesInput>
    where?: MatrimonialProfileWhereInput
  }

  export type MatrimonialProfileUpdateToOneWithWhereWithoutSentMessagesInput = {
    where?: MatrimonialProfileWhereInput
    data: XOR<MatrimonialProfileUpdateWithoutSentMessagesInput, MatrimonialProfileUncheckedUpdateWithoutSentMessagesInput>
  }

  export type MatrimonialProfileUpdateWithoutSentMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    city?: StringFieldUpdateOperationsInput | string
    profession?: StringFieldUpdateOperationsInput | string
    education?: StringFieldUpdateOperationsInput | string
    religion?: StringFieldUpdateOperationsInput | string
    height?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: MatrimonialProfileUpdateinterestsInput | string[]
    photos?: MatrimonialProfileUpdatephotosInput | string[]
    familyBackground?: NullableStringFieldUpdateOperationsInput | string | null
    partnerPreferences?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    compatibilityScore?: IntFieldUpdateOperationsInput | number
    isInterested?: BoolFieldUpdateOperationsInput | boolean
    isMatched?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedMessages?: MatrimonialMessageUpdateManyWithoutToProfileNestedInput
  }

  export type MatrimonialProfileUncheckedUpdateWithoutSentMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    city?: StringFieldUpdateOperationsInput | string
    profession?: StringFieldUpdateOperationsInput | string
    education?: StringFieldUpdateOperationsInput | string
    religion?: StringFieldUpdateOperationsInput | string
    height?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: MatrimonialProfileUpdateinterestsInput | string[]
    photos?: MatrimonialProfileUpdatephotosInput | string[]
    familyBackground?: NullableStringFieldUpdateOperationsInput | string | null
    partnerPreferences?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    compatibilityScore?: IntFieldUpdateOperationsInput | number
    isInterested?: BoolFieldUpdateOperationsInput | boolean
    isMatched?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedMessages?: MatrimonialMessageUncheckedUpdateManyWithoutToProfileNestedInput
  }

  export type MatrimonialProfileUpsertWithoutReceivedMessagesInput = {
    update: XOR<MatrimonialProfileUpdateWithoutReceivedMessagesInput, MatrimonialProfileUncheckedUpdateWithoutReceivedMessagesInput>
    create: XOR<MatrimonialProfileCreateWithoutReceivedMessagesInput, MatrimonialProfileUncheckedCreateWithoutReceivedMessagesInput>
    where?: MatrimonialProfileWhereInput
  }

  export type MatrimonialProfileUpdateToOneWithWhereWithoutReceivedMessagesInput = {
    where?: MatrimonialProfileWhereInput
    data: XOR<MatrimonialProfileUpdateWithoutReceivedMessagesInput, MatrimonialProfileUncheckedUpdateWithoutReceivedMessagesInput>
  }

  export type MatrimonialProfileUpdateWithoutReceivedMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    city?: StringFieldUpdateOperationsInput | string
    profession?: StringFieldUpdateOperationsInput | string
    education?: StringFieldUpdateOperationsInput | string
    religion?: StringFieldUpdateOperationsInput | string
    height?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: MatrimonialProfileUpdateinterestsInput | string[]
    photos?: MatrimonialProfileUpdatephotosInput | string[]
    familyBackground?: NullableStringFieldUpdateOperationsInput | string | null
    partnerPreferences?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    compatibilityScore?: IntFieldUpdateOperationsInput | number
    isInterested?: BoolFieldUpdateOperationsInput | boolean
    isMatched?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentMessages?: MatrimonialMessageUpdateManyWithoutFromProfileNestedInput
  }

  export type MatrimonialProfileUncheckedUpdateWithoutReceivedMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    city?: StringFieldUpdateOperationsInput | string
    profession?: StringFieldUpdateOperationsInput | string
    education?: StringFieldUpdateOperationsInput | string
    religion?: StringFieldUpdateOperationsInput | string
    height?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: MatrimonialProfileUpdateinterestsInput | string[]
    photos?: MatrimonialProfileUpdatephotosInput | string[]
    familyBackground?: NullableStringFieldUpdateOperationsInput | string | null
    partnerPreferences?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    compatibilityScore?: IntFieldUpdateOperationsInput | number
    isInterested?: BoolFieldUpdateOperationsInput | boolean
    isMatched?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentMessages?: MatrimonialMessageUncheckedUpdateManyWithoutFromProfileNestedInput
  }

  export type VendorCreateWithoutVerificationDocumentsInput = {
    id?: string
    businessName: string
    category: $Enums.VendorCategory
    description: string
    location: string
    phone: string
    email: string
    website?: string | null
    experience?: number
    rating?: number
    totalReviews?: number
    isVerified?: boolean
    isActive?: boolean
    verificationStatus?: $Enums.VerificationStatus
    documentSignedAt?: Date | string | null
    verificationNotes?: string | null
    basePrice?: number | null
    priceRange?: string | null
    profileImage?: string | null
    gallery?: VendorCreategalleryInput | string[]
    availability?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutVendorInput
    bookings?: BookingCreateNestedManyWithoutVendorInput
    services?: ServiceCreateNestedManyWithoutVendorInput
    reviews?: ReviewCreateNestedManyWithoutVendorInput
    chatSessions?: ChatSessionCreateNestedManyWithoutVendorInput
    dynamicFields?: VendorDynamicFieldCreateNestedManyWithoutVendorInput
  }

  export type VendorUncheckedCreateWithoutVerificationDocumentsInput = {
    id?: string
    userId: string
    businessName: string
    category: $Enums.VendorCategory
    description: string
    location: string
    phone: string
    email: string
    website?: string | null
    experience?: number
    rating?: number
    totalReviews?: number
    isVerified?: boolean
    isActive?: boolean
    verificationStatus?: $Enums.VerificationStatus
    documentSignedAt?: Date | string | null
    verificationNotes?: string | null
    basePrice?: number | null
    priceRange?: string | null
    profileImage?: string | null
    gallery?: VendorCreategalleryInput | string[]
    availability?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutVendorInput
    services?: ServiceUncheckedCreateNestedManyWithoutVendorInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutVendorInput
    chatSessions?: ChatSessionUncheckedCreateNestedManyWithoutVendorInput
    dynamicFields?: VendorDynamicFieldUncheckedCreateNestedManyWithoutVendorInput
  }

  export type VendorCreateOrConnectWithoutVerificationDocumentsInput = {
    where: VendorWhereUniqueInput
    create: XOR<VendorCreateWithoutVerificationDocumentsInput, VendorUncheckedCreateWithoutVerificationDocumentsInput>
  }

  export type VendorUpsertWithoutVerificationDocumentsInput = {
    update: XOR<VendorUpdateWithoutVerificationDocumentsInput, VendorUncheckedUpdateWithoutVerificationDocumentsInput>
    create: XOR<VendorCreateWithoutVerificationDocumentsInput, VendorUncheckedCreateWithoutVerificationDocumentsInput>
    where?: VendorWhereInput
  }

  export type VendorUpdateToOneWithWhereWithoutVerificationDocumentsInput = {
    where?: VendorWhereInput
    data: XOR<VendorUpdateWithoutVerificationDocumentsInput, VendorUncheckedUpdateWithoutVerificationDocumentsInput>
  }

  export type VendorUpdateWithoutVerificationDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessName?: StringFieldUpdateOperationsInput | string
    category?: EnumVendorCategoryFieldUpdateOperationsInput | $Enums.VendorCategory
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: IntFieldUpdateOperationsInput | number
    rating?: FloatFieldUpdateOperationsInput | number
    totalReviews?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    documentSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    priceRange?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    gallery?: VendorUpdategalleryInput | string[]
    availability?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutVendorNestedInput
    bookings?: BookingUpdateManyWithoutVendorNestedInput
    services?: ServiceUpdateManyWithoutVendorNestedInput
    reviews?: ReviewUpdateManyWithoutVendorNestedInput
    chatSessions?: ChatSessionUpdateManyWithoutVendorNestedInput
    dynamicFields?: VendorDynamicFieldUpdateManyWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateWithoutVerificationDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    businessName?: StringFieldUpdateOperationsInput | string
    category?: EnumVendorCategoryFieldUpdateOperationsInput | $Enums.VendorCategory
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: IntFieldUpdateOperationsInput | number
    rating?: FloatFieldUpdateOperationsInput | number
    totalReviews?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    documentSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    priceRange?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    gallery?: VendorUpdategalleryInput | string[]
    availability?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutVendorNestedInput
    services?: ServiceUncheckedUpdateManyWithoutVendorNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutVendorNestedInput
    chatSessions?: ChatSessionUncheckedUpdateManyWithoutVendorNestedInput
    dynamicFields?: VendorDynamicFieldUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type VendorCreateWithoutDynamicFieldsInput = {
    id?: string
    businessName: string
    category: $Enums.VendorCategory
    description: string
    location: string
    phone: string
    email: string
    website?: string | null
    experience?: number
    rating?: number
    totalReviews?: number
    isVerified?: boolean
    isActive?: boolean
    verificationStatus?: $Enums.VerificationStatus
    documentSignedAt?: Date | string | null
    verificationNotes?: string | null
    basePrice?: number | null
    priceRange?: string | null
    profileImage?: string | null
    gallery?: VendorCreategalleryInput | string[]
    availability?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutVendorInput
    bookings?: BookingCreateNestedManyWithoutVendorInput
    services?: ServiceCreateNestedManyWithoutVendorInput
    reviews?: ReviewCreateNestedManyWithoutVendorInput
    chatSessions?: ChatSessionCreateNestedManyWithoutVendorInput
    verificationDocuments?: VendorVerificationDocumentCreateNestedManyWithoutVendorInput
  }

  export type VendorUncheckedCreateWithoutDynamicFieldsInput = {
    id?: string
    userId: string
    businessName: string
    category: $Enums.VendorCategory
    description: string
    location: string
    phone: string
    email: string
    website?: string | null
    experience?: number
    rating?: number
    totalReviews?: number
    isVerified?: boolean
    isActive?: boolean
    verificationStatus?: $Enums.VerificationStatus
    documentSignedAt?: Date | string | null
    verificationNotes?: string | null
    basePrice?: number | null
    priceRange?: string | null
    profileImage?: string | null
    gallery?: VendorCreategalleryInput | string[]
    availability?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutVendorInput
    services?: ServiceUncheckedCreateNestedManyWithoutVendorInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutVendorInput
    chatSessions?: ChatSessionUncheckedCreateNestedManyWithoutVendorInput
    verificationDocuments?: VendorVerificationDocumentUncheckedCreateNestedManyWithoutVendorInput
  }

  export type VendorCreateOrConnectWithoutDynamicFieldsInput = {
    where: VendorWhereUniqueInput
    create: XOR<VendorCreateWithoutDynamicFieldsInput, VendorUncheckedCreateWithoutDynamicFieldsInput>
  }

  export type VendorUpsertWithoutDynamicFieldsInput = {
    update: XOR<VendorUpdateWithoutDynamicFieldsInput, VendorUncheckedUpdateWithoutDynamicFieldsInput>
    create: XOR<VendorCreateWithoutDynamicFieldsInput, VendorUncheckedCreateWithoutDynamicFieldsInput>
    where?: VendorWhereInput
  }

  export type VendorUpdateToOneWithWhereWithoutDynamicFieldsInput = {
    where?: VendorWhereInput
    data: XOR<VendorUpdateWithoutDynamicFieldsInput, VendorUncheckedUpdateWithoutDynamicFieldsInput>
  }

  export type VendorUpdateWithoutDynamicFieldsInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessName?: StringFieldUpdateOperationsInput | string
    category?: EnumVendorCategoryFieldUpdateOperationsInput | $Enums.VendorCategory
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: IntFieldUpdateOperationsInput | number
    rating?: FloatFieldUpdateOperationsInput | number
    totalReviews?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    documentSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    priceRange?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    gallery?: VendorUpdategalleryInput | string[]
    availability?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutVendorNestedInput
    bookings?: BookingUpdateManyWithoutVendorNestedInput
    services?: ServiceUpdateManyWithoutVendorNestedInput
    reviews?: ReviewUpdateManyWithoutVendorNestedInput
    chatSessions?: ChatSessionUpdateManyWithoutVendorNestedInput
    verificationDocuments?: VendorVerificationDocumentUpdateManyWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateWithoutDynamicFieldsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    businessName?: StringFieldUpdateOperationsInput | string
    category?: EnumVendorCategoryFieldUpdateOperationsInput | $Enums.VendorCategory
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: IntFieldUpdateOperationsInput | number
    rating?: FloatFieldUpdateOperationsInput | number
    totalReviews?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    documentSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    priceRange?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    gallery?: VendorUpdategalleryInput | string[]
    availability?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutVendorNestedInput
    services?: ServiceUncheckedUpdateManyWithoutVendorNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutVendorNestedInput
    chatSessions?: ChatSessionUncheckedUpdateManyWithoutVendorNestedInput
    verificationDocuments?: VendorVerificationDocumentUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type BookingCreateManyUserInput = {
    id?: string
    vendorId: string
    serviceId: string
    eventDate: Date | string
    eventTime: string
    eventDuration: number
    guestCount?: number | null
    location?: string | null
    specialRequests?: string | null
    basePrice: number
    additionalCosts?: number
    totalAmount: number
    status?: $Enums.BookingStatus
    paymentStatus?: $Enums.PaymentStatus
    requestedAt?: Date | string
    approvedAt?: Date | string | null
    confirmedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageCreateManySenderInput = {
    id?: string
    receiverId: string
    bookingId?: string | null
    content: string
    messageType?: string
    attachments?: MessageCreateattachmentsInput | string[]
    isRead?: boolean
    createdAt?: Date | string
  }

  export type MessageCreateManyReceiverInput = {
    id?: string
    senderId: string
    bookingId?: string | null
    content: string
    messageType?: string
    attachments?: MessageCreateattachmentsInput | string[]
    isRead?: boolean
    createdAt?: Date | string
  }

  export type ReviewCreateManyUserInput = {
    id?: string
    vendorId: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    title: string
    message: string
    type: string
    isRead?: boolean
    createdAt?: Date | string
  }

  export type ChatSessionCreateManyUserInput = {
    id?: string
    vendorId: string
    lastMessageAt?: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    eventTime?: StringFieldUpdateOperationsInput | string
    eventDuration?: IntFieldUpdateOperationsInput | number
    guestCount?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    additionalCosts?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneRequiredWithoutBookingsNestedInput
    service?: ServiceUpdateOneRequiredWithoutBookingsNestedInput
    payments?: PaymentUpdateManyWithoutBookingNestedInput
    messages?: MessageUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    eventTime?: StringFieldUpdateOperationsInput | string
    eventDuration?: IntFieldUpdateOperationsInput | number
    guestCount?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    additionalCosts?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutBookingNestedInput
    messages?: MessageUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    eventTime?: StringFieldUpdateOperationsInput | string
    eventDuration?: IntFieldUpdateOperationsInput | number
    guestCount?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    additionalCosts?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    messageType?: StringFieldUpdateOperationsInput | string
    attachments?: MessageUpdateattachmentsInput | string[]
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiver?: UserUpdateOneRequiredWithoutReceivedMessagesNestedInput
    booking?: BookingUpdateOneWithoutMessagesNestedInput
  }

  export type MessageUncheckedUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    messageType?: StringFieldUpdateOperationsInput | string
    attachments?: MessageUpdateattachmentsInput | string[]
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    messageType?: StringFieldUpdateOperationsInput | string
    attachments?: MessageUpdateattachmentsInput | string[]
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUpdateWithoutReceiverInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    messageType?: StringFieldUpdateOperationsInput | string
    attachments?: MessageUpdateattachmentsInput | string[]
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutSentMessagesNestedInput
    booking?: BookingUpdateOneWithoutMessagesNestedInput
  }

  export type MessageUncheckedUpdateWithoutReceiverInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    messageType?: StringFieldUpdateOperationsInput | string
    attachments?: MessageUpdateattachmentsInput | string[]
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyWithoutReceiverInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    messageType?: StringFieldUpdateOperationsInput | string
    attachments?: MessageUpdateattachmentsInput | string[]
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type ReviewUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatSessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    lastMessageAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneRequiredWithoutChatSessionsNestedInput
  }

  export type ChatSessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    lastMessageAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatSessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    lastMessageAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingCreateManyVendorInput = {
    id?: string
    userId: string
    serviceId: string
    eventDate: Date | string
    eventTime: string
    eventDuration: number
    guestCount?: number | null
    location?: string | null
    specialRequests?: string | null
    basePrice: number
    additionalCosts?: number
    totalAmount: number
    status?: $Enums.BookingStatus
    paymentStatus?: $Enums.PaymentStatus
    requestedAt?: Date | string
    approvedAt?: Date | string | null
    confirmedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceCreateManyVendorInput = {
    id?: string
    name: string
    description: string
    price: number
    duration?: number | null
    maxCapacity?: number | null
    includes?: ServiceCreateincludesInput | string[]
    addOns?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewCreateManyVendorInput = {
    id?: string
    userId: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChatSessionCreateManyVendorInput = {
    id?: string
    userId: string
    lastMessageAt?: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VendorVerificationDocumentCreateManyVendorInput = {
    id?: string
    documentType: string
    documentTitle: string
    documentContent: string
    documentHash: string
    signingToken: string
    tokenExpiresAt: Date | string
    signedAt?: Date | string | null
    signatureData?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    ipAddress?: string | null
    userAgent?: string | null
    reviewedBy?: string | null
    reviewedAt?: Date | string | null
    reviewNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VendorDynamicFieldCreateManyVendorInput = {
    id?: string
    fieldName: string
    fieldLabel: string
    fieldType: string
    fieldOptions?: VendorDynamicFieldCreatefieldOptionsInput | string[]
    fieldValue?: string | null
    isRequired?: boolean
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    eventTime?: StringFieldUpdateOperationsInput | string
    eventDuration?: IntFieldUpdateOperationsInput | number
    guestCount?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    additionalCosts?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBookingsNestedInput
    service?: ServiceUpdateOneRequiredWithoutBookingsNestedInput
    payments?: PaymentUpdateManyWithoutBookingNestedInput
    messages?: MessageUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    eventTime?: StringFieldUpdateOperationsInput | string
    eventDuration?: IntFieldUpdateOperationsInput | number
    guestCount?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    additionalCosts?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutBookingNestedInput
    messages?: MessageUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateManyWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    eventTime?: StringFieldUpdateOperationsInput | string
    eventDuration?: IntFieldUpdateOperationsInput | number
    guestCount?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    additionalCosts?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    maxCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    includes?: ServiceUpdateincludesInput | string[]
    addOns?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    maxCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    includes?: ServiceUpdateincludesInput | string[]
    addOns?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateManyWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    maxCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    includes?: ServiceUpdateincludesInput | string[]
    addOns?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type ReviewUncheckedUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatSessionUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    lastMessageAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutChatSessionsNestedInput
  }

  export type ChatSessionUncheckedUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    lastMessageAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatSessionUncheckedUpdateManyWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    lastMessageAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorVerificationDocumentUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: StringFieldUpdateOperationsInput | string
    documentTitle?: StringFieldUpdateOperationsInput | string
    documentContent?: StringFieldUpdateOperationsInput | string
    documentHash?: StringFieldUpdateOperationsInput | string
    signingToken?: StringFieldUpdateOperationsInput | string
    tokenExpiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureData?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorVerificationDocumentUncheckedUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: StringFieldUpdateOperationsInput | string
    documentTitle?: StringFieldUpdateOperationsInput | string
    documentContent?: StringFieldUpdateOperationsInput | string
    documentHash?: StringFieldUpdateOperationsInput | string
    signingToken?: StringFieldUpdateOperationsInput | string
    tokenExpiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureData?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorVerificationDocumentUncheckedUpdateManyWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: StringFieldUpdateOperationsInput | string
    documentTitle?: StringFieldUpdateOperationsInput | string
    documentContent?: StringFieldUpdateOperationsInput | string
    documentHash?: StringFieldUpdateOperationsInput | string
    signingToken?: StringFieldUpdateOperationsInput | string
    tokenExpiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureData?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorDynamicFieldUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    fieldName?: StringFieldUpdateOperationsInput | string
    fieldLabel?: StringFieldUpdateOperationsInput | string
    fieldType?: StringFieldUpdateOperationsInput | string
    fieldOptions?: VendorDynamicFieldUpdatefieldOptionsInput | string[]
    fieldValue?: NullableStringFieldUpdateOperationsInput | string | null
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorDynamicFieldUncheckedUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    fieldName?: StringFieldUpdateOperationsInput | string
    fieldLabel?: StringFieldUpdateOperationsInput | string
    fieldType?: StringFieldUpdateOperationsInput | string
    fieldOptions?: VendorDynamicFieldUpdatefieldOptionsInput | string[]
    fieldValue?: NullableStringFieldUpdateOperationsInput | string | null
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorDynamicFieldUncheckedUpdateManyWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    fieldName?: StringFieldUpdateOperationsInput | string
    fieldLabel?: StringFieldUpdateOperationsInput | string
    fieldType?: StringFieldUpdateOperationsInput | string
    fieldOptions?: VendorDynamicFieldUpdatefieldOptionsInput | string[]
    fieldValue?: NullableStringFieldUpdateOperationsInput | string | null
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingCreateManyServiceInput = {
    id?: string
    userId: string
    vendorId: string
    eventDate: Date | string
    eventTime: string
    eventDuration: number
    guestCount?: number | null
    location?: string | null
    specialRequests?: string | null
    basePrice: number
    additionalCosts?: number
    totalAmount: number
    status?: $Enums.BookingStatus
    paymentStatus?: $Enums.PaymentStatus
    requestedAt?: Date | string
    approvedAt?: Date | string | null
    confirmedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    eventTime?: StringFieldUpdateOperationsInput | string
    eventDuration?: IntFieldUpdateOperationsInput | number
    guestCount?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    additionalCosts?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBookingsNestedInput
    vendor?: VendorUpdateOneRequiredWithoutBookingsNestedInput
    payments?: PaymentUpdateManyWithoutBookingNestedInput
    messages?: MessageUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    eventTime?: StringFieldUpdateOperationsInput | string
    eventDuration?: IntFieldUpdateOperationsInput | number
    guestCount?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    additionalCosts?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutBookingNestedInput
    messages?: MessageUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateManyWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    eventTime?: StringFieldUpdateOperationsInput | string
    eventDuration?: IntFieldUpdateOperationsInput | number
    guestCount?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    additionalCosts?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateManyBookingInput = {
    id?: string
    amount: number
    currency?: string
    paymentMethod: string
    transactionId?: string | null
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.PaymentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageCreateManyBookingInput = {
    id?: string
    senderId: string
    receiverId: string
    content: string
    messageType?: string
    attachments?: MessageCreateattachmentsInput | string[]
    isRead?: boolean
    createdAt?: Date | string
  }

  export type PaymentUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    messageType?: StringFieldUpdateOperationsInput | string
    attachments?: MessageUpdateattachmentsInput | string[]
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutSentMessagesNestedInput
    receiver?: UserUpdateOneRequiredWithoutReceivedMessagesNestedInput
  }

  export type MessageUncheckedUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    messageType?: StringFieldUpdateOperationsInput | string
    attachments?: MessageUpdateattachmentsInput | string[]
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    messageType?: StringFieldUpdateOperationsInput | string
    attachments?: MessageUpdateattachmentsInput | string[]
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatrimonialMessageCreateManyFromProfileInput = {
    id?: string
    toProfileId: string
    content: string
    createdAt?: Date | string
  }

  export type MatrimonialMessageCreateManyToProfileInput = {
    id?: string
    fromProfileId: string
    content: string
    createdAt?: Date | string
  }

  export type MatrimonialMessageUpdateWithoutFromProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    toProfile?: MatrimonialProfileUpdateOneRequiredWithoutReceivedMessagesNestedInput
  }

  export type MatrimonialMessageUncheckedUpdateWithoutFromProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    toProfileId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatrimonialMessageUncheckedUpdateManyWithoutFromProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    toProfileId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatrimonialMessageUpdateWithoutToProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fromProfile?: MatrimonialProfileUpdateOneRequiredWithoutSentMessagesNestedInput
  }

  export type MatrimonialMessageUncheckedUpdateWithoutToProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromProfileId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatrimonialMessageUncheckedUpdateManyWithoutToProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromProfileId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VendorCountOutputTypeDefaultArgs instead
     */
    export type VendorCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VendorCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ServiceCountOutputTypeDefaultArgs instead
     */
    export type ServiceCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ServiceCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BookingCountOutputTypeDefaultArgs instead
     */
    export type BookingCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BookingCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MatrimonialProfileCountOutputTypeDefaultArgs instead
     */
    export type MatrimonialProfileCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MatrimonialProfileCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VendorDefaultArgs instead
     */
    export type VendorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VendorDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ServiceDefaultArgs instead
     */
    export type ServiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ServiceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BookingDefaultArgs instead
     */
    export type BookingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BookingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PaymentDefaultArgs instead
     */
    export type PaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PaymentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MessageDefaultArgs instead
     */
    export type MessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MessageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChatSessionDefaultArgs instead
     */
    export type ChatSessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChatSessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReviewDefaultArgs instead
     */
    export type ReviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReviewDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationDefaultArgs instead
     */
    export type NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WeddingChecklistDefaultArgs instead
     */
    export type WeddingChecklistArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WeddingChecklistDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AIConversationDefaultArgs instead
     */
    export type AIConversationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AIConversationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MatrimonialProfileDefaultArgs instead
     */
    export type MatrimonialProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MatrimonialProfileDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MatrimonialMessageDefaultArgs instead
     */
    export type MatrimonialMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MatrimonialMessageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VendorVerificationDocumentDefaultArgs instead
     */
    export type VendorVerificationDocumentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VendorVerificationDocumentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VendorDynamicFieldDefaultArgs instead
     */
    export type VendorDynamicFieldArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VendorDynamicFieldDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PackageDynamicFieldDefaultArgs instead
     */
    export type PackageDynamicFieldArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PackageDynamicFieldDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}